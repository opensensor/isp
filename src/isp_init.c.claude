#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <stdarg.h>
#include <sys/ioctl.h>

// Updated ISP device structure based on binary ninja offsets
typedef struct {
    char dev_name[32];     // Device name/path 
    int fd;                // File descriptor (offset 0x20)
    int is_open;           // Device open status (offset 0x24)
    char sensor_name[80];  // Sensor name buffer (offset 0x28)
    char padding1[0x60];   // Padding to 0xac
    void* buf_info;        // Buffer info pointer (offset 0xac)
    int wdr_mode;          // WDR mode flag (offset 0xb0)
    void* wdr_buf_info;    // WDR buffer info pointer (offset 0xb4)
    char padding2[0x28];   // Padding to match 0xE0 size
} IMPISPDev;

static IMPISPDev* gISPdev = NULL;


// Define the buffer info structure
struct imp_buffer_info {
    uint32_t paddr;
    uint32_t size;
};


// IOCTL commands from binary ninja
#define VIDIOC_REGISTER_SENSOR     0x805056c1
#define VIDIOC_SELECT_SENSOR       0xc00456c7
#define VIDIOC_GET_SENSOR_ID       0xc050561a
#define VIDIOC_SET_SENSOR         0xc0045627
#define VIDIOC_GET_BUF_INFO       0x800856d5
#define VIDIOC_SET_BUF_INFO       0x800856d4
#define VIDIOC_GET_WDR_BUF_INFO   0x800856d7
#define VIDIOC_SET_WDR_BUF_INFO   0x800856d6


// Mock implementation of IMP_Alloc for testing
static int IMP_Alloc(void* buf, int size, const char* name) {
    // Simple implementation for testing
    printf("IMP_Alloc called with size %d, name %s\n", size, name);
    *(uint32_t*)((char*)buf + 0x84) = 0x1000; // Mock physical address
    return 0;
}


/* ISP Related Definitions copied from IMP headers */
#define TX_SENSOR_CONTROL_INTERFACE_I2C        1
#define IMPISP_TUNING_OPS_MODE_ENABLE         1
#define IMPISP_RUNNING_MODE_DAY               1

typedef struct {
    char type[32];
    int addr;
    // Add any other i2c fields needed
} imp_isp_i2c_info;

typedef struct {
    char name[32];
    int cbus_type;
    imp_isp_i2c_info i2c;
    // Add other sensor fields as needed
} IMPSensorInfo;


// Log level definitions (matching binary ninja's imp_log_fun levels)
#define IMP_LOG_ERROR   6
#define IMP_LOG_INFO    3
#define IMP_LOG_DEBUG   4

// Mock implementation of the logging function seen in binary ninja
static void imp_log_fun(int level, int option, int arg2, const char* file, 
                       const char* func, int line, const char* fmt, ...) {
    // Simple implementation for testing
    printf("LOG [%d]: ", level);
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    printf("\n");
}

// Mock implementation of IMP_Log_Get_Option
static int IMP_Log_Get_Option(void) {
    return 0;
}

/* Function declarations that would be in IMP */
static int IMP_ISP_Open(void);
static int IMP_ISP_AddSensor(IMPSensorInfo *sensor);
static int IMP_ISP_EnableSensor(void);
static int IMP_System_Init(void);
static int IMP_ISP_EnableTuning(void);

int IMP_ISP_Open(void) {
    int result = 0;

    printf("IMP_ISP_Open called\n");    
    // Check if device is already initialized
    if (gISPdev == 0) {
        // Allocate device structure (0xE0 bytes as seen in binary ninja)
        gISPdev = (IMPISPDev*)calloc(1, sizeof(IMPISPDev));
        
        if (gISPdev == NULL) {
            imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                       __FILE__, __func__, __LINE__,
                       "Failed to alloc gISPdev!\n");
            return -1;
        }
        
        // Copy device name (as seen at 0x8b778)
        strcpy(gISPdev->dev_name, "/dev/tx-isp");
        
        // Open the device with flags 0x80002 (O_RDWR | O_NONBLOCK)
        gISPdev->fd = open(gISPdev->dev_name, O_RDWR | O_NONBLOCK);
        
        if (gISPdev->fd < 0) {
            imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                       __FILE__, __func__, __LINE__,
                       "Cannot open %s\n", gISPdev->dev_name);
            free(gISPdev);
            gISPdev = NULL;
            return -1;
        }
        
        // Set device as open (offset 0x24 set to 1 in binary ninja)
        gISPdev->is_open = 1;
        
        // Log successful open
        imp_log_fun(IMP_LOG_INFO, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "~~~~~~ %s[%d] ~~~~~~~\n", "IMP_ISP_Open", __LINE__);
    }
    
    return result;
}


static void dump_sensor_info(IMPSensorInfo *sensor) {
    printf("Sensor Info:\n");
    printf("  Name: %s\n", sensor->name);
    printf("  CBUS Type: %d\n", sensor->cbus_type);
    printf("  I2C Info:\n");
    printf("    Type: %s\n", sensor->i2c.type);
    printf("    Addr: 0x%x\n", sensor->i2c.addr);
}

// Structure for wrapping the sensor info for ioctl
struct sensor_reg_info {
    char sensor_name[32];
    uint32_t cbus_type;
    struct {
        char type[32];
        uint32_t addr;
    } i2c;
    uint32_t reg_width;      // Adding register width
    uint32_t sensor_id;      // Adding sensor ID
    uint32_t sensor_type;    // Adding sensor type
    uint32_t sensor_addr;    // Adding sensor address
};

int IMP_ISP_AddSensor(IMPSensorInfo *sensor) {
    if (gISPdev == NULL) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "ISPDEV cannot open\n");
        return -1;
    }

    if (gISPdev->is_open >= 2) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "Sensor is running, please Call 'Enable' after 'AddSensor'\n");
        return -1;
    }

    // Prepare sensor registration info
    struct sensor_reg_info reg_info;
    memset(&reg_info, 0, sizeof(reg_info));
    
    strncpy(reg_info.sensor_name, sensor->name, sizeof(reg_info.sensor_name) - 1);
    reg_info.cbus_type = sensor->cbus_type;
    strncpy(reg_info.i2c.type, sensor->i2c.type, sizeof(reg_info.i2c.type) - 1);
    reg_info.i2c.addr = sensor->i2c.addr;
    reg_info.reg_width = 16;  // Most common for GC2053
    reg_info.sensor_id = 0;   // Will be assigned by driver
    reg_info.sensor_type = 0; // Default sensor type
    reg_info.sensor_addr = sensor->i2c.addr;  // Use I2C address
    
    // Debug print the registration info
    printf("Registering sensor with:\n");
    printf("  Name: %s\n", reg_info.sensor_name);
    printf("  CBUS Type: %d\n", reg_info.cbus_type);
    printf("  I2C Type: %s\n", reg_info.i2c.type);
    printf("  I2C Addr: 0x%x\n", reg_info.i2c.addr);
    printf("  Reg Width: %d\n", reg_info.reg_width);
    printf("  Sensor Type: %d\n", reg_info.sensor_type);
    printf("  Sensor Addr: 0x%x\n", reg_info.sensor_addr);

    // Register sensor with expanded info structure
    if (ioctl(gISPdev->fd, VIDIOC_REGISTER_SENSOR, &reg_info) != 0) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "VIDIOC_REGISTER_SENSOR(%s) error\n", sensor->name);
        perror("VIDIOC_REGISTER_SENSOR ioctl error");
        return -1;
    }

    // Copy sensor name to device structure
    strncpy(gISPdev->sensor_name, sensor->name, sizeof(gISPdev->sensor_name) - 1);
    
    // Find sensor ID
    int sensor_id = -1;
    int curr_id = 0;
    char curr_name[32];

    while (ioctl(gISPdev->fd, VIDIOC_GET_SENSOR_ID, &curr_id) == 0) {
        memset(curr_name, 0, sizeof(curr_name));
        if (strcmp(sensor->name, curr_name) == 0) {
            sensor_id = curr_id;
            break;
        }
        curr_id++;
    }

    if (sensor_id == -1) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "sensor[%s] hasn't been added!\n", sensor->name);
        return -1;
    }

    // Select sensor
    if (ioctl(gISPdev->fd, VIDIOC_SET_SENSOR, &sensor_id) != 0) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "Failed to select sensor[%s]!\n", sensor->name);
        return -1;
    }

    // Get buffer info
    struct imp_buffer_info buf_info = {0};

    if (ioctl(gISPdev->fd, VIDIOC_GET_BUF_INFO, &buf_info) != 0) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "VIDIOC_GET_BUF_INFO() error!\n");
        perror("VIDIOC_GET_BUF_INFO ioctl error");  // Add more error info
        return -1;
    }

    imp_log_fun(IMP_LOG_DEBUG, IMP_Log_Get_Option(), 2,
               __FILE__, __func__, __LINE__,
               "%s,%d: paddr = 0x%x, size = 0x%x\n",
               __func__, __LINE__, buf_info.paddr, buf_info.size);

    // Allocate buffer info structure
    void* ncubuf = malloc(0x94);  // Size from binary ninja
    if (ncubuf == NULL) {
        printf("error(%s,%d): malloc err\n", __func__, __LINE__);
        return -1;
    }

    // Initialize buffer
    if (IMP_Alloc(ncubuf, buf_info.size, "ncubuf") != 0) {
        printf("error(%s,%d): IMP_Alloc\n", __func__, __LINE__);
        free(ncubuf);
        return -1;
    }

    // Save buffer info pointer
    gISPdev->buf_info = ncubuf;
    uint32_t phys_addr = *(uint32_t*)((char*)ncubuf + 0x84);

    // Set buffer info
    if (ioctl(gISPdev->fd, VIDIOC_SET_BUF_INFO, &phys_addr) != 0) {
        imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                   __FILE__, __func__, __LINE__,
                   "VIDIOC_SET_BUF_INFO() error!\n");
        perror("VIDIOC_SET_BUF_INFO ioctl error");  // Add more error info
        return -1;
    }

    // Handle WDR mode if enabled
    if (gISPdev->wdr_mode == 1) {
        struct imp_buffer_info wdr_buf_info = {0};

        if (ioctl(gISPdev->fd, VIDIOC_GET_WDR_BUF_INFO, &wdr_buf_info) != 0) {
            imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                       __FILE__, __func__, __LINE__,
                       "VIDIOC_GET_WDR_BUF_INFO() error!\n");
            perror("VIDIOC_GET_WDR_BUF_INFO ioctl error");
            return -1;
        }

        void* wdrbuf = malloc(0x94);
        if (!wdrbuf) {
            printf("error(%s,%d): malloc err\n", __func__, __LINE__);
            return -1;
        }

        if (IMP_Alloc(wdrbuf, wdr_buf_info.size, "wdrbuf") != 0) {
            printf("error(%s,%d): IMP_Alloc\n", __func__, __LINE__);
            free(wdrbuf);
            return -1;
        }

        gISPdev->wdr_buf_info = wdrbuf;
        phys_addr = *(uint32_t*)((char*)wdrbuf + 0x84);

        if (ioctl(gISPdev->fd, VIDIOC_SET_WDR_BUF_INFO, &phys_addr) != 0) {
            imp_log_fun(IMP_LOG_ERROR, IMP_Log_Get_Option(), 2,
                       __FILE__, __func__, __LINE__,
                       "VIDIOC_SET_WDR_BUF_INFO() error!\n");
            perror("VIDIOC_SET_WDR_BUF_INFO ioctl error");
            return -1;
        }
    }

    return 0;
}


static int IMP_ISP_EnableSensor(void) {
    printf("IMP_ISP_EnableSensor called\n");
    return 0;
}

static int IMP_System_Init(void) {
    printf("IMP_System_Init called\n");
    return 0;
}

static int IMP_ISP_EnableTuning(void) {
    printf("IMP_ISP_EnableTuning called\n");
    return 0;
}

/* Main test code */
#define ISP_BASE_ADDR 0x13300000
#define ISP_MAP_SIZE  0x100000

/* Register offsets from binary ninja analysis */
#define REG_CONTROL          0x4
#define REG_BAYER_PATTERN    0x8
#define REG_BYPASS           0xc
#define REG_DEIR_CONTROL     0x1c
#define REG_STATUS           0x30
#define REG_BUFFER_BASE      0xa02c
#define REG_BUFFER_CONFIG    0xa04c

static void write_isp_register(void *map_base, uint32_t offset, uint32_t value) {
    if (!map_base) {
        printf("Error: Memory not mapped\n");
        return;
    }
    volatile uint32_t *reg = (uint32_t *)((char *)map_base + offset);
    *reg = value;
    printf("Wrote 0x%08x to register offset 0x%08x\n", value, offset);
}

static uint32_t read_isp_register(void *map_base, uint32_t offset) {
    if (!map_base) {
        printf("Error: Memory not mapped\n");
        return 0;
    }
    volatile uint32_t *reg = (uint32_t *)((char *)map_base + offset);
    uint32_t value = *reg;
    printf("Read 0x%08x from register offset 0x%08x\n", value, offset);
    return value;
}

static int verify_register_write(void *map_base, uint32_t offset, uint32_t value) {
    write_isp_register(map_base, offset, value);
    uint32_t readback = read_isp_register(map_base, offset);
    
    if (readback != value) {
        printf("Register verification failed at offset 0x%x: wrote 0x%x, read 0x%x\n",
               offset, value, readback);
        return -1;
    }
    return 0;
}

int main(void) {
    printf("Starting ISP initialization...\n");
    printf("ISP physical base address: 0x%08x\n", ISP_BASE_ADDR);

    /* Initialize IMP system first */
    IMPSensorInfo sinfo;
    memset(&sinfo, 0, sizeof(IMPSensorInfo));
    strcpy(sinfo.name, "gc2053");  // Example sensor
    sinfo.cbus_type = TX_SENSOR_CONTROL_INTERFACE_I2C;
    strcpy(sinfo.i2c.type, "gc2053");
    sinfo.i2c.addr = 0x37;  // Example address

    IMP_ISP_Open();
    IMP_ISP_AddSensor(&sinfo);
    IMP_ISP_EnableSensor();
    IMP_System_Init();
    IMP_ISP_EnableTuning();

    /* Now try direct register access */
    int mem_fd = open("/dev/mem", O_RDWR | O_SYNC);
    if (mem_fd < 0) {
        perror("Failed to open /dev/mem");
        return 1;
    }

    void *map_base = mmap(NULL, ISP_MAP_SIZE, PROT_READ | PROT_WRITE, 
                         MAP_SHARED, mem_fd, ISP_BASE_ADDR);
    if (map_base == MAP_FAILED) {
        perror("Failed to mmap");
        close(mem_fd);
        return 1;
    }

    printf("Memory mapped successfully at %p\n", map_base);
    printf("Virtual to physical offset: 0x%lx\n", 
           (unsigned long)map_base - ISP_BASE_ADDR);

    /* Test register access */
    printf("\nTesting register access...\n");
    uint32_t test_value = 0xAA55AA55;
    verify_register_write(map_base, REG_CONTROL, test_value);

    /* Read initial status */
    uint32_t initial_status = read_isp_register(map_base, REG_STATUS);
    printf("Initial status register: 0x%08x\n", initial_status);

    /* Cleanup */
    if (munmap(map_base, ISP_MAP_SIZE) != 0) {
        perror("Failed to unmap memory");
    }
    close(mem_fd);

    return 0;
}
