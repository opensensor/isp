[   10.191178] RTW: start auth
[   10.195762] RTW: auth success, start assoc
[   10.200902] RTW: assoc success
[   10.201990] IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
[   10.202541] RTW: ============ STA [e8:9c:25:02:11:0c]  ===================
[   10.202551] RTW: mac_id : 0
[   10.202557] RTW: wireless_mode : 0x0b
[   10.202562] RTW: mimo_type : 0
[   10.202568] RTW: static smps : N
[   10.202574] RTW: bw_mode : 20MHz, ra_bw_mode : 20MHz
[   10.202580] RTW: rate_id : 3
[   10.202586] RTW: rssi : -1 (%), rssi_level : 0
[   10.202592] RTW: is_support_sgi : Y, is_vht_enable : N
[   10.202598] RTW: disable_ra : N, disable_pt : N
[   10.202603] RTW: is_noisy : N
[   10.202608] RTW: txrx_state : 0
[   10.202615] RTW: curr_tx_rate : CCK_1M (L)
[   10.202620] RTW: curr_tx_bw : 20MHz
[   10.202626] RTW: curr_retry_ratio : 0
[   10.202632] RTW: ra_mask : 0x00000000000fffff
[   10.202632] 
[   10.205878] RTW: recv eapol packet 1/4
[   10.207046] RTW: send eapol packet 2/4
[   10.212602] RTW: recv eapol packet 3/4
[   10.212984] RTW: send eapol packet 4/4
[   10.214157] RTW: set pairwise key camid:0, addr:e8:9c:25:02:11:0c, kid:0, type:AES
[   10.214440] RTW: set group key camid:1, addr:e8:9c:25:02:11:0c, kid:2, type:AES
[   13.626085] codec_codec_ctl: set repaly channel...
[   13.626123] cgu_set_rate, parent = 1392000000, rate = 4096000, n = 10875, reg val = 0x22002a7b
[   13.626129] codec_codec_ctl: set sample rate...
[   13.626215] codec_codec_ctl: set device...
[   13.859160] codec_set_device: set device: speaker...
[   79.267698] ISP Register Monitor v1.3 initializing
[   79.267837] ISP Monitor: initialized region isp-w01 at phys 0x0x10023000 size 0x1000
[   79.295340] ISP Monitor: initialized region isp-m0 at phys 0x0x13300000 size 0x100000
[   79.304928] ISP Monitor: initialized region isp-w02 at phys 0x0x133e0000 size 0x10000
[   79.305064] ISP Monitor: initialized region isp-csi at phys 0x0x10022000 size 0x1000
[   81.327841] TX ISP driver initializing with new subdevice management system...
[   81.327852] *** Using reference driver interrupt-driven frame processing ***
[   81.327858] *** CRITICAL: REGISTERING SUBDEV PLATFORM DRIVERS FIRST ***
[   81.327863] *** TX ISP SUBDEV PLATFORM DRIVERS REGISTRATION ***
[   81.341837] All ISP subdev platform drivers registered successfully
[   81.341850] *** SUBDEV PLATFORM DRIVERS REGISTERED - VIC/CSI/VIN/CORE DRIVERS AVAILABLE ***
[   81.341856] *** CRITICAL: INITIALIZING SUBDEVICE REGISTRY BEFORE MAIN PLATFORM DEVICE ***
[   81.341861] *** CRITICAL: Registering main platform driver ***
[   81.344301] *** Main platform driver registered successfully ***
[   81.344313] *** REFERENCE DRIVER: Subdev platform devices will be registered by tx_isp_create_graph_and_nodes ***
[   81.356999] *** PROBE: tx_isp_platform_probe CALLED for device tx-isp ***
[   81.357017] *** PROBE: ISP device allocated successfully: 81124000 ***
[   81.357034] *** PROBE: ISP device mutex and spinlock initialized ***
[   81.357041] *** PROBE: Event callback structure initialized at 0x85eac500 (offset 0xc from isp_dev) ***
[   81.357051] parse_rmem_bootarg: Found rmem=29M@0x06300000 (size=0x01d00000)
[   81.357058] *** PROBE: Initialized rmem_addr=0x06300000, size=0x01d00000 ***
[   81.357065] *** PROBE: Platform data: c068b178 ***
[   81.357069] *** PROBE: Platform data validation passed ***
[   81.357075] *** REFERENCE DRIVER: Individual subdevices will initialize their own memory regions ***
[   81.357081] *** PLATFORM DEVICES ALREADY REGISTERED IN INIT - SKIPPING DUPLICATE REGISTRATION ***
[   81.357087] *** tx_isp_module_init: EXACT Binary Ninja reference implementation ***
[   81.359593] *** tx_isp_create_graph_and_nodes: EXACT Binary Ninja reference implementation ***
[   81.359607] *** Registering platform device 0 from platform data ***
[   81.362381] *** tx_isp_subdev_init: CALLED for device 'isp-w00' ***
[   81.362397] *** tx_isp_subdev_init: pdev=c068ae80, sd=85209400, ops=c068b480 ***
[   81.362403] *** tx_isp_subdev_init: ourISPdev=81124000 ***
[   81.362410] *** tx_isp_subdev_init: ops=c068b480, ops->core=c068b4b0 ***
[   81.362416] *** tx_isp_subdev_init: ops->core->init=c06501e8 ***
[   81.362423] *** tx_isp_subdev_init: Set sd->dev=c068ae90, sd->pdev=c068ae80 ***
[   81.362428] *** tx_isp_subdev_init: CSI subdev registered at index 1 ***
[   81.362435] tx_isp_module_init: Module initialized for isp-w00
[   81.362440] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   81.362447] *** isp-w00: Skipping IRQ request - device has no IRQ resource ***
[   81.362453] tx_isp_subdev_init: platform_get_resource returned c068af64 for device isp-w00
[   81.362462] tx_isp_subdev_init: Memory resource found: start=0x10022000, end=0x10022fff, size=0x00001000
[   81.362471] isp_subdev_init_clks: Initializing 2 clocks
[   81.362479] Found clock: cgu_isp
[   81.362488] ISP clock enabled at 100MHz
[   81.362495] Found ISP clock: isp
[   81.362501] ISP core clock enabled
[   81.385993] CPM clock gates configured
[   81.386007] isp_subdev_init_clks: Successfully initialized 2 clocks
[   81.386017] *** tx_isp_subdev_auto_link: ENTRY - pdev=c068ae80, sd=85209400, ourISPdev=81124000 ***
[   81.386025] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-w00' to ourISPdev=81124000 ***
[   81.386031] *** DEBUG: Device name comparison - checking 'isp-w00' ***
[   81.386035] *** DEBUG: About to check device name matches ***
[   81.386042] *** CSI BASIC REGISTERS SET: b0022000 (from tx_isp_subdev_init) ***
[   81.386119] *** LINKED CSI device: 85209400, regs: b0022000 ***
[   81.386127] *** CSI PROBE: Set dev_priv to csi_dev 85209400 AFTER subdev_init ***
[   81.386133] *** CSI PROBE: Set host_priv to csi_dev 85209400 AFTER subdev_init ***
[   81.386139] *** CSI PROBE: Using register mapping from tx_isp_subdev_init: b0022000 ***
[   81.386146] *** CSI PROBE: Device linking handled automatically by tx_isp_subdev_init ***
[   81.386169] *** Platform device 0 (isp-w00) registered successfully ***
[   81.386175] *** Registering platform device 1 from platform data ***
[   81.391323] ISP isp-w02: [CSI PHY Control] write at offset 0x4: 0x0 -> 0x7800438 (delta: 0.000 ms)
[   81.391338] ISP isp-w02: [CSI PHY Control] write at offset 0xc: 0x0 -> 0x2 (delta: 0.000 ms)
[   81.391347] ISP isp-w02: [CSI PHY Control] write at offset 0x14: 0x0 -> 0x2 (delta: 0.000 ms)
[   81.391357] ISP isp-w02: [CSI PHY Control] write at offset 0x18: 0x0 -> 0xf00 (delta: 0.000 ms)
[   81.391369] ISP isp-w02: [CSI PHY Control] write at offset 0x60: 0x0 -> 0x800800 (delta: 0.000 ms)
[   81.391379] ISP isp-w02: [CSI PHY Control] write at offset 0x64: 0x0 -> 0x9d09d0 (delta: 0.000 ms)
[   81.391388] ISP isp-w02: [CSI PHY Control] write at offset 0x70: 0x0 -> 0x6002 (delta: 0.000 ms)
[   81.391397] ISP isp-w02: [CSI PHY Control] write at offset 0x74: 0x0 -> 0x7003 (delta: 0.000 ms)
[   81.391410] ISP isp-w02: [CSI PHY Control] write at offset 0xc0: 0x0 -> 0xeb8080 (delta: 0.000 ms)
[   81.391419] ISP isp-w02: [CSI PHY Control] write at offset 0xc4: 0x0 -> 0x108080 (delta: 0.000 ms)
[   81.391429] ISP isp-w02: [CSI PHY Control] write at offset 0xc8: 0x0 -> 0x29f06e (delta: 0.000 ms)
[   81.391438] ISP isp-w02: [CSI PHY Control] write at offset 0xcc: 0x0 -> 0x913622 (delta: 0.000 ms)
[   81.391447] ISP isp-w02: [CSI PHY Control] write at offset 0xd0: 0x0 -> 0x515af0 (delta: 0.000 ms)
[   81.391457] ISP isp-w02: [CSI PHY Control] write at offset 0xd4: 0x0 -> 0xaaa610 (delta: 0.000 ms)
[   81.391466] ISP isp-w02: [CSI PHY Control] write at offset 0xd8: 0x0 -> 0xd21092 (delta: 0.000 ms)
[   81.391475] ISP isp-w02: [CSI PHY Control] write at offset 0xdc: 0x0 -> 0x6acade (delta: 0.000 ms)
[   81.391485] ISP isp-w02: [CSI PHY Control] write at offset 0xe0: 0x0 -> 0xeb8080 (delta: 0.000 ms)
[   81.391494] ISP isp-w02: [CSI PHY Control] write at offset 0xe4: 0x0 -> 0x108080 (delta: 0.000 ms)
[   81.391503] ISP isp-w02: [CSI PHY Control] write at offset 0xe8: 0x0 -> 0x29f06e (delta: 0.000 ms)
[   81.391513] ISP isp-w02: [CSI PHY Control] write at offset 0xec: 0x0 -> 0x913622 (delta: 0.000 ms)
[   81.391522] ISP isp-w02: [CSI PHY Control] write at offset 0xf0: 0x0 -> 0x515af0 (delta: 0.000 ms)
[   81.391531] ISP isp-w02: [CSI PHY Control] write at offset 0xf4: 0x0 -> 0xaaa610 (delta: 0.000 ms)
[   81.391540] ISP isp-w02: [CSI PHY Control] write at offset 0xf8: 0x0 -> 0xd21092 (delta: 0.000 ms)
[   81.391549] ISP isp-w02: [CSI PHY Control] write at offset 0xfc: 0x0 -> 0x6acade (delta: 0.000 ms)
[   81.391559] ISP isp-w02: [CSI PHY Config] write at offset 0x100: 0x0 -> 0x2d0 (delta: 0.000 ms)
[   81.391569] ISP isp-w02: [CSI PHY Config] write at offset 0x10c: 0x0 -> 0x2c000 (delta: 0.000 ms)
[   81.391578] ISP isp-w02: [CSI PHY Config] write at offset 0x110: 0x0 -> 0x7800000 (delta: 0.000 ms)
[   81.391593] ISP isp-w02: [CSI PHY Config] write at offset 0x1a4: 0x0 -> 0x100010 (delta: 0.000 ms)
[   81.391603] ISP isp-w02: [CSI PHY Config] write at offset 0x1a8: 0x0 -> 0x4440 (delta: 0.000 ms)
[   81.391612] ISP isp-w02: [CSI PHY Config] write at offset 0x1b0: 0x0 -> 0x10 (delta: 0.000 ms)
[   81.394765] *** VIC PROBE: IRQ numbers initialized to 38 ***
[   81.394780] *** VIC PROBE: Primary VIC registers mapped at 0x133e0000 -> b33e0000 ***
[   81.394787] *** VIC PROBE: VIC control registers mapped at 0x10023000 -> b0023000 ***
[   81.394793] *** VIC PROBE: Hardware IRQ function pointers set using SAFE struct members (tx_isp_enable/disable_irq) ***
[   81.394799] *** VIC PROBE: Secondary VIC register test - 0x1e0 = 0x00000000 (mapping verified) ***
[   81.394805] *** BINARY NINJA MCP: VIC buffer management ENABLED - following reference driver ***
[   81.394811] *** VIC will operate in FULL mode with complete buffer operations ***
[   81.394817] *** BINARY NINJA MCP: VIC full initialization complete - buffer management ENABLED ***
[   81.394823] *** VIC PROBE: Initialized default dimensions 1920x1080 and critical fields ***
[   81.394829] *** VIC PROBE: Event callback structure stored in VIC device field ***
[   81.394835] *** VIC PROBE: Stored vic_dev pointer 85be2000 in subdev dev_priv ***
[   81.394842] *** VIC PROBE: Set host_priv to vic_dev 85be2000 for Binary Ninja compatibility ***
[   81.394849] *** tx_isp_subdev_init: CALLED for device 'isp-w02' ***
[   81.394857] *** tx_isp_subdev_init: pdev=c068af80, sd=85be2000, ops=c068b410 ***
[   81.394863] *** tx_isp_subdev_init: ourISPdev=81124000 ***
[   81.394869] *** tx_isp_subdev_init: ops=c068b410, ops->core=c068b428 ***
[   81.394875] *** tx_isp_subdev_init: ops->core->init=c064eb3c ***
[   81.394882] *** tx_isp_subdev_init: Set sd->dev=c068af90, sd->pdev=c068af80 ***
[   81.394888] *** tx_isp_subdev_init: VIC device linked and registered at index 3 ***
[   81.394894] tx_isp_module_init: Module initialized for isp-w02
[   81.394900] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   81.394908] *** tx_isp_request_irq: platform_get_irq returned 38 for device isp-w02 ***
[   81.394915] *** tx_isp_request_irq: Using main ISP device as dev_id for IRQ 38 (device: isp-w02) ***
[   81.394925] *** tx_isp_request_irq: About to call request_threaded_irq(irq=38, handler=c0658ac8, thread=c064bc0c, flags=0x80, name=isp-w02, dev_id=81124000) ***
[   81.397371] *** tx_isp_request_irq: request_threaded_irq returned 0 ***
[   81.397383] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 38 ***
[   81.397390] *** tx_isp_disable_irq: IRQ 38 DISABLED ***
[   81.397397] *** tx_isp_request_irq: IRQ 38 registered successfully for isp-w02 ***
[   81.397406] tx_isp_subdev_init: platform_get_resource returned c068b064 for device isp-w02
[   81.397414] tx_isp_subdev_init: Memory resource found: start=0x133e0000, end=0x133effff, size=0x00010000
[   81.397424] isp_subdev_init_clks: Initializing 2 clocks
[   81.397432] Found clock: cgu_isp
[   81.397438] ISP clock enabled at 100MHz
[   81.397445] Found ISP clock: isp
[   81.397450] ISP core clock enabled
[   81.397483] ISP isp-m0: [CSI PHY Control] write at offset 0x0: 0x0 -> 0x54560031 (delta: 0.000 ms)
[   81.397493] ISP isp-m0: [CSI PHY Control] write at offset 0x4: 0x0 -> 0x7800438 (delta: 0.000 ms)
[   81.397503] ISP isp-m0: [CSI PHY Control] write at offset 0x8: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.397512] ISP isp-m0: [CSI PHY Control] write at offset 0xc: 0x0 -> 0x80700008 (delta: 0.000 ms)
[   81.397522] ISP isp-m0: [CSI PHY Control] write at offset 0x28: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.397531] ISP isp-m0: [CSI PHY Control] write at offset 0x2c: 0x0 -> 0x400040 (delta: 0.000 ms)
[   81.397545] ISP isp-m0: [CSI PHY Control] write at offset 0x90: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.397554] ISP isp-m0: [CSI PHY Control] write at offset 0x94: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.397563] ISP isp-m0: [CSI PHY Control] write at offset 0x98: 0x0 -> 0x30000 (delta: 0.000 ms)
[   81.397573] ISP isp-m0: [CSI PHY Control] write at offset 0xa8: 0x0 -> 0x58050000 (delta: 0.000 ms)
[   81.397583] ISP isp-m0: [CSI PHY Control] write at offset 0xac: 0x0 -> 0x58050000 (delta: 0.000 ms)
[   81.397593] ISP isp-m0: [CSI PHY Control] write at offset 0xc4: 0x0 -> 0x40000 (delta: 0.000 ms)
[   81.397602] ISP isp-m0: [CSI PHY Control] write at offset 0xc8: 0x0 -> 0x400040 (delta: 0.000 ms)
[   81.397611] ISP isp-m0: [CSI PHY Control] write at offset 0xcc: 0x0 -> 0x100 (delta: 0.000 ms)
[   81.397621] ISP isp-m0: [CSI PHY Control] write at offset 0xd4: 0x0 -> 0xc (delta: 0.000 ms)
[   81.397630] ISP isp-m0: [CSI PHY Control] write at offset 0xd8: 0x0 -> 0xffffff (delta: 0.000 ms)
[   81.397639] ISP isp-m0: [CSI PHY Control] write at offset 0xe0: 0x0 -> 0x100 (delta: 0.000 ms)
[   81.397649] ISP isp-m0: [CSI PHY Control] write at offset 0xe4: 0x0 -> 0x400040 (delta: 0.000 ms)
[   81.397659] ISP isp-m0: [CSI PHY Control] write at offset 0xf0: 0x0 -> 0xff808000 (delta: 0.000 ms)
[   81.397669] ISP isp-m0: [CSI PHY Config] write at offset 0x110: 0x0 -> 0x80007000 (delta: 0.000 ms)
[   81.397679] ISP isp-m0: [CSI PHY Config] write at offset 0x114: 0x0 -> 0x777111 (delta: 0.000 ms)
[   81.399501] ISP isp-m0: [ISP Control] write at offset 0x9804: 0x0 -> 0x3f00 (delta: 0.000 ms)
[   81.399515] ISP isp-m0: [ISP Control] write at offset 0x9864: 0x0 -> 0x7800438 (delta: 0.000 ms)
[   81.399525] ISP isp-m0: [ISP Control] write at offset 0x987c: 0x0 -> 0xc0000000 (delta: 0.000 ms)
[   81.399534] ISP isp-m0: [ISP Control] write at offset 0x9880: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399543] ISP isp-m0: [ISP Control] write at offset 0x9884: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399553] ISP isp-m0: [ISP Control] write at offset 0x9890: 0x0 -> 0x1010001 (delta: 0.000 ms)
[   81.399562] ISP isp-m0: [ISP Control] write at offset 0x989c: 0x0 -> 0x1010001 (delta: 0.000 ms)
[   81.399572] ISP isp-m0: [ISP Control] write at offset 0x98a8: 0x0 -> 0x1010001 (delta: 0.000 ms)
[   81.399597] ISP isp-m0: [VIC Control] write at offset 0x9a00: 0x0 -> 0x50002d0 (delta: 0.000 ms)
[   81.399607] ISP isp-m0: [VIC Control] write at offset 0x9a04: 0x0 -> 0x3000300 (delta: 0.000 ms)
[   81.399617] ISP isp-m0: [VIC Control] write at offset 0x9a2c: 0x0 -> 0x50002d0 (delta: 0.000 ms)
[   81.399627] ISP isp-m0: [VIC Control] write at offset 0x9a34: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399638] ISP isp-m0: [VIC Control] write at offset 0x9a70: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399647] ISP isp-m0: [VIC Control] write at offset 0x9a7c: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399657] ISP isp-m0: [VIC Control] write at offset 0x9a80: 0x0 -> 0x500 (delta: 0.000 ms)
[   81.399666] ISP isp-m0: [VIC Control] write at offset 0x9a88: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399675] ISP isp-m0: [VIC Control] write at offset 0x9a94: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.399685] ISP isp-m0: [VIC Control] write at offset 0x9a98: 0x0 -> 0x500 (delta: 0.000 ms)
[   81.399695] ISP isp-m0: [VIC Control] write at offset 0x9ac0: 0x0 -> 0x200 (delta: 0.000 ms)
[   81.399705] ISP isp-m0: [VIC Control] write at offset 0x9ac8: 0x0 -> 0x200 (delta: 0.000 ms)
[   81.399957] ISP isp-m0: [Core Control] write at offset 0xb004: 0x0 -> 0xf001f001 (delta: 0.000 ms)
[   81.399967] ISP isp-m0: [Core Control] write at offset 0xb008: 0x0 -> 0x40404040 (delta: 0.000 ms)
[   81.399976] ISP isp-m0: [Core Control] write at offset 0xb00c: 0x0 -> 0x40404040 (delta: 0.000 ms)
[   81.399985] ISP isp-m0: [Core Control] write at offset 0xb010: 0x0 -> 0x40404040 (delta: 0.000 ms)
[   81.399995] ISP isp-m0: [Core Control] write at offset 0xb014: 0x0 -> 0x404040 (delta: 0.000 ms)
[   81.400005] ISP isp-m0: [Core Control] write at offset 0xb018: 0x0 -> 0x40404040 (delta: 0.000 ms)
[   81.400014] ISP isp-m0: [Core Control] write at offset 0xb01c: 0x0 -> 0x40404040 (delta: 0.000 ms)
[   81.400023] ISP isp-m0: [Core Control] write at offset 0xb020: 0x0 -> 0x40404040 (delta: 0.000 ms)
[   81.400033] ISP isp-m0: [Core Control] write at offset 0xb024: 0x0 -> 0x404040 (delta: 0.000 ms)
[   81.400042] ISP isp-m0: [Core Control] write at offset 0xb028: 0x0 -> 0x1000080 (delta: 0.000 ms)
[   81.400051] ISP isp-m0: [Core Control] write at offset 0xb02c: 0x0 -> 0x1000080 (delta: 0.000 ms)
[   81.400061] ISP isp-m0: [Core Control] write at offset 0xb030: 0x0 -> 0x100 (delta: 0.000 ms)
[   81.400070] ISP isp-m0: [Core Control] write at offset 0xb034: 0x0 -> 0xffff0100 (delta: 0.000 ms)
[   81.400079] ISP isp-m0: [Core Control] write at offset 0xb038: 0x0 -> 0x1ff00 (delta: 0.000 ms)
[   81.400089] ISP isp-m0: [Core Control] write at offset 0xb04c: 0x0 -> 0x103 (delta: 0.000 ms)
[   81.400098] ISP isp-m0: [Core Control] write at offset 0xb050: 0x0 -> 0x3 (delta: 0.000 ms)
[   81.400109] ISP isp-m0: [Core Control] write at offset 0xb07c: 0x0 -> 0x1fffff (delta: 0.000 ms)
[   81.400119] ISP isp-m0: [Core Control] write at offset 0xb080: 0x0 -> 0x1fffff (delta: 0.000 ms)
[   81.400128] ISP isp-m0: [Core Control] write at offset 0xb084: 0x0 -> 0x1fffff (delta: 0.000 ms)
[   81.400137] ISP isp-m0: [Core Control] write at offset 0xb088: 0x0 -> 0x1fdfff (delta: 0.000 ms)
[   81.400147] ISP isp-m0: [Core Control] write at offset 0xb08c: 0x0 -> 0x1fff (delta: 0.000 ms)
[   81.425993] CPM clock gates configured
[   81.426007] isp_subdev_init_clks: Successfully initialized 2 clocks
[   81.426017] *** tx_isp_subdev_auto_link: ENTRY - pdev=c068af80, sd=85be2000, ourISPdev=81124000 ***
[   81.426025] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-w02' to ourISPdev=81124000 ***
[   81.426031] *** DEBUG: Device name comparison - checking 'isp-w02' ***
[   81.426035] *** DEBUG: About to check device name matches ***
[   81.426041] *** DEBUG: VIC DEVICE NAME MATCHED! Processing VIC device linking ***
[   81.426047] *** DEBUG: Retrieved vic_dev from subdev data: 85be2000 ***
[   81.426053] *** DEBUG: About to set ourISPdev->vic_dev = 85be2000 ***
[   81.426059] *** DEBUG: ourISPdev before linking: 81124000 ***
[   81.426065] *** DEBUG: ourISPdev->vic_dev set to: 85be2000 ***
[   81.426071] *** VIC AUTO-LINK: VIC IRQ already registered (irq=38) ***
[   81.426077] *** MAPPED secondary VIC registers: b0023000 (0x10023000) ***
[   81.426083] *** VIC AUTO-LINK: Registers are mapped, registering interrupt handler ***
[   81.426091] *** VIC PROBE: Device linking handled automatically by tx_isp_subdev_init ***
[   81.426115] *** Platform device 1 (isp-w02) registered successfully ***
[   81.426121] *** Registering platform device 2 from platform data ***
[   81.436180] *** tx_isp_subdev_init: CALLED for device 'isp-w01' ***
[   81.436195] *** tx_isp_subdev_init: pdev=c068ada8, sd=8116e200, ops=c068c2b4 ***
[   81.436202] *** tx_isp_subdev_init: ourISPdev=81124000 ***
[   81.436209] *** tx_isp_subdev_init: ops=c068c2b4, ops->core=c068c2d4 ***
[   81.436215] *** tx_isp_subdev_init: ops->core->init=c066ba98 ***
[   81.436221] *** tx_isp_subdev_init: Set sd->dev=c068adb8, sd->pdev=c068ada8 ***
[   81.436228] *** tx_isp_subdev_init: NOT A SENSOR - ops=c068c2b4 ***
[   81.436235] *** tx_isp_subdev_init: ops->sensor=  (null), csi_subdev_ops=c068b480 ***
[   81.436241] tx_isp_module_init: Module initialized for isp-w01
[   81.436247] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   81.436255] *** tx_isp_subdev_auto_link: ENTRY - pdev=c068ada8, sd=8116e200, ourISPdev=81124000 ***
[   81.436262] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-w01' to ourISPdev=81124000 ***
[   81.436268] *** DEBUG: Device name comparison - checking 'isp-w01' ***
[   81.436273] *** DEBUG: About to check device name matches ***
[   81.436279] *** DEBUG: VIN device name matched! Setting up VIN device ***
[   81.436285] *** LINKED VIN device: 8116e200 ***
[   81.436292] *** VIN SUBDEV OPS CONFIGURED: core=c068c2d4, video=c068c2c8, s_stream=c066bcb4 ***
[   81.436297] *** REGISTERED VIN SUBDEV AT INDEX 2 WITH VIDEO OPS ***
[   81.436303] *** VIN INITIALIZATION DEFERRED TO SENSOR REGISTRATION PHASE ***
[   81.436309] *** VIN PROBE: Device linking handled automatically by tx_isp_subdev_init ***
[   81.436327] *** Platform device 2 (isp-w01) registered successfully ***
[   81.436334] *** Registering platform device 3 from platform data ***
[   81.438925] *** tx_isp_subdev_init: CALLED for device 'isp-fs' ***
[   81.438941] *** tx_isp_subdev_init: pdev=c068ac50, sd=8116e400, ops=c068b534 ***
[   81.438947] *** tx_isp_subdev_init: ourISPdev=81124000 ***
[   81.438954] *** tx_isp_subdev_init: ops=c068b534, ops->core=c06923dc ***
[   81.438959] *** tx_isp_subdev_init: WARNING - ops->core->init is NULL! ***
[   81.438967] *** tx_isp_subdev_init: Set sd->dev=c068ac60, sd->pdev=c068ac50 ***
[   81.438973] *** tx_isp_subdev_init: NOT A SENSOR - ops=c068b534 ***
[   81.438979] *** tx_isp_subdev_init: ops->sensor=c06923d0, csi_subdev_ops=c068b480 ***
[   81.438986] tx_isp_module_init: Module initialized for isp-fs
[   81.438991] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   81.438998] *** isp-fs: Skipping IRQ request - device has no IRQ resource ***
[   81.439005] tx_isp_subdev_init: platform_get_resource returned c068ad8c for device isp-fs
[   81.439013] tx_isp_subdev_init: Memory resource found: start=0x13310000, end=0x1331ffff, size=0x00010000
[   81.439024] *** CRITICAL: LINKING FS DEVICE TO ISP DEVICE ***
[   81.439030] *** FS DEVICE LINKED: ourISPdev->fs_dev = 8116e400 ***
[   81.439035] *** CRITICAL: ADDING FS TO SUBDEV ARRAY AT INDEX 3 ***
[   81.439041] *** FS subdev slot (index 3) already occupied by 85be2000 ***
[   81.439060] *** Platform device 3 (isp-fs) registered successfully ***
[   81.439067] *** Registering platform device 4 from platform data ***
[   81.441558] *** tx_isp_core_probe: NEW ARCHITECTURE - Creating separate core device ***
[   81.441571] *** tx_isp_create_core_device: Creating ISP core device ***
[   81.441581] *** tx_isp_create_core_device: Core device created successfully: 85be2400 ***
[   81.441587] *** CORE PROBE: Set dev_priv to core_dev 85be2400 ***
[   81.441593] *** CORE PROBE: Set host_priv to core_dev 85be2400 - PREVENTS BadVA CRASH ***
[   81.441601] *** tx_isp_subdev_init: CALLED for device 'isp-m0' ***
[   81.441608] *** tx_isp_subdev_init: pdev=c068ab30, sd=85be2400, ops=c068b238 ***
[   81.441614] *** tx_isp_subdev_init: ourISPdev=81124000 ***
[   81.441621] *** tx_isp_subdev_init: ops=c068b238, ops->core=c068b268 ***
[   81.441627] *** tx_isp_subdev_init: ops->core->init=c065f220 ***
[   81.441634] *** tx_isp_subdev_init: Set sd->dev=c068ab40, sd->pdev=c068ab30 ***
[   81.441639] *** tx_isp_subdev_init: Core ISP subdev registration handled by core device ***
[   81.441646] tx_isp_module_init: Module initialized for isp-m0
[   81.441651] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   81.441660] *** tx_isp_request_irq: platform_get_irq returned 37 for device isp-m0 ***
[   81.441667] *** tx_isp_request_irq: Using main ISP device as dev_id for IRQ 37 (device: isp-m0) ***
[   81.441677] *** tx_isp_request_irq: About to call request_threaded_irq(irq=37, handler=c0658ac8, thread=c064bc0c, flags=0x80, name=isp-m0, dev_id=81124000) ***
[   81.443938] *** tx_isp_request_irq: request_threaded_irq returned 0 ***
[   81.443950] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 37 ***
[   81.443957] *** tx_isp_disable_irq: IRQ 37 DISABLED ***
[   81.443964] *** tx_isp_request_irq: IRQ 37 registered successfully for isp-m0 ***
[   81.443973] tx_isp_subdev_init: platform_get_resource returned c068ac14 for device isp-m0
[   81.443981] tx_isp_subdev_init: Memory resource found: start=0x13300000, end=0x1330ffff, size=0x00010000
[   81.443991] isp_subdev_init_clks: Initializing 3 clocks
[   81.444007] Found clock: cgu_isp
[   81.444013] ISP clock enabled at 100MHz
[   81.444019] Found ISP clock: isp
[   81.444025] ISP core clock enabled
[   81.444031] Found CSI clock: csi
[   81.444037] CSI/MIPI clock enabled
[   81.461449] ISP isp-w01: [CSI PHY Control] write at offset 0x0: 0x0 -> 0x3130322a (delta: 0.000 ms)
[   81.461465] ISP isp-w01: [CSI PHY Control] write at offset 0x4: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.461475] ISP isp-w01: [CSI PHY Control] write at offset 0x14: 0x0 -> 0x200 (delta: 0.000 ms)
[   81.465999] CPM clock gates configured
[   81.466013] isp_subdev_init_clks: Successfully initialized 3 clocks
[   81.466023] *** tx_isp_subdev_auto_link: ENTRY - pdev=c068ab30, sd=85be2400, ourISPdev=81124000 ***
[   81.466031] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-m0' to ourISPdev=81124000 ***
[   81.466037] *** DEBUG: Device name comparison - checking 'isp-m0' ***
[   81.466042] *** DEBUG: About to check device name matches ***
[   81.466049] *** DEBUG: CORE device name matched! Setting up Core device ***
[   81.466055] *** CRITICAL FIX: CORE regs mapped to core device: b3300000 ***
[   81.466062] *** tx_isp_link_core_device: Linking core device 85be2400 to ISP device 81124000 ***
[   81.466068] *** tx_isp_link_core_device: Core device linked successfully ***
[   81.466074] *** Core subdev registered at index 0: 85be2400 ***
[   81.466080] *** LINKED CORE device: 85be2400 ***
[   81.466085] *** CORE SUBDEV REGISTERED AT INDEX 0 ***
[   81.466090] *** tx_isp_core_probe: Core subdev initialized successfully ***
[   81.466097] *** tx_isp_core_device_init: Initializing core device: 85be2400 ***
[   81.466109] *** tx_isp_core_device_init: State transitions handled by slake_module ***
[   81.466114] *** tx_isp_core_device_init: Core device initialized successfully ***
[   81.466120] *** tx_isp_core_device_init: Core sensor IOCTL handler set for sensor registration ***
[   81.466127] *** tx_isp_link_core_device: Linking core device 85be2400 to ISP device 81124000 ***
[   81.466133] *** tx_isp_link_core_device: Core device linked successfully ***
[   81.466139] *** Core subdev registered at index 0: 85be2400 ***
[   81.466153] *** tx_isp_core_probe: Assigned frame_channels=85be2800 to core_dev ***
[   81.466158] *** tx_isp_core_probe: VIC device creation deferred to platform driver system ***
[   81.466164] *** tx_isp_core_probe: Platform drivers will call tx_isp_subdev_init for proper initialization ***
[   81.466169] *** tx_isp_core_probe: Calling sensor_early_init ***
[   81.466175] sensor_early_init: Preparing sensor infrastructure
[   81.466180] sensor_early_init: Calling tx_isp_detect_and_register_sensors
[   81.466185] *** CRITICAL: Creating I2C sensor devices during ISP initialization ***
[   81.466191] *** Calling subdev_sensor_ops_ioctl with IOCTL 0x2000000 to create I2C sensor device ***
[   81.466197] *** Core subdev sensor IOCTL not available for sensor device creation ***
[   81.466203] *** core_subdev=  (null) ***
[   81.466209] Sensor detection complete - result: 0
[   81.466214] sensor_early_init: Failed to detect and register sensors: -19
[   81.466219] *** tx_isp_core_probe: ISP clock management handled by infrastructure ***
[   81.466225] *** tx_isp_core_probe: Calling ispcore_slake_module for state initialization ***
[   81.466231] *** ispcore_slake_module: EXACT Binary Ninja MCP implementation ***
[   81.466238] ispcore_slake_module: VIC device=85be2000, state=1ispcore_slake_module: Complete, result=0
[   81.466246] *** tx_isp_core_probe: ispcore_slake_module completed successfully ***
[   81.466251] *** tx_isp_core_probe: Core device setup complete ***
[   81.466257] ***   - Core device: 85be2400 ***
[   81.466263] ***   - Channel count: 6 ***
[   81.466268] ***   - Linked to ISP device: 81124000 ***
[   81.466273] *** tx_isp_core_probe: Initializing core tuning system ***
[   81.466279] isp_core_tuning_init: Initializing tuning data structure
[   81.466291] isp_core_tuning_init: Tuning data structure initialized at 84d46000
[   81.466297] isp_core_tuning_init: Structure size: 4356 bytes (vs Binary Ninja 0x40d0)
[   81.466302] *** SAFE: mode_flag properly initialized using struct member access ***
[   81.466307] *** tx_isp_core_probe: Tuning init SUCCESS ***
[   81.466313] *** tx_isp_core_probe: Set platform driver data ***
[   81.466318] *** tx_isp_core_probe: Set global core device reference ***
[   81.466323] *** tx_isp_core_probe: SUCCESS - Core device fully initialized ***
[   81.466329] ***   - Core device: 85be2400 ***
[   81.466335] ***   - Tuning device: 84d46000 ***
[   81.466339] *** tx_isp_core_probe: Creating frame channel devices ***
[   81.466345] *** tx_isp_create_framechan_devices: Creating frame channel devices ***
[   81.476165] *** Created frame channel device: /dev/framechan0 (major=10, minor=54) ***
[   81.478789] *** Created frame channel device: /dev/framechan1 (major=10, minor=53) ***
[   81.481348] *** Created frame channel device: /dev/framechan2 (major=10, minor=52) ***
[   81.483891] *** Created frame channel device: /dev/framechan3 (major=10, minor=51) ***
[   81.483902] *** tx_isp_create_framechan_devices: All frame channel devices created ***
[   81.483908] *** tx_isp_core_probe: Frame channel devices created successfully ***
[   81.483913] *** tx_isp_core_probe: Creating ISP M0 tuning device node ***
[   81.483919] tisp_code_create_tuning_node: Creating ISP M0 tuning device node
[   81.483928] tisp_code_create_tuning_node: Allocated dynamic major 251
[   81.497338] *** ISP M0 TUNING DEVICE CREATED: /dev/isp-m0 (major=251, minor=0) ***
[   81.497349] *** tx_isp_core_probe: ISP M0 tuning device node created successfully ***
[   81.497355] *** tx_isp_core_probe: Core probe completed successfully ***
[   81.497376] *** Platform device 4 (isp-m0) registered successfully ***
[   81.497383] *** tx_isp_create_graph_and_nodes: Creating /proc/jz/isp entries ***
[   81.497405] *** Created /proc/jz/isp directory ***
[   81.497415] *** Created /proc/jz/isp/isp-w00 entry with file ops ***
[   81.497424] *** Created /proc/jz/isp/isp-w02 entry with file ops ***
[   81.497433] *** Created /proc/jz/isp/isp-w01 entry with file ops ***
[   81.497462] *** Created /proc/jz/isp/isp-fs entry with file ops ***
[   81.497472] *** Created /proc/jz/isp/isp-m0 entry with file ops ***
[   81.497478] *** tx_isp_create_graph_and_nodes: Registering misc devices ***
[   81.497483] *** Misc device registration handled via main tx-isp device ***
[   81.497489] *** Misc device registration handled via main tx-isp device ***
[   81.497494] *** Misc device registration handled via main tx-isp device ***
[   81.497499] *** Misc device registration handled via main tx-isp device ***
[   81.497505] *** Misc device registration handled via main tx-isp device ***
[   81.497511] *** tx_isp_create_graph_and_nodes: Initializing frame channels ***
[   81.497519] *** Frame channel 0 initialized: 1920x1080, state=2 ***
[   81.497527] *** Frame channel 1 initialized: 640x360, state=2 ***
[   81.497533] *** tx_isp_create_graph_and_nodes: Binary Ninja reference implementation complete ***
[   81.497541] *** tx_isp_module_init: VIC device linkage check - isp_dev->vic_dev = 85be2000 ***
[   81.497546] *** tx_isp_module_init: VIC device successfully linked ***
[   81.497551] *** tx_isp_module_init: Binary Ninja reference implementation complete ***
[   81.497557] *** PROBE: Binary Ninja reference implementation complete ***
[   81.497567] *** SUCCESS: ourISPdev allocated by probe function: 81124000 ***
[   81.497573] *** Following reference driver: IRQ registration handled by tx_isp_request_irq ***
[   81.497579] TX ISP driver initialized successfully - probe function will handle device setup
[   82.467955] === gc2053 SENSOR MODULE INIT ===
[   82.476118] gc2053 I2C driver registered, waiting for device creation by ISP
root@ing-wyze-cam3-a000 ~# prudynt &
root@ing-wyze-cam3-a000 ~# [INFO:Config.cpp]: Loaded configuration from /etc/prudynt.cfg
[INFO:main.cpp]: PRUDYNT-T Next-Gen Video Daemon: Aug 28 2025 05:46:40_f5514583
[INFO:main.cpp]: Starting Prudynt Video Server.
[INFO:IMPSystem.cpp]: LIBIMP Version IMP-1.1.6
[INFO:IMPSystem.cpp]: SYSUTILS Version: SYSUTILS-1.1.6
[INFO:IMPSystem.cpp]: CPU Information: T31-X
[INFO:IMPSystem.cpp]: Sensor: gc2053
root@ing-wyze-cam3-a000 ~# dmesg ---- FPGA board is ready ----
  Board UID : 30AB6E51
  Board HW ID : 72000460
  Board rev.  : 5DE5A975
  Board date  : 20190326
-----------------------------

[   81.461465] ISP isp-w01: [CSI PHY Control] write at offset 0x4: 0x0 -> 0x1 (delta: 0.000 ms)
[   81.461475] ISP isp-w01: [CSI PHY Control] write at offset 0x14: 0x0 -> 0x200 (delta: 0.000 ms)
[   81.465999] CPM clock gates configured
[   81.466013] isp_subdev_init_clks: Successfully initialized 3 clocks
[   81.466023] *** tx_isp_subdev_auto_link: ENTRY - pdev=c068ab30, sd=85be2400, ourISPdev=81124000 ***
[   81.466031] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-m0' to ourISPdev=81124000 ***
[   81.466037] *** DEBUG: Device name comparison - checking 'isp-m0' ***
[   81.466042] *** DEBUG: About to check device name matches ***
[   81.466049] *** DEBUG: CORE device name matched! Setting up Core device ***
[   81.466055] *** CRITICAL FIX: CORE regs mapped to core device: b3300000 ***
[   81.466062] *** tx_isp_link_core_device: Linking core device 85be2400 to ISP device 81124000 ***
[   81.466068] *** tx_isp_link_core_device: Core device linked successfully ***
[   81.466074] *** Core subdev registered at index 0: 85be2400 ***
[   81.466080] *** LINKED CORE device: 85be2400 ***
[   81.466085] *** CORE SUBDEV REGISTERED AT INDEX 0 ***
[   81.466090] *** tx_isp_core_probe: Core subdev initialized successfully ***
[   81.466097] *** tx_isp_core_device_init: Initializing core device: 85be2400 ***
[   81.466109] *** tx_isp_core_device_init: State transitions handled by slake_module ***
[   81.466114] *** tx_isp_core_device_init: Core device initialized successfully ***
[   81.466120] *** tx_isp_core_device_init: Core sensor IOCTL handler set for sensor registration ***
[   81.466127] *** tx_isp_link_core_device: Linking core device 85be2400 to ISP device 81124000 ***
[   81.466133] *** tx_isp_link_core_device: Core device linked successfully ***
[   81.466139] *** Core subdev registered at index 0: 85be2400 ***
[   81.466153] *** tx_isp_core_probe: Assigned frame_channels=85be2800 to core_dev ***
[   81.466158] *** tx_isp_core_probe: VIC device creation deferred to platform driver system ***
[   81.466164] *** tx_isp_core_probe: Platform drivers will call tx_isp_subdev_init for proper initialization ***
[   81.466169] *** tx_isp_core_probe: Calling sensor_early_init ***
[   81.466175] sensor_early_init: Preparing sensor infrastructure
[   81.466180] sensor_early_init: Calling tx_isp_detect_and_register_sensors
[   81.466185] *** CRITICAL: Creating I2C sensor devices during ISP initialization ***
[   81.466191] *** Calling subdev_sensor_ops_ioctl with IOCTL 0x2000000 to create I2C sensor device ***
[   81.466197] *** Core subdev sensor IOCTL not available for sensor device creation ***
[   81.466203] *** core_subdev=  (null) ***
[   81.466209] Sensor detection complete - result: 0
[   81.466214] sensor_early_init: Failed to detect and register sensors: -19
[   81.466219] *** tx_isp_core_probe: ISP clock management handled by infrastructure ***
[   81.466225] *** tx_isp_core_probe: Calling ispcore_slake_module for state initialization ***
[   81.466231] *** ispcore_slake_module: EXACT Binary Ninja MCP implementation ***
[   81.466238] ispcore_slake_module: VIC device=85be2000, state=1ispcore_slake_module: Complete, result=0
[   81.466246] *** tx_isp_core_probe: ispcore_slake_module completed successfully ***
[   81.466251] *** tx_isp_core_probe: Core device setup complete ***
[   81.466257] ***   - Core device: 85be2400 ***
[   81.466263] ***   - Channel count: 6 ***
[   81.466268] ***   - Linked to ISP device: 81124000 ***
[   81.466273] *** tx_isp_core_probe: Initializing core tuning system ***
[   81.466279] isp_core_tuning_init: Initializing tuning data structure
[   81.466291] isp_core_tuning_init: Tuning data structure initialized at 84d46000
[   81.466297] isp_core_tuning_init: Structure size: 4356 bytes (vs Binary Ninja 0x40d0)
[   81.466302] *** SAFE: mode_flag properly initialized using struct member access ***
[   81.466307] *** tx_isp_core_probe: Tuning init SUCCESS ***
[   81.466313] *** tx_isp_core_probe: Set platform driver data ***
[   81.466318] *** tx_isp_core_probe: Set global core device reference ***
[   81.466323] *** tx_isp_core_probe: SUCCESS - Core device fully initialized ***
[   81.466329] ***   - Core device: 85be2400 ***
[   81.466335] ***   - Tuning device: 84d46000 ***
[   81.466339] *** tx_isp_core_probe: Creating frame channel devices ***
[   81.466345] *** tx_isp_create_framechan_devices: Creating frame channel devices ***
[   81.476165] *** Created frame channel device: /dev/framechan0 (major=10, minor=54) ***
[   81.478789] *** Created frame channel device: /dev/framechan1 (major=10, minor=53) ***
[   81.481348] *** Created frame channel device: /dev/framechan2 (major=10, minor=52) ***
[   81.483891] *** Created frame channel device: /dev/framechan3 (major=10, minor=51) ***
[   81.483902] *** tx_isp_create_framechan_devices: All frame channel devices created ***
[   81.483908] *** tx_isp_core_probe: Frame channel devices created successfully ***
[   81.483913] *** tx_isp_core_probe: Creating ISP M0 tuning device node ***
[   81.483919] tisp_code_create_tuning_node: Creating ISP M0 tuning device node
[   81.483928] tisp_code_create_tuning_node: Allocated dynamic major 251
[   81.497338] *** ISP M0 TUNING DEVICE CREATED: /dev/isp-m0 (major=251, minor=0) ***
[   81.497349] *** tx_isp_core_probe: ISP M0 tuning device node created successfully ***
[   81.497355] *** tx_isp_core_probe: Core probe completed successfully ***
[   81.497376] *** Platform device 4 (isp-m0) registered successfully ***
[   81.497383] *** tx_isp_create_graph_and_nodes: Creating /proc/jz/isp entries ***
[   81.497405] *** Created /proc/jz/isp directory ***
[   81.497415] *** Created /proc/jz/isp/isp-w00 entry with file ops ***
[   81.497424] *** Created /proc/jz/isp/isp-w02 entry with file ops ***
[   81.497433] *** Created /proc/jz/isp/isp-w01 entry with file ops ***
[   81.497462] *** Created /proc/jz/isp/isp-fs entry with file ops ***
[   81.497472] *** Created /proc/jz/isp/isp-m0 entry with file ops ***
[   81.497478] *** tx_isp_create_graph_and_nodes: Registering misc devices ***
[   81.497483] *** Misc device registration handled via main tx-isp device ***
[   81.497489] *** Misc device registration handled via main tx-isp device ***
[   81.497494] *** Misc device registration handled via main tx-isp device ***
[   81.497499] *** Misc device registration handled via main tx-isp device ***
[   81.497505] *** Misc device registration handled via main tx-isp device ***
[   81.497511] *** tx_isp_create_graph_and_nodes: Initializing frame channels ***
[   81.497519] *** Frame channel 0 initialized: 1920x1080, state=2 ***
[   81.497527] *** Frame channel 1 initialized: 640x360, state=2 ***
[   81.497533] *** tx_isp_create_graph_and_nodes: Binary Ninja reference implementation complete ***
[   81.497541] *** tx_isp_module_init: VIC device linkage check - isp_dev->vic_dev = 85be2000 ***
[   81.497546] *** tx_isp_module_init: VIC device successfully linked ***
[   81.497551] *** tx_isp_module_init: Binary Ninja reference implementation complete ***
[   81.497557] *** PROBE: Binary Ninja reference implementation complete ***
[   81.497567] *** SUCCESS: ourISPdev allocated by probe function: 81124000 ***
[   81.497573] *** Following reference driver: IRQ registration handled by tx_isp_request_irq ***
[   81.497579] TX ISP driver initialized successfully - probe function will handle device setup
[   82.467955] === gc2053 SENSOR MODULE INIT ===
[   82.476118] gc2053 I2C driver registered, waiting for device creation by ISP
[   84.884868] *** tx_isp_open: SAFE IMPLEMENTATION - preventing dangerous initialization chains ***
[   84.884882] *** tx_isp_open: SAFE MODE - no hardware initialization during open ***
[   84.884888] *** tx_isp_open: Background processing disabled to prevent delayed crashes ***
[   84.884894] *** tx_isp_open: ISP opened safely - no dangerous operations triggered ***
[   84.885221] ISP IOCTL: cmd=0x805056c1 arg=0x7730dd60
[   84.885230] *** DEBUG: Subdev array contents before IOCTL processing ***
[   84.885239] *** DEBUG: subdevs[0] = 85be2400 (valid=YES, aligned=YES) ***
[   84.885246] *** DEBUG: subdevs[1] = 85209400 (valid=YES, aligned=YES) ***
[   84.885254] *** DEBUG: subdevs[2] = 8116e200 (valid=YES, aligned=YES) ***
[   84.885261] *** DEBUG: subdevs[3] = 85be2000 (valid=YES, aligned=YES) ***
[   84.885269] subdev_sensor_ops_ioctl: cmd=0x2000000
[   84.885274] *** subdev_sensor_ops_ioctl: IOCTL 0x2000000 - Creating I2C sensor device ***
[   84.885280] *** Creating I2C sensor device on adapter 0 ***
[   84.885288] *** Creating I2C device: gc2053 at 0x37 ***
[   84.885294] *** isp_i2c_new_subdev_board: MIPS-SAFE implementation - FIXED CRASH ***
[   84.885302] Creating I2C subdev: type=gc2053 addr=0x37 on adapter i2c0 (MIPS-safe)
[   84.885307] *** MIPS-SAFE: Requesting sensor module gc2053 ***
[   84.888184] *** MIPS-SAFE: Valid I2C address 0x37, creating device ***
[   84.893860] === GC2053 SENSOR PROBE START ===
[   84.893876] sensor_probe: client=856b3d00, addr=0x37, adapter=84074c10 (i2c0)
[   84.893881] === PERFORMING GPIO RESET SEQUENCE BEFORE I2C ===
[   84.893887] Requesting reset GPIO 18
[   84.893896] GPIO reset sequence: HIGH -> LOW -> HIGH
[   85.115852] GPIO reset sequence completed successfully
[   85.115865] === GPIO INITIALIZATION COMPLETE ===
[   85.115876] sensor_probe: Initialized sensor info - name=gc2053, i2c_addr=0x37
[   85.115890] sensor_probe: data_interface=1, sensor_max_fps=30
[   85.115896] sensor_probe: MIPI 30fps
[   85.115904] *** tx_isp_subdev_init: CALLED for device 'gc2053' ***
[   85.115912] *** tx_isp_subdev_init: pdev=c06b1f18, sd=85e1d400, ops=c06b1ff8 ***
[   85.115918] *** tx_isp_subdev_init: ourISPdev=81124000 ***
[   85.115924] *** tx_isp_subdev_init: ops=c06b1ff8, ops->core=c06b2024 ***
[   85.115931] *** tx_isp_subdev_init: ops->core->init=c06af678 ***
[   85.115938] *** tx_isp_subdev_init: Set sd->dev=c06b1f28, sd->pdev=c06b1f18 ***
[   85.115946] *** tx_isp_subdev_init: DETECTED SENSOR SUBDEV - ops=c06b1ff8, ops->sensor=c06b200c ***
[   85.115951] *** tx_isp_subdev_init: Set up sensor module notify handler ***
[   85.115958] *** tx_isp_subdev_init: SENSOR subdev registered at index 5, sd=85e1d400 ***
[   85.115965] *** tx_isp_subdev_init: SENSOR ops=c06b1ff8, ops->sensor=c06b200c ***
[   85.115970] *** tx_isp_subdev_init: Core state transitions handled by slake_module ***
[   85.115977] tx_isp_module_init: Module initialized for (null)
[   85.115992] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   85.116001] *** tx_isp_subdev_auto_link: ENTRY - pdev=c06b1f18, sd=85e1d400, ourISPdev=81124000 ***
[   85.116008] *** tx_isp_subdev_auto_link: Auto-linking device 'gc2053' to ourISPdev=81124000 ***
[   85.116014] *** DEBUG: Device name comparison - checking 'gc2053' ***
[   85.116019] *** DEBUG: About to check device name matches ***
[   85.116026] *** DETECTED SENSOR DEVICE: 'gc2053' - checking for existing registration ***
[   85.116034] *** SENSOR 'gc2053' already registered at subdev index 5 (sd=85e1d400) ***
[   85.116039] *** SENSOR: Skipping duplicate registration to prevent multiple sensor inits ***
[   85.116046] sensor_probe: I2C client association complete
[   85.116054]   sd=85e1d400, client=856b3d00, addr=0x37, adapter=i2c0
[   85.116059] === TESTING I2C COMMUNICATION AFTER GPIO RESET ===
[   85.116068] sensor_read: reg=0xf0, client=856b3d00, adapter=i2c0, addr=0x37
[   85.116478] sensor_read: reg=0xf0 value=0x20 SUCCESS
[   85.116486] I2C test read (0xf0): ret=0, val=0x20 (expected 0x20)
[   85.116491] *** SUCCESS: I2C communication working after GPIO reset! ***
[   85.116500] sensor_read: reg=0xf1, client=856b3d00, adapter=i2c0, addr=0x37
[   85.116988] sensor_read: reg=0xf1 value=0x53 SUCCESS
[   85.116996] I2C test read (0xf1): ret=0, val=0x53 (expected 0x53)
[   85.117001] === I2C COMMUNICATION TEST COMPLETE ===
[   85.117008] Registering gc2053 with ISP framework (sd=85e1d400, sensor=85e1d400)
[   85.117014] === KERNEL SENSOR REGISTRATION ===
[   85.117020] Sensor: gc2053 (subdev=85e1d400)
[   85.117026] gc2053 registered with ISP framework successfully
[   85.117047] *** MIPS-SAFE: I2C device created successfully at 0x856b3d00 ***
[   85.117054] *** MIPS-SAFE: Module reference acquired for gc2053 ***
[   85.117060] *** MIPS-SAFE: Sensor subdev data found, device ready ***
[   85.117067] *** I2C DEVICE READY: gc2053 at 0x37 (MIPS-safe) ***
[   85.117074] *** I2C sensor device created successfully: gc2053 at 0x37 ***
[   85.117091] ISP IOCTL: cmd=0xc050561a arg=0x7ff02228
[   85.117098] TX_ISP_SENSOR_ENUM_INPUT: Enumerating sensor at index 0
[   85.117104] TX_ISP_SENSOR_ENUM_INPUT: Returning sensor 'gc2053' at index 0
[   85.117112] ISP IOCTL: cmd=0xc050561a arg=0x7ff02228
[   85.117118] TX_ISP_SENSOR_ENUM_INPUT: Enumerating sensor at index 1
[   85.117124] TX_ISP_SENSOR_ENUM_INPUT: No sensor at index 1 - returning error to end enumeration
[   85.117132] ISP IOCTL: cmd=0xc0045627 arg=0x7ff02280
[   85.117139] subdev_sensor_ops_ioctl: cmd=0x2000004
[   85.117145] subdev_sensor_ops_ioctl: IOCTL 0x2000004 - Set sensor input
[   85.117150] subdev_sensor_ops_set_input: EXACT Binary Ninja implementation
[   85.117157] subdev_sensor_ops_set_input: Processing input_index=0 from arg=8047be40
[   85.117163] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.117170] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.117177] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.117184] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.117191] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.117198] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.117204] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.117212] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.117218] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.117224] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.117231] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.117238] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.117244] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.117249] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.117254] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.117260] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.117266] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.117271] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.117277] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.117282] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.117288] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.117294] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.117300] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.117307] subdev_sensor_ops_set_input: Current sensor from tx_isp_get_sensor: 85e1d400
[   85.117312] subdev_sensor_ops_set_input: Requested input_index: 0
[   85.117318] subdev_sensor_ops_set_input: Skipping current sensor stop logic - proceeding to sensor selection
[   85.117324] subdev_sensor_ops_set_input: Checking input_index 0 against 0xffffffff
[   85.117330] subdev_sensor_ops_set_input: input_index is valid, proceeding to sensor search
[   85.117336] subdev_sensor_ops_set_input: Searching for sensor at input_index 0
[   85.117343] subdev_sensor_ops_set_input: Found sensor at subdev[5], current_index=0, target=0
[   85.117350] subdev_sensor_ops_set_input: Selected sensor at subdev[5]: 85e1d400
[   85.117356] subdev_sensor_ops_set_input: Found sensor at index 0: 85e1d400
[   85.117363] subdev_sensor_ops_set_input: Sensor input set successfully to index 0
[   85.117368] subdev_sensor_ops_set_input: Stored current_sensor_index = 0
[   85.117377] ISP IOCTL: cmd=0x800856d5 arg=0x7ff02278
[   85.117382] TX_ISP_GET_BUF: IOCTL handler called
[   85.117388] TX_ISP_GET_BUF: core_dev=85be2400, isp_dev=81124000
[   85.117395] TX_ISP_GET_BUF: Using dimensions 1920x1080 from core device
[   85.117402] TX_ISP_GET_BUF: Returning buffer size=4685424, paddr=0x6300000
[   85.192314] ISP IOCTL: cmd=0x800856d4 arg=0x7ff02278
[   85.192328] TX_ISP_SET_BUF: addr=0x6300000 size=0
[   85.195891] ISP IOCTL: cmd=0x40045626 arg=0x7ff02290
[   85.195904] subdev_sensor_ops_ioctl: cmd=0x2000003
[   85.195910] subdev_sensor_ops_ioctl: IOCTL 0x2000003 - Get sensor input
[   85.195916] subdev_sensor_ops_ioctl: Returning current sensor index 0
[   85.195927] ISP IOCTL: cmd=0x80045612 arg=0x0
[   85.195934] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation - enable=1 ***
[   85.195940] *** tx_isp_video_s_stream: Calling specific activate functions before streaming ***
[   85.195946] *** tx_isp_video_s_stream: activate function SUCCESS on subdev[0] ***
[   85.195952] *** tx_isp_video_s_stream: activate function SUCCESS on subdev[1] ***
[   85.195958] *** tx_isp_video_s_stream: Calling tx_isp_vin_activate_subdev on subdev[2] ***
[   85.195965] *** tx_isp_video_s_stream: activate function SUCCESS on subdev[2] ***
[   85.195971] *** tx_isp_video_s_stream: Calling fs_activate_module on subdev[3] ***
[   85.195977] *** fs_activate_module: EXACT Binary Ninja implementation ***
[   85.195983] *** fs_activate_module: Channel 0 activated ***
[   85.195988] *** fs_activate_module: FS state set to 2 (activated) ***
[   85.195993] *** fs_activate_module: SUCCESS ***
[   85.195999] *** tx_isp_video_s_stream: activate function SUCCESS on subdev[3] ***
[   85.196004] *** tx_isp_video_s_stream: Preparing core state for initialization ***
[   85.196010] *** tx_isp_video_s_stream: Current core state: 1 ***
[   85.196016] *** tx_isp_video_s_stream: Transitioning core state from 1 to 2 (ready) ***
[   85.196022] *** tx_isp_video_s_stream: Found ISP Core subdev at index 0 - calling core->init ***
[   85.196028] *** ispcore_core_ops_init: NEW ARCHITECTURE - Using core device, on=1 ***
[   85.196034] *** ispcore_core_ops_init: core_dev=85be2400 ****** ispcore_core_ops_init: Core device valid, current state=2 ***
[   85.196043] *** ispcore_core_ops_init: Frame sync work structure initialized ***<6>[   85.196049] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196057] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196063] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196070] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196077] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196084] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196091] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196098] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196105] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196111] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196118] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196124] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196130] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196136] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196141] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196147] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196152] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196158] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196164] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196169] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196175] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196180] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196187] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196192] ispcore_core_ops_init: Sensor available, skipping sensor_attr access for now
[   85.196198] ispcore_core_ops_init: Core device=85be2400, state=2*** ispcore_core_ops_init: INITIALIZING CORE (on=1) ***
[   85.196206] *** ispcore_core_ops_init: Current vic_state (core state): 2 ****** ispcore_core_ops_init: Core in ready state (2) - normal initialization ***
[   85.196214] *** ispcore_core_ops_init: Core state check passed, proceeding with initialization ****** ispcore_core_ops_init: VIC state set to 3 (ACTIVE) - CORE READY FOR STREAMING ***
[   85.196222] *** ispcore_core_ops_init: Core device state set to 3 (ACTIVE) ***<6>[   85.196228] *** tx_isp_core_enable_irq: Enabling ISP Core hardware interrupts ***
[   85.196236] *** ISP PIPELINE: VIC->ISP connection ENABLED (0x800=1, 0x804=0x1c, 0x1c=8) ***
[   85.196241] *** ISP CORE: Hardware interrupt generation ENABLED ***
[   85.196247] *** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***
[   85.196252] *** ispcore_core_ops_init: ISP Core hardware interrupts enabled ***
[   85.196256] ispcore_core_ops_init: Complete, result=0<6>[   85.196262] *** tx_isp_video_s_stream: ISP Core init SUCCESS - state should now be 3 ***
[   85.196269] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=1 ***
[   85.196276] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=1 ***
[   85.196282] *** CORE STATE CHECK: core_dev->state=3 (need >=3), enable=1 ***
[   85.196288] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.196295] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 37 ***
[   85.196302] *** tx_isp_disable_irq: IRQ 37 DISABLED ***
[   85.196308] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.196315] csi_video_s_stream: sd=85209400, enable=1
[   85.196320] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196327] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196334] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196341] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196348] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196355] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196361] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196368] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196375] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196381] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196388] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196394] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196400] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196406] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196412] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196417] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196423] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196428] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196434] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196440] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196445] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196451] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196458] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196463] csi_video_s_stream: Stream ON - CSI state set to 4
[   85.196470] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=1 ***
[   85.196477] vin_s_stream: VIN state = 2, enable = 1
[   85.196482] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196490] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196496] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196504] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196510] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196518] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196524] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196531] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196538] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196544] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196551] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196558] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196563] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196568] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196574] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196580] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196585] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196591] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196596] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196602] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196608] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196614] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196620] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196626] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.196632] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   85.196639] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=1 ***
[   85.196645] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=3 ***
[   85.196650] *** vic_core_s_stream: STREAM ON ***
[   85.196656] *** vic_core_s_stream: State != 4, calling VIC start sequence ***
[   85.196661] *** vic_core_s_stream: Step 1 - Disabling VIC interrupts ***
[   85.196667] *** vic_core_s_stream: Step 2 - Calling tx_isp_vic_start to initialize VIC hardware ***
[   85.196673] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196680] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196687] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196694] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196701] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196708] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196714] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196722] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196728] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196734] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196742] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196748] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196754] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196759] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196765] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196770] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196776] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196782] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196787] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196793] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196798] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196804] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196811] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196817] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   85.196823] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   85.196829] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   85.196836] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   85.196841] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   85.196848] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   85.196854] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   85.196861] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   85.196866] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   85.196872] *** VIC unlock: Commands written, checking VIC status register ***
[   85.196879] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   85.196884] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   85.196890] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   85.196896] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   85.196902] *** tx_isp_vic_start: SIMPLIFIED to match Binary Ninja exactly ***
[   85.196908] *** vic_core_s_stream: Step 3 - tx_isp_vic_start SUCCESS - VIC hardware initialized ***
[   85.196913] *** vic_core_s_stream: Step 4 - VIC state set to 4 (streaming) ***
[   85.196919] *** vic_core_s_stream: Step 5 - Enabling VIC interrupts ***
[   85.196925] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 38 ***
[   85.196932] *** tx_isp_enable_irq: IRQ 38 ENABLED ***
[   85.196939] *** tx_vic_enable_irq: VIC interrupt masks configured (0x1e8=0xFFFFFFFE enables bit 0, 0x1ec=0xFFFFFFFF disables all MDMA) ***
[   85.196945] *** vic_core_s_stream: Step 6 - VIC interrupts enabled ***
[   85.196951] *** vic_core_s_stream: VIC start completed, ret=0, state=4 ***
[   85.196959] gc2053: s_stream called with enable=1
[   85.196966] gc2053: module data_interface=1, sensor data_interface=1 (1=DVP, 2=MIPI)
[   85.196972] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   85.196978] gc2053: About to write streaming registers for interface 1
[   85.196984] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   85.196994] sensor_write: reg=0xfe val=0x00, client=856b3d00, adapter=i2c0, addr=0x37
[   85.205878] sensor_write: reg=0xfe val=0x00 SUCCESS
[   85.205892] sensor_write_array: reg[1] 0xfe=0x00 OK
[   85.205902] sensor_write: reg=0x3e val=0x91, client=856b3d00, adapter=i2c0, addr=0x37
[   85.206220] sensor_write: reg=0x3e val=0x91 SUCCESS
[   85.206227] sensor_write_array: reg[2] 0x3e=0x91 OK
[   85.206234] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   85.206241] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   85.206247] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   85.206253] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   85.206268] ISP IOCTL: cmd=0x800456d0 arg=0x7ff02290
[   85.206274] TX_ISP_VIDEO_LINK_SETUP: config=0
[   85.206281] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   85.206288] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[INFO:Opus.cpp]: Encoder bitrate: 40000
[   85.206294] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.206302] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.206308] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.206316] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.206322] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.206330] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.206336] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.206344] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.206350] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.206356] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.206364] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.206370] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.206376] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.206382] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.206387] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.206393] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.206398] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.206404] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.206410] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.206415] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.206421] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.206426] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.206433] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.206440] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=1 ***
[   85.206447] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=1 ***
[   85.206454] *** CORE STATE CHECK: core_dev->state=4 (need >=3), enable=1 ***
[   85.206460] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.206466] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 37 ***
[   85.206473] *** tx_isp_enable_irq: IRQ 37 ENABLED ***
[   85.206479] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.206486] csi_video_s_stream: sd=85209400, enable=1
[   85.206491] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.206498] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.206505] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.206512] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.206519] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.206526] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.206532] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.206540] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.206546] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.206552] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.206560] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.206566] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.206572] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.206577] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.206583] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.206588] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.206594] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.206600] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.206605] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.206611] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.206616] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.206622] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.206629] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.206634] csi_video_s_stream: Stream ON - CSI state set to 4
[   85.206642] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=1 ***
[   85.206648] vin_s_stream: VIN state = 4, enable = 1
[   85.206654] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.206660] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.206667] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.206674] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.206681] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.206688] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.206695] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.206702] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.206708] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.206714] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.206722] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.206728] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.206734] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.206740] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.206745] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.206750] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.206756] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.206762] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.206768] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.206773] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.206779] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.206784] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.206791] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.206797] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.206803] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   85.206810] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=1 ***
[   85.206816] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=4 ***
[   85.206822] *** vic_core_s_stream: STREAM ON ***
[   85.206827] *** vic_core_s_stream: Already in state 4, skipping VIC start ***
[   85.206832] *** tx_isp_video_s_stream: SKIPPING sensor s_stream in main loop (will call later) ***
[   85.206838] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation complete ***
[   85.216540] ISP isp-w01: [CSI PHY Control] write at offset 0x4: 0x1 -> 0x0 (delta: 3760.000 ms)
[   85.226050] ISP isp-m0: [CSI PHY Control] write at offset 0x1c: 0x0 -> 0x8 (delta: 0.000 ms)
[   85.226067] ISP isp-m0: [CSI PHY Control] write at offset 0x30: 0x0 -> 0x8fffffff (delta: 0.000 ms)
[   85.226082] ISP isp-m0: [CSI PHY Control] write at offset 0xb0: 0x0 -> 0x3fff (delta: 0.000 ms)
[   85.226096] ISP isp-m0: [CSI PHY Config] write at offset 0x110: 0x80007000 -> 0x80007001 (delta: 3830.000 ms)
[   85.228010] ISP isp-m0: [ISP Control] write at offset 0x9804: 0x3f00 -> 0x0 (delta: 3830.000 ms)
[   85.228053] ISP isp-m0: [VIC Control] write at offset 0x9ac0: 0x200 -> 0x0 (delta: 3830.000 ms)
[   85.228063] ISP isp-m0: [VIC Control] write at offset 0x9ac8: 0x200 -> 0x0 (delta: 3830.000 ms)
[   85.359420] ISP M0 device open called from pid 2499
[   85.359452] *** REFERENCE DRIVER IMPLEMENTATION ***
[   85.359461] ISP M0 tuning buffer allocated: 811a0000 (size=0x500c, aligned)
[   85.359467] tisp_par_ioctl global variable set: 811a0000
[   85.359519] TUNING: Allowing V4L2 control command 0xc00c56c6 for VIN init (call #1)
[   85.359527] isp_core_tunning_unlocked_ioctl: Auto-initializing tuning for V4L2 control (one-time)
[   85.359533] isp_core_tunning_unlocked_ioctl: Initializing tuning data structure
[   85.359539] isp_core_tuning_init: Initializing tuning data structure
[   85.359557] isp_core_tuning_init: Tuning data structure initialized at 811a8000
[   85.359564] isp_core_tuning_init: Structure size: 4356 bytes (vs Binary Ninja 0x40d0)
[   85.359570] *** SAFE: mode_flag properly initialized using struct member access ***
[   85.359577] isp_core_tunning_unlocked_ioctl: Tuning data allocated at 811a8000
[   85.359582] *** BINARY NINJA REFERENCE: Skipping auto-initialization - no hardware reset during tuning setup ***
[   85.359588] isp_core_tunning_unlocked_ioctl: ISP tuning auto-enabled for V4L2 controls (permanent)
[   85.359595] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   85.359601] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   85.359607] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   85.359613] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   85.359619] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   85.359643] TUNING DISABLED: Silently ignoring command 0xc008561b (magic=0x56) to prevent memory corruption
[   85.359649] TUNING DISABLED: Returning success to keep streaming app happy
[   85.359657] TUNING DISABLED: Silently ignoring command 0xc008561b (magic=0x56) to prevent memory corruption
[   85.359663] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360109] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360120] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360244] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360251] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360363] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360370] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360478] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360485] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360619] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360627] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360739] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360746] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360852] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360860] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360966] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360973] TUNING DISABLED: Returning success to keep streaming app happy
[   85.361089] TUNING: Allowing V4L2 control command 0xc00c56c6 for VIN init (call #2)
[   85.361099] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   85.361106] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   85.361111] isp_core_tunning_unlocked_ioctl: Ignoring disable command - tuning was auto-initialized
[   85.361233] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #3) to prevent CSI PHY corruption
[   85.361241] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.361357] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.361364] TUNING DISABLED: Returning success to keep streaming app happy
[   85.361470] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.361477] TUNING DISABLED: Returning success to keep streaming app happy
[   85.361583] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #4) to prevent CSI PHY corruption
[   85.361591] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.361714] ISP IOCTL: cmd=0x800456d3 arg=0x0
[   85.361724] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=0 ***
[   85.361730] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.361739] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.361745] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.361753] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.361759] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.361767] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.361774] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.361781] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.361788] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.361794] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.361801] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.361808] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.361814] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.361819] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.361825] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.361831] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.361837] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.361842] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.361848] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.361853] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.361859] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.361865] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.361871] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.361879] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=0 ***
[   85.361885] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=0 ***
[   85.361893] *** CORE STATE CHECK: core_dev->state=4 (need >=3), enable=0 ***
[   85.361900] *** DEBUG: Frame channel loop - s2_1=0xc4, v0_6=85be2800 ***
[   85.361907] *** DEBUG: Checking channel=85be2800, state=1 ***
[   85.361913] *** DEBUG: Frame channel loop - s2_1=0x188, v0_6=85be28c4 ***
[   85.361920] *** DEBUG: Checking channel=85be28c4, state=0 ***
[   85.361927] *** DEBUG: Frame channel loop - s2_1=0x24c, v0_6=85be2988 ***
[   85.361933] *** DEBUG: Checking channel=85be2988, state=3 ***
[   85.361938] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.361945] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 37 ***
[   85.361953] *** tx_isp_disable_irq: IRQ 37 DISABLED ***
[   85.361959] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.361965] csi_video_s_stream: sd=85209400, enable=0
[   85.361971] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.361978] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.361985] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.361992] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.361999] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362006] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362012] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362019] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362026] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362032] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362039] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362045] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362051] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362057] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362063] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362068] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362074] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362079] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362085] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362091] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362097] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362102] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362109] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[INFO:WS.cpp]: Server started on port 8089
[   85.362114] csi_video_s_stream: Stream OFF - CSI state set to 3
[   85.362121] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=0 ***
[   85.362128] vin_s_stream: VIN state = 4, enable = 0
[   85.362133] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362141] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362147] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362155] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362161] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362169] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362175] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362182] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362189] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362195] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362201] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362208] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362214] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362219] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362225] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362231] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362237] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362242] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362248] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362253] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362259] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362265] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362271] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362277] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.362283] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   85.362290] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=0 ***
[   85.362296] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=4 ***
[   85.362301] *** vic_core_s_stream: STREAM OFF ***
[   85.362307] vic_core_s_stream: Stream OFF - state 4 -> 3
[   85.362312] *** tx_isp_video_s_stream: SKIPPING sensor s_stream in main loop (will call later) ***
[   85.362318] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation complete ***
[   85.362327] ISP IOCTL: cmd=0x800456d1 arg=0x7ff02290
[   85.362333] tx_isp_video_link_destroy: Destroying links for config 0
[   85.362340] tx_isp_video_link_destroy: All links destroyed, config reset to -1
[   85.362349] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.362355] TUNING DISABLED: Returning success to keep streaming app happy
[   85.362362] ISP IOCTL: cmd=0x800456d0 arg=0x7ff02290
[   85.362368] TX_ISP_VIDEO_LINK_SETUP: config=0
[   85.362375] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   85.362381] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[   85.362386] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362393] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362400] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362407] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362414] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362421] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362427] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362435] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362441] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362447] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362454] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362461] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362467] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362472] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362478] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362483] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362489] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362495] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362500] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362506] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362511] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362517] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362524] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362530] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=1 ***
[   85.362537] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=1 ***
[   85.362543] *** CORE STATE CHECK: core_dev->state=3 (need >=3), enable=1 ***
[   85.362549] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.362555] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 37 ***
[   85.362561] *** tx_isp_enable_irq: IRQ 37 ENABLED ***
[   85.362567] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.362573] csi_video_s_stream: sd=85209400, enable=1
[   85.362579] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362586] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362593] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362600] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362607] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362614] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362620] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362627] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362634] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362640] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362647] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362653] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362659] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362665] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362671] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362676] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362681] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362687] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362693] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362699] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362704] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362710] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362716] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362721] csi_video_s_stream: Stream ON - CSI state set to 4
[   85.362728] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=1 ***
[   85.362734] vin_s_stream: VIN state = 3, enable = 1
[   85.362739] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362747] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362753] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362761] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362767] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362775] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362781] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362788] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362795] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362801] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362808] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362814] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362820] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362825] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362831] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362837] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362843] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362848] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362854] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362859] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362865] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362871] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362877] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362883] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.362889] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   85.362895] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=1 ***
[   85.362901] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=3 ***
[   85.362907] *** vic_core_s_stream: STREAM ON ***
[   85.362912] *** vic_core_s_stream: State != 4, calling VIC start sequence ***
[   85.362917] *** vic_core_s_stream: Step 1 - Disabling VIC interrupts ***
[   85.362924] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 38 ***
[   85.362930] *** tx_isp_disable_irq: IRQ 38 DISABLED ***
[   85.362936] *** vic_core_s_stream: Step 2 - Calling tx_isp_vic_start to initialize VIC hardware ***
[   85.362942] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362949] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362956] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362963] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362970] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362977] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362983] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362991] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362997] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.363003] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.363011] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.363017] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.363023] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.363028] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.363034] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.363039] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.363045] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.363051] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.363057] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.363062] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.363068] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.363073] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.363080] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.363086] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   85.363092] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   85.363098] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   85.363105] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   85.363110] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   85.363116] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   85.363123] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   85.363130] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   85.363135] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   85.363141] *** VIC unlock: Commands written, checking VIC status register ***
[   85.363148] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   85.363153] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   85.363159] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   85.363165] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   85.363171] *** tx_isp_vic_start: SIMPLIFIED to match Binary Ninja exactly ***
[   85.363177] *** vic_core_s_stream: Step 3 - tx_isp_vic_start SUCCESS - VIC hardware initialized ***
[   85.363182] *** vic_core_s_stream: Step 4 - VIC state set to 4 (streaming) ***
[   85.363187] *** vic_core_s_stream: Step 5 - Enabling VIC interrupts ***
[   85.363194] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 38 ***
[   85.363201] *** tx_isp_enable_irq: IRQ 38 ENABLED ***
[   85.363207] *** tx_vic_enable_irq: VIC interrupt masks configured (0x1e8=0xFFFFFFFE enables bit 0, 0x1ec=0xFFFFFFFF disables all MDMA) ***
[   85.363213] *** vic_core_s_stream: Step 6 - VIC interrupts enabled ***
[   85.363219] *** vic_core_s_stream: VIC start completed, ret=0, state=4 ***
[   85.363225] *** tx_isp_video_s_stream: SKIPPING sensor s_stream in main loop (will call later) ***
[   85.363231] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation complete ***
[   85.365970] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #5) to prevent CSI PHY corruption
[   85.365981] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366112] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.366119] TUNING DISABLED: Returning success to keep streaming app happy
[   85.366328] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #6) to prevent CSI PHY corruption
[   85.366337] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366465] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #7) to prevent CSI PHY corruption
[   85.366473] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366591] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #8) to prevent CSI PHY corruption
[   85.366599] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366702] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #9) to prevent CSI PHY corruption
[   85.366709] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366851] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #10) to prevent CSI PHY corruption
[   85.366859] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366970] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #11) to prevent CSI PHY corruption
[   85.366978] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.367092] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #12) to prevent CSI PHY corruption
[   85.367100] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.367213] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #13) to prevent CSI PHY corruption
[   85.367221] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.369139] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #14) to prevent CSI PHY corruption
[   85.369149] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.369356] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #15) to prevent CSI PHY corruption
[   85.369366] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
root@ing-wyze-cam3-a000 ~# warn: shm_init,53shm init already
[INFO:IMPAudio.cpp]: Audio In: format:OPUS, vol:80, gain:25, samplerate:16000, bitwidth:16, soundmode:1, frmNum:30, numPerFrm:640, chnCnt:1, usrFrmDepth:30
set jpeg streamMngCtx suceess
root@ing-wyze-cam3-a000 ~# dmesg 
[   85.196222] *** ispcore_core_ops_init: Core device state set to 3 (ACTIVE) ***<6>[   85.196228] *** tx_isp_core_enable_irq: Enabling ISP Core hardware interrupts ***
[   85.196236] *** ISP PIPELINE: VIC->ISP connection ENABLED (0x800=1, 0x804=0x1c, 0x1c=8) ***
[   85.196241] *** ISP CORE: Hardware interrupt generation ENABLED ***
[   85.196247] *** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***
[   85.196252] *** ispcore_core_ops_init: ISP Core hardware interrupts enabled ***
[   85.196256] ispcore_core_ops_init: Complete, result=0<6>[   85.196262] *** tx_isp_video_s_stream: ISP Core init SUCCESS - state should now be 3 ***
[   85.196269] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=1 ***
[   85.196276] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=1 ***
[   85.196282] *** CORE STATE CHECK: core_dev->state=3 (need >=3), enable=1 ***
[   85.196288] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.196295] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 37 ***
[   85.196302] *** tx_isp_disable_irq: IRQ 37 DISABLED ***
[   85.196308] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.196315] csi_video_s_stream: sd=85209400, enable=1
[   85.196320] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196327] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196334] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196341] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196348] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196355] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196361] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196368] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196375] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196381] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196388] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196394] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196400] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196406] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196412] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196417] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196423] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196428] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196434] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196440] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196445] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196451] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196458] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196463] csi_video_s_stream: Stream ON - CSI state set to 4
[   85.196470] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=1 ***
[   85.196477] vin_s_stream: VIN state = 2, enable = 1
[   85.196482] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196490] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196496] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196504] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196510] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196518] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196524] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196531] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196538] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196544] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196551] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196558] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196563] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196568] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196574] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196580] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196585] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196591] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196596] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196602] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196608] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196614] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196620] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196626] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.196632] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   85.196639] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=1 ***
[   85.196645] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=3 ***
[   85.196650] *** vic_core_s_stream: STREAM ON ***
[   85.196656] *** vic_core_s_stream: State != 4, calling VIC start sequence ***
[   85.196661] *** vic_core_s_stream: Step 1 - Disabling VIC interrupts ***
[   85.196667] *** vic_core_s_stream: Step 2 - Calling tx_isp_vic_start to initialize VIC hardware ***
[   85.196673] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.196680] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.196687] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.196694] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.196701] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.196708] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.196714] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.196722] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.196728] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.196734] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.196742] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.196748] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.196754] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.196759] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.196765] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.196770] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.196776] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.196782] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.196787] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.196793] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.196798] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.196804] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.196811] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.196817] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   85.196823] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   85.196829] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   85.196836] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   85.196841] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   85.196848] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   85.196854] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   85.196861] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   85.196866] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   85.196872] *** VIC unlock: Commands written, checking VIC status register ***
[   85.196879] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   85.196884] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   85.196890] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   85.196896] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   85.196902] *** tx_isp_vic_start: SIMPLIFIED to match Binary Ninja exactly ***
[   85.196908] *** vic_core_s_stream: Step 3 - tx_isp_vic_start SUCCESS - VIC hardware initialized ***
[   85.196913] *** vic_core_s_stream: Step 4 - VIC state set to 4 (streaming) ***
[   85.196919] *** vic_core_s_stream: Step 5 - Enabling VIC interrupts ***
[   85.196925] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 38 ***
[   85.196932] *** tx_isp_enable_irq: IRQ 38 ENABLED ***
[   85.196939] *** tx_vic_enable_irq: VIC interrupt masks configured (0x1e8=0xFFFFFFFE enables bit 0, 0x1ec=0xFFFFFFFF disables all MDMA) ***
[   85.196945] *** vic_core_s_stream: Step 6 - VIC interrupts enabled ***
[   85.196951] *** vic_core_s_stream: VIC start completed, ret=0, state=4 ***
[   85.196959] gc2053: s_stream called with enable=1
[   85.196966] gc2053: module data_interface=1, sensor data_interface=1 (1=DVP, 2=MIPI)
[   85.196972] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   85.196978] gc2053: About to write streaming registers for interface 1
[   85.196984] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   85.196994] sensor_write: reg=0xfe val=0x00, client=856b3d00, adapter=i2c0, addr=0x37
[   85.205878] sensor_write: reg=0xfe val=0x00 SUCCESS
[   85.205892] sensor_write_array: reg[1] 0xfe=0x00 OK
[   85.205902] sensor_write: reg=0x3e val=0x91, client=856b3d00, adapter=i2c0, addr=0x37
[   85.206220] sensor_write: reg=0x3e val=0x91 SUCCESS
[   85.206227] sensor_write_array: reg[2] 0x3e=0x91 OK
[   85.206234] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   85.206241] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   85.206247] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   85.206253] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   85.206268] ISP IOCTL: cmd=0x800456d0 arg=0x7ff02290
[   85.206274] TX_ISP_VIDEO_LINK_SETUP: config=0
[   85.206281] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   85.206288] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[   85.206294] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.206302] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.206308] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.206316] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.206322] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.206330] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.206336] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.206344] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.206350] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.206356] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.206364] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.206370] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.206376] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.206382] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.206387] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.206393] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.206398] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.206404] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.206410] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.206415] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.206421] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.206426] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.206433] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.206440] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=1 ***
[   85.206447] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=1 ***
[   85.206454] *** CORE STATE CHECK: core_dev->state=4 (need >=3), enable=1 ***
[   85.206460] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.206466] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 37 ***
[   85.206473] *** tx_isp_enable_irq: IRQ 37 ENABLED ***
[   85.206479] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.206486] csi_video_s_stream: sd=85209400, enable=1
[   85.206491] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.206498] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.206505] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.206512] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.206519] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.206526] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.206532] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.206540] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.206546] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.206552] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.206560] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.206566] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.206572] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.206577] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.206583] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.206588] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.206594] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.206600] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.206605] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.206611] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.206616] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.206622] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.206629] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.206634] csi_video_s_stream: Stream ON - CSI state set to 4
[   85.206642] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=1 ***
[   85.206648] vin_s_stream: VIN state = 4, enable = 1
[   85.206654] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.206660] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.206667] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.206674] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.206681] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.206688] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.206695] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.206702] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.206708] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.206714] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.206722] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.206728] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.206734] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.206740] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.206745] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.206750] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.206756] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.206762] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.206768] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.206773] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.206779] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.206784] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.206791] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.206797] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.206803] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   85.206810] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=1 ***
[   85.206816] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=4 ***
[   85.206822] *** vic_core_s_stream: STREAM ON ***
[   85.206827] *** vic_core_s_stream: Already in state 4, skipping VIC start ***
[   85.206832] *** tx_isp_video_s_stream: SKIPPING sensor s_stream in main loop (will call later) ***
[   85.206838] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation complete ***
[   85.216540] ISP isp-w01: [CSI PHY Control] write at offset 0x4: 0x1 -> 0x0 (delta: 3760.000 ms)
[   85.226050] ISP isp-m0: [CSI PHY Control] write at offset 0x1c: 0x0 -> 0x8 (delta: 0.000 ms)
[   85.226067] ISP isp-m0: [CSI PHY Control] write at offset 0x30: 0x0 -> 0x8fffffff (delta: 0.000 ms)
[   85.226082] ISP isp-m0: [CSI PHY Control] write at offset 0xb0: 0x0 -> 0x3fff (delta: 0.000 ms)
[   85.226096] ISP isp-m0: [CSI PHY Config] write at offset 0x110: 0x80007000 -> 0x80007001 (delta: 3830.000 ms)
[   85.228010] ISP isp-m0: [ISP Control] write at offset 0x9804: 0x3f00 -> 0x0 (delta: 3830.000 ms)
[   85.228053] ISP isp-m0: [VIC Control] write at offset 0x9ac0: 0x200 -> 0x0 (delta: 3830.000 ms)
[   85.228063] ISP isp-m0: [VIC Control] write at offset 0x9ac8: 0x200 -> 0x0 (delta: 3830.000 ms)
[   85.359420] ISP M0 device open called from pid 2499
[   85.359452] *** REFERENCE DRIVER IMPLEMENTATION ***
[   85.359461] ISP M0 tuning buffer allocated: 811a0000 (size=0x500c, aligned)
[   85.359467] tisp_par_ioctl global variable set: 811a0000
[   85.359519] TUNING: Allowing V4L2 control command 0xc00c56c6 for VIN init (call #1)
[   85.359527] isp_core_tunning_unlocked_ioctl: Auto-initializing tuning for V4L2 control (one-time)
[   85.359533] isp_core_tunning_unlocked_ioctl: Initializing tuning data structure
[   85.359539] isp_core_tuning_init: Initializing tuning data structure
[   85.359557] isp_core_tuning_init: Tuning data structure initialized at 811a8000
[   85.359564] isp_core_tuning_init: Structure size: 4356 bytes (vs Binary Ninja 0x40d0)
[   85.359570] *** SAFE: mode_flag properly initialized using struct member access ***
[   85.359577] isp_core_tunning_unlocked_ioctl: Tuning data allocated at 811a8000
[   85.359582] *** BINARY NINJA REFERENCE: Skipping auto-initialization - no hardware reset during tuning setup ***
[   85.359588] isp_core_tunning_unlocked_ioctl: ISP tuning auto-enabled for V4L2 controls (permanent)
[   85.359595] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   85.359601] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   85.359607] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   85.359613] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   85.359619] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   85.359643] TUNING DISABLED: Silently ignoring command 0xc008561b (magic=0x56) to prevent memory corruption
[   85.359649] TUNING DISABLED: Returning success to keep streaming app happy
[   85.359657] TUNING DISABLED: Silently ignoring command 0xc008561b (magic=0x56) to prevent memory corruption
[   85.359663] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360109] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360120] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360244] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360251] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360363] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360370] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360478] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360485] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360619] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360627] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360739] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360746] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360852] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360860] TUNING DISABLED: Returning success to keep streaming app happy
[   85.360966] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.360973] TUNING DISABLED: Returning success to keep streaming app happy
[   85.361089] TUNING: Allowing V4L2 control command 0xc00c56c6 for VIN init (call #2)
[   85.361099] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   85.361106] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   85.361111] isp_core_tunning_unlocked_ioctl: Ignoring disable command - tuning was auto-initialized
[   85.361233] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #3) to prevent CSI PHY corruption
[   85.361241] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.361357] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.361364] TUNING DISABLED: Returning success to keep streaming app happy
[   85.361470] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.361477] TUNING DISABLED: Returning success to keep streaming app happy
[   85.361583] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #4) to prevent CSI PHY corruption
[   85.361591] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.361714] ISP IOCTL: cmd=0x800456d3 arg=0x0
[   85.361724] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=0 ***
[   85.361730] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.361739] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.361745] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.361753] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.361759] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.361767] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.361774] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.361781] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.361788] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.361794] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.361801] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.361808] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.361814] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.361819] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.361825] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.361831] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.361837] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.361842] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.361848] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.361853] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.361859] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.361865] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.361871] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.361879] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=0 ***
[   85.361885] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=0 ***
[   85.361893] *** CORE STATE CHECK: core_dev->state=4 (need >=3), enable=0 ***
[   85.361900] *** DEBUG: Frame channel loop - s2_1=0xc4, v0_6=85be2800 ***
[   85.361907] *** DEBUG: Checking channel=85be2800, state=1 ***
[   85.361913] *** DEBUG: Frame channel loop - s2_1=0x188, v0_6=85be28c4 ***
[   85.361920] *** DEBUG: Checking channel=85be28c4, state=0 ***
[   85.361927] *** DEBUG: Frame channel loop - s2_1=0x24c, v0_6=85be2988 ***
[   85.361933] *** DEBUG: Checking channel=85be2988, state=3 ***
[   85.361938] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.361945] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 37 ***
[   85.361953] *** tx_isp_disable_irq: IRQ 37 DISABLED ***
[   85.361959] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.361965] csi_video_s_stream: sd=85209400, enable=0
[   85.361971] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.361978] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.361985] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.361992] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.361999] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362006] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362012] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362019] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362026] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362032] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362039] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362045] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362051] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362057] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362063] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362068] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362074] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362079] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362085] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362091] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362097] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362102] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362109] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362114] csi_video_s_stream: Stream OFF - CSI state set to 3
[   85.362121] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=0 ***
[   85.362128] vin_s_stream: VIN state = 4, enable = 0
[   85.362133] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362141] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362147] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362155] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362161] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362169] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362175] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362182] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362189] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362195] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362201] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362208] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362214] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362219] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362225] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362231] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362237] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362242] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362248] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362253] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362259] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362265] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362271] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362277] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.362283] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   85.362290] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=0 ***
[   85.362296] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=4 ***
[   85.362301] *** vic_core_s_stream: STREAM OFF ***
[   85.362307] vic_core_s_stream: Stream OFF - state 4 -> 3
[   85.362312] *** tx_isp_video_s_stream: SKIPPING sensor s_stream in main loop (will call later) ***
[   85.362318] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation complete ***
[   85.362327] ISP IOCTL: cmd=0x800456d1 arg=0x7ff02290
[   85.362333] tx_isp_video_link_destroy: Destroying links for config 0
[   85.362340] tx_isp_video_link_destroy: All links destroyed, config reset to -1
[   85.362349] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.362355] TUNING DISABLED: Returning success to keep streaming app happy
[   85.362362] ISP IOCTL: cmd=0x800456d0 arg=0x7ff02290
[   85.362368] TX_ISP_VIDEO_LINK_SETUP: config=0
[   85.362375] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   85.362381] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[   85.362386] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362393] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362400] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362407] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362414] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362421] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362427] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362435] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362441] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362447] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362454] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362461] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362467] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362472] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362478] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362483] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362489] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362495] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362500] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362506] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362511] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362517] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362524] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362530] *** ispcore_video_s_stream: FIXED Binary Ninja MCP implementation - enable=1 ***
[   85.362537] *** ispcore_video_s_stream: DEBUG - sd=85be2400, enable=1 ***
[   85.362543] *** CORE STATE CHECK: core_dev->state=3 (need >=3), enable=1 ***
[   85.362549] *** ispcore_video_s_stream: FIXED - removed recursive subdev loop ***
[   85.362555] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 37 ***
[   85.362561] *** tx_isp_enable_irq: IRQ 37 ENABLED ***
[   85.362567] *** csi_video_s_stream: EXACT Binary Ninja implementation - FIXED for MIPS ***
[   85.362573] csi_video_s_stream: sd=85209400, enable=1
[   85.362579] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362586] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362593] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362600] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362607] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362614] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362620] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362627] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362634] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362640] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362647] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362653] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362659] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362665] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362671] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362676] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362681] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362687] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362693] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362699] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362704] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362710] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362716] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362721] csi_video_s_stream: Stream ON - CSI state set to 4
[   85.362728] *** vin_s_stream: SAFE implementation - sd=8116e200, enable=1 ***
[   85.362734] vin_s_stream: VIN state = 3, enable = 1
[   85.362739] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362747] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362753] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362761] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362767] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362775] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362781] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362788] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362795] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.362801] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.362808] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.362814] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.362820] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.362825] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.362831] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.362837] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.362843] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.362848] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.362854] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.362859] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.362865] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.362871] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.362877] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.362883] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   85.362889] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   85.362895] *** vic_core_s_stream: BINARY NINJA EXACT - sd=85be2000, enable=1 ***
[   85.362901] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=3 ***
[   85.362907] *** vic_core_s_stream: STREAM ON ***
[   85.362912] *** vic_core_s_stream: State != 4, calling VIC start sequence ***
[   85.362917] *** vic_core_s_stream: Step 1 - Disabling VIC interrupts ***
[   85.362924] *** tx_isp_disable_irq: EXACT Binary Ninja - disabling IRQ 38 ***
[   85.362930] *** tx_isp_disable_irq: IRQ 38 DISABLED ***
[   85.362936] *** vic_core_s_stream: Step 2 - Calling tx_isp_vic_start to initialize VIC hardware ***
[   85.362942] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   85.362949] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   85.362956] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   85.362963] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   85.362970] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   85.362977] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   85.362983] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   85.362991] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   85.362997] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   85.363003] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   85.363011] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   85.363017] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   85.363023] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   85.363028] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   85.363034] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   85.363039] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   85.363045] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   85.363051] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   85.363057] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   85.363062] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   85.363068] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   85.363073] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   85.363080] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   85.363086] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   85.363092] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   85.363098] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   85.363105] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   85.363110] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   85.363116] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   85.363123] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   85.363130] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   85.363135] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   85.363141] *** VIC unlock: Commands written, checking VIC status register ***
[   85.363148] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   85.363153] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   85.363159] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   85.363165] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   85.363171] *** tx_isp_vic_start: SIMPLIFIED to match Binary Ninja exactly ***
[   85.363177] *** vic_core_s_stream: Step 3 - tx_isp_vic_start SUCCESS - VIC hardware initialized ***
[INFO:IMPAudioServerMediaSubsession.cpp]: IMPAudioServerMediaSubsession init
[INFO:RTSP.cpp]: Audio stream 0 added to session
[INFO:RTSP.cpp]: stream 0 available at: rtsp://192.168.50.211/ch0
[   85.363182] *** vic_core_s_stream: Step 4 - VIC state set to 4 (streaming) ***
[   85.363187] *** vic_core_s_stream: Step 5 - Enabling VIC interrupts ***
[   85.363194] *** tx_isp_enable_irq: EXACT Binary Ninja - enabling IRQ 38 ***
[   85.363201] *** tx_isp_enable_irq: IRQ 38 ENABLED ***
[   85.363207] *** tx_vic_enable_irq: VIC interrupt masks configured (0x1e8=0xFFFFFFFE enables bit 0, 0x1ec=0xFFFFFFFF disables all MDMA) ***
[   85.363213] *** vic_core_s_stream: Step 6 - VIC interrupts enabled ***
[   85.363219] *** vic_core_s_stream: VIC start completed, ret=0, state=4 ***
[   85.363225] *** tx_isp_video_s_stream: SKIPPING sensor s_stream in main loop (will call later) ***
[   85.363231] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation complete ***
[   85.365970] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #5) to prevent CSI PHY corruption
[   85.365981] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366112] TUNING DISABLED: Silently ignoring command 0xc008561c (magic=0x56) to prevent memory corruption
[   85.366119] TUNING DISABLED: Returning success to keep streaming app happy
[   85.366328] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #6) to prevent CSI PHY corruption
[   85.366337] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366465] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #7) to prevent CSI PHY corruption
[   85.366473] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366591] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #8) to prevent CSI PHY corruption
[   85.366599] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366702] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #9) to prevent CSI PHY corruption
[   85.366709] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366851] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #10) to prevent CSI PHY corruption
[   85.366859] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.366970] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #11) to prevent CSI PHY corruption
[   85.366978] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.367092] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #12) to prevent CSI PHY corruption
[   85.367100] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.367213] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #13) to prevent CSI PHY corruption
[   85.367221] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.369139] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #14) to prevent CSI PHY corruption
[   85.369149] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.369356] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #15) to prevent CSI PHY corruption
[   85.369366] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   85.664455] cgu_set_rate, parent = 1392000000, rate = 4096000, n = 10875, reg val = 0x22002a7b
[   85.664467] codec_codec_ctl: set sample rate...
[   85.664598] codec_codec_ctl: set device...
[   86.115816] codec_set_device: set device: MIC...
[   86.236110] *** FRAME CHANNEL OPEN: minor=54 ***
[   86.236122] *** FRAME CHANNEL OPEN: Device not in array, creating new entry for minor 54 ***
[   86.236128] *** FRAME CHANNEL OPEN: Assigned to channel 0 ***
[   86.236134] *** FRAME CHANNEL 0: State set to 3 (ready for streaming) - Binary Ninja EXACT ***
[   86.236140] *** SAFE: Frame channel device stored in file->private_data ***
[   86.236146] *** FRAME CHANNEL 0 OPENED SUCCESSFULLY - NOW READY FOR IOCTLS ***
[   86.236154] Channel 0: Format 1920x1080, pixfmt=0x32315659, minor=54
[   86.236172] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc07056c3 ***
[   86.236180] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc07056c3 ***
[   86.236188] Channel 0: Set format 1920x1080 pixfmt=0x3231564e
[   86.236779] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0145608 ***
[   86.236790] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0145608 ***
[   86.236797] *** Channel 0: REQBUFS - MEMORY-AWARE implementation ***
[   86.236804] Channel 0: Request 4 buffers, type=1 memory=2
[   86.236810] Channel 0: USERPTR mode - client will provide buffers
[   86.236816] Channel 0: USERPTR mode - 4 user buffers expected
[   86.236826] *** Channel 0: REQBUFS allocated VBM buffer array for 4 buffers at 811e1400 ***
[   86.236834] *** Channel 0: VIC active_buffer_count set to 4 ***
[   86.236839] *** REQBUFS: VIC DMA will be configured during streaming via vic_pipo_mdma_enable ***
[   86.236846] *** Channel 0: MEMORY-AWARE REQBUFS SUCCESS - 4 buffers ***
[   86.236869] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.236877] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.236883] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.236890] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.236897] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   86.236904] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   86.236912] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.236918] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   86.236925] *** Channel 0: QBUF - Queue buffer index=0 ***
[   86.236931] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   86.236938] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   86.236945] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.236953] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.236959] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.236966] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.236974] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x805afdb8) ***
[   86.236982] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=805afdb8 ***
[   86.236988] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.236994] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.237001] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   86.237010] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   86.237017] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=1 ***
[   86.237025] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=1 ***
[   86.237032] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   86.237038] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   86.237046] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.237056] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.237063] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.237069] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.237076] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.237083] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   86.237090] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   86.237097] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.237104] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   86.237110] *** Channel 0: QBUF - Queue buffer index=1 ***
[   86.237116] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   86.237124] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   86.237130] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.237137] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.237144] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.237150] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.237157] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x805afdb8) ***
[   86.237165] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=805afdb8 ***
[   86.237171] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.237177] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.237184] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   86.237192] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   86.237199] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=2 ***
[   86.237207] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=2 ***
[   86.237214] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   86.237220] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   86.237226] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.237235] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.237242] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.237248] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.237254] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.237261] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   86.237268] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   86.237276] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.237282] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   86.237288] *** Channel 0: QBUF - Queue buffer index=2 ***
[   86.237294] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   86.237302] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   86.237308] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.237315] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.237321] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.237327] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.237335] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x805afdb8) ***
[   86.237342] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=805afdb8 ***
[   86.237349] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.237354] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.237361] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   86.237369] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   86.237377] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=3 ***
[   86.237384] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=3 ***
[   86.237391] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   86.237398] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   86.237404] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.237412] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.237419] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.237425] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.237431] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.237438] *** Channel 0: QBUF - Buffer received: index=3, type=1, memory=2 ***
[   86.237446] *** Channel 0: QBUF - Buffer m.offset=0x79d0000, m.userptr=0x79d0000 ***
[   86.237452] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.237460] *** Channel 0: QBUF - Validation: buffer.index=3, state->buffer_count=4 ***
[   86.237466] *** Channel 0: QBUF - Queue buffer index=3 ***
[   86.237472] *** QBUF: No buffer allocated for index 3 - VBM initialization mode ***
[   86.237479] *** Channel 0: QBUF - Using buffer struct   (null) for index 3 ***
[   86.237485] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.237492] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.237498] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.237505] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.237512] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x805afdb8) ***
[   86.237520] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=805afdb8 ***
[   86.237526] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.237532] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.237538] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x79d0000 ***
[   86.237546] *** Channel 0: QBUF - Buffer 3: phys_addr=0x79d0000, size=4147200 (VALIDATED) ***
[   86.237554] *** Channel 0: QBUF VBM - Stored buffer[3] = 0x79d0000, total_count=4 ***
[   86.237562] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.237568] *** Channel 0: QBUF - VBM buffer slot[3] available ***
[   86.237575] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x79d0000 ***
[   86.237582] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.237672] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x80045612 ***
[   86.237682] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x80045612 ***
[   86.237689] *** Channel 0: VIDIOC_STREAMON - Binary Ninja implementation ***
[   86.237695] Channel 0: STREAMON - Enqueuing buffers in driver
[   86.237702] *** Channel 0: STREAMON - Resetting core state from 4 to 2 (ready) ***
[   86.245873] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.245886] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.245893] *** Channel 0: Frame completion wait ***
[   86.245899] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.245906] *** Channel 0: Frame wait returned 10 ***
[   86.245911] *** Channel 0: Frame was ready, consuming it ***
[   86.246019] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.246028] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.246034] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.246040] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.246048] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.246055] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.246062] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.246070] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.246077] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.246084] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.246092] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.246098] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.246104] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.246112] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.246118] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.246124] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.246130] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.246135] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.246141] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.246146] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.246152] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.246158] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.246164] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.246169] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.246175] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.246181] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.246188] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.246204] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.246212] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.246218] *** Channel 0: Frame completion wait ***
[   86.246223] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.345813] *** Channel 0: Frame wait returned 0 ***
[   86.345825] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.345847] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.345855] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.345862] *** Channel 0: Frame completion wait ***
[   86.345867] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.345873] *** Channel 0: Frame wait returned 10 ***
[   86.345879] *** Channel 0: Frame was ready, consuming it ***
[   86.345887] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.345894] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.345899] *** Channel 0: Frame completion wait ***
[   86.345905] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.400528] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #16) to prevent CSI PHY corruption
[   86.400540] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.446369] *** Channel 0: DQBUF wait returned 0 ***
[   86.446380] *** Channel 0: DQBUF timeout, generating frame ***
[   86.446389] *** Channel 0: DQBUF complete - buffer[0] seq=-1 flags=0x3 ***
[   86.446429] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #17) to prevent CSI PHY corruption
[   86.446435] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.446556] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.446566] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.446572] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.446578] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.446587] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.446594] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.446602] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.446608] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.446616] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.446623] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.446630] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.446637] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.446643] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.446650] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.446657] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.446663] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.446668] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.446674] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.446680] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.446686] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.446691] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.446697] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.446702] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.446708] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.446714] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.446720] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.446727] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.446744] *** Channel 0: Frame wait returned 0 ***
[   86.446751] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.446764] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.446770] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.446777] *** Channel 0: Frame completion wait ***
[   86.446782] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.446788] *** Channel 0: Frame wait returned 10 ***
[   86.446794] *** Channel 0: Frame was ready, consuming it ***
[   86.446802] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.446809] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.446814] *** Channel 0: Frame completion wait ***
[   86.446820] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.460241] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.460254] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.460261] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.460268] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.460275] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   86.460282] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   86.460290] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.460296] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   86.460303] *** Channel 0: QBUF - Queue buffer index=0 ***
[   86.460309] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   86.460317] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   86.460324] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.460332] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.460338] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.460344] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.460352] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   86.460360] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   86.460367] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.460373] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.460380] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   86.460388] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   86.460396] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   86.460404] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.460410] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   86.460417] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   86.460429] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.460500] *** Channel 0: Frame wait returned 9 ***
[   86.460507] *** Channel 0: Frame was ready, consuming it ***
[   86.460520] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.460527] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.460534] *** Channel 0: Frame completion wait ***
[   86.460540] *** Channel 0: Waiting for frame (timeout=100ms) ***
root@ing-wyze-cam3-a000 ~# dmesg 
[   86.246098] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.246104] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.246112] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.246118] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.246124] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.246130] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.246135] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.246141] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.246146] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.246152] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.246158] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.246164] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.246169] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.246175] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.246181] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.246188] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.246204] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.246212] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.246218] *** Channel 0: Frame completion wait ***
[   86.246223] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.345813] *** Channel 0: Frame wait returned 0 ***
[   86.345825] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.345847] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.345855] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.345862] *** Channel 0: Frame completion wait ***
[   86.345867] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.345873] *** Channel 0: Frame wait returned 10 ***
[   86.345879] *** Channel 0: Frame was ready, consuming it ***
[   86.345887] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.345894] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.345899] *** Channel 0: Frame completion wait ***
[   86.345905] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.400528] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #16) to prevent CSI PHY corruption
[   86.400540] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.446369] *** Channel 0: DQBUF wait returned 0 ***
[   86.446380] *** Channel 0: DQBUF timeout, generating frame ***
[   86.446389] *** Channel 0: DQBUF complete - buffer[0] seq=-1 flags=0x3 ***
[   86.446429] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #17) to prevent CSI PHY corruption
[   86.446435] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.446556] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.446566] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.446572] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.446578] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.446587] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.446594] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.446602] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.446608] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.446616] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.446623] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.446630] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.446637] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.446643] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.446650] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.446657] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.446663] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.446668] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.446674] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.446680] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.446686] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.446691] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.446697] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.446702] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.446708] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.446714] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.446720] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.446727] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.446744] *** Channel 0: Frame wait returned 0 ***
[   86.446751] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.446764] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.446770] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.446777] *** Channel 0: Frame completion wait ***
[   86.446782] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.446788] *** Channel 0: Frame wait returned 10 ***
[   86.446794] *** Channel 0: Frame was ready, consuming it ***
[   86.446802] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.446809] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.446814] *** Channel 0: Frame completion wait ***
[   86.446820] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.460241] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.460254] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.460261] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.460268] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.460275] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   86.460282] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   86.460290] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.460296] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   86.460303] *** Channel 0: QBUF - Queue buffer index=0 ***
[   86.460309] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   86.460317] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   86.460324] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.460332] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.460338] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.460344] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.460352] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   86.460360] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   86.460367] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.460373] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.460380] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   86.460388] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   86.460396] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   86.460404] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.460410] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   86.460417] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   86.460429] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.460500] *** Channel 0: Frame wait returned 9 ***
[   86.460507] *** Channel 0: Frame was ready, consuming it ***
[   86.460520] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.460527] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.460534] *** Channel 0: Frame completion wait ***
[   86.460540] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.555804] *** Channel 0: Frame wait returned 0 ***
[   86.555816] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.555837] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.555844] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.555851] *** Channel 0: Frame completion wait ***
[   86.555856] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.555863] *** Channel 0: Frame wait returned 10 ***
[   86.555868] *** Channel 0: Frame was ready, consuming it ***
[   86.555876] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.555883] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.555889] *** Channel 0: Frame completion wait ***
[   86.555894] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.645792] *** Channel 0: DQBUF wait returned 0 ***
[   86.645804] *** Channel 0: DQBUF timeout, generating frame ***
[   86.645812] *** Channel 0: DQBUF complete - buffer[1] seq=0 flags=0x3 ***
[   86.645836] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #18) to prevent CSI PHY corruption
[   86.645842] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.645956] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.645967] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.645974] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.645980] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.645988] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.645995] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.646002] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.646009] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.646016] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.646024] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.646031] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.646038] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.646044] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.646051] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.646058] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.646064] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.646069] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.646075] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.646080] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.646105] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.646112] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.646117] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.646123] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.646128] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.646134] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.646141] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.646148] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.655814] *** Channel 0: Frame wait returned 0 ***
[   86.655830] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.655858] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.655866] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.655872] *** Channel 0: Frame completion wait ***
[   86.655878] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.655884] *** Channel 0: Frame wait returned 10 ***
[   86.655890] *** Channel 0: Frame was ready, consuming it ***
[   86.655898] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.655905] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.655911] *** Channel 0: Frame completion wait ***
[   86.655916] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.656142] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.656153] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.656160] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.656166] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.656173] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   86.656181] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   86.656188] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.656195] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   86.656201] *** Channel 0: QBUF - Queue buffer index=1 ***
[   86.656207] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   86.656215] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   86.656222] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.656230] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.656236] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.656242] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.656250] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   86.656258] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   86.656266] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.656271] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.656278] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   86.656286] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   86.656294] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   86.656302] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.656308] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   86.656316] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   86.656326] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.656393] *** Channel 0: DQBUF wait returned 19 ***
[   86.656404] *** Channel 0: DQBUF complete - buffer[2] seq=1 flags=0x3 ***
[   86.656422] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #19) to prevent CSI PHY corruption
[   86.656428] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.656545] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.656556] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.656563] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.656569] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.656577] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.656584] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.656592] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.656598] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.656606] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.656613] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.656620] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.656627] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.656633] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.656640] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.656647] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.656653] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.656658] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.656664] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.656670] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.656675] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.656681] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.656686] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.656692] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.656698] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.656704] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.656710] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.656716] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.666820] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.666833] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.666840] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.666846] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.666853] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   86.666861] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   86.666868] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.666875] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   86.666881] *** Channel 0: QBUF - Queue buffer index=2 ***
[   86.666887] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   86.666895] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   86.666902] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.666910] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.666916] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.666923] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.666931] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   86.666938] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   86.666945] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.666951] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.666958] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   86.666966] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   86.666974] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   86.666982] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.666988] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   86.666995] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   86.667006] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.667092] *** Channel 0: Frame wait returned 9 ***
[   86.667099] *** Channel 0: Frame was ready, consuming it ***
[   86.667113] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.667120] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.667126] *** Channel 0: Frame completion wait ***
[   86.667132] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.765788] *** Channel 0: Frame wait returned 0 ***
[   86.765800] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.765821] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.765829] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.765835] *** Channel 0: Frame completion wait ***
[   86.765841] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.765847] *** Channel 0: Frame wait returned 10 ***
[   86.765852] *** Channel 0: Frame was ready, consuming it ***
[   86.765860] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.765867] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.765873] *** Channel 0: Frame completion wait ***
[   86.765878] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.855787] *** Channel 0: DQBUF wait returned 0 ***
[   86.855797] *** Channel 0: DQBUF timeout, generating frame ***
[   86.855807] *** Channel 0: DQBUF complete - buffer[3] seq=2 flags=0x3 ***
[   86.855830] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #20) to prevent CSI PHY corruption
[   86.855836] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.855951] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.855961] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.855967] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.855973] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.855981] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.855989] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.855996] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.856003] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.856010] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.856017] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.856025] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.856032] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.856037] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.856045] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.856052] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.856057] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.856063] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.856069] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.856075] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.856080] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.856086] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.856091] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.856097] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.856103] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.856108] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.856115] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.856121] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.865924] *** Channel 0: Frame wait returned 0 ***
[   86.865935] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.865956] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.865964] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.865970] *** Channel 0: Frame completion wait ***
[   86.865975] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.865982] *** Channel 0: Frame wait returned 10 ***
[   86.865987] *** Channel 0: Frame was ready, consuming it ***
[   86.865995] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.866002] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.866008] *** Channel 0: Frame completion wait ***
[   86.866013] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.866178] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.866188] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.866194] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.866201] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.866208] *** Channel 0: QBUF - Buffer received: index=3, type=1, memory=2 ***
[   86.866216] *** Channel 0: QBUF - Buffer m.offset=0x79d0000, m.userptr=0x79d0000 ***
[   86.866223] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.866230] *** Channel 0: QBUF - Validation: buffer.index=3, state->buffer_count=4 ***
[   86.866236] *** Channel 0: QBUF - Queue buffer index=3 ***
[   86.866242] *** QBUF: No buffer allocated for index 3 - VBM initialization mode ***
[   86.866250] *** Channel 0: QBUF - Using buffer struct   (null) for index 3 ***
[   86.866257] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.866265] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.866272] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.866278] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.866286] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   86.866294] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   86.866301] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.866307] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.866313] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x79d0000 ***
[   86.866322] *** Channel 0: QBUF - Buffer 3: phys_addr=0x79d0000, size=4147200 (VALIDATED) ***
[   86.866330] *** Channel 0: QBUF VBM - Stored buffer[3] = 0x79d0000, total_count=4 ***
[   86.866337] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.866363] *** Channel 0: QBUF - VBM buffer slot[3] available ***
[   86.866371] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x79d0000 ***
[   86.866382] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.866514] *** Channel 0: DQBUF wait returned 19 ***
[   86.866527] *** Channel 0: DQBUF complete - buffer[0] seq=3 flags=0x3 ***
[   86.866545] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #21) to prevent CSI PHY corruption
[   86.866551] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   86.866669] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   86.866681] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   86.866687] *** Channel 0: DQBUF - dequeue buffer request ***
[   86.866693] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   86.866702] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   86.866709] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   86.866716] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   86.866723] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   86.866730] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   86.866737] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   86.866745] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   86.866751] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   86.866757] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   86.866765] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   86.866771] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   86.866777] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   86.866783] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   86.866789] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   86.866794] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   86.866800] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   86.866805] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   86.866811] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   86.866817] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   86.866823] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   86.866828] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   86.866835] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   86.866841] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   86.876982] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   86.876995] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   86.877002] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   86.877009] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   86.877016] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   86.877023] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   86.877031] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   86.877038] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   86.877045] *** Channel 0: QBUF - Queue buffer index=0 ***
[   86.877051] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   86.877058] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   86.877065] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   86.877073] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   86.877080] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   86.877086] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   86.877112] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   86.877132] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   86.877139] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   86.877145] *** Channel 0: QBUF EVENT SUCCESS ***
[   86.877152] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   86.877160] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   86.877168] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   86.877175] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   86.877182] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   86.877189] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   86.877200] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   86.877269] *** Channel 0: Frame wait returned 9 ***
[   86.877277] *** Channel 0: Frame was ready, consuming it ***
[   86.877289] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.877297] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.877303] *** Channel 0: Frame completion wait ***
[   86.877309] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.975841] *** Channel 0: Frame wait returned 0 ***
[   86.975853] *** Channel 0: Frame wait timeout/error, generating frame ***
[   86.975886] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.975894] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.975900] *** Channel 0: Frame completion wait ***
[   86.975905] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   86.975912] *** Channel 0: Frame wait returned 10 ***
[   86.975918] *** Channel 0: Frame was ready, consuming it ***
[   86.975925] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   86.975932] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   86.975938] *** Channel 0: Frame completion wait ***
[   86.975943] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.065781] *** Channel 0: DQBUF wait returned 0 ***
[   87.065793] *** Channel 0: DQBUF timeout, generating frame ***
[   87.065802] *** Channel 0: DQBUF complete - buffer[1] seq=4 flags=0x3 ***
[   87.065822] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #22) to prevent CSI PHY corruption
[   87.065829] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.065945] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   87.065956] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   87.065963] *** Channel 0: DQBUF - dequeue buffer request ***
[   87.065968] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   87.065977] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   87.065983] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   87.065991] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   87.065998] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   87.066005] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   87.066013] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   87.066020] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   87.066027] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   87.066033] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   87.066040] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   87.066047] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   87.066052] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   87.066058] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   87.066063] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   87.066069] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   87.066075] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   87.066081] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   87.066086] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   87.066092] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   87.066097] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   87.066103] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   87.066110] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   87.066117] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   87.075807] *** Channel 0: Frame wait returned 0 ***
[   87.075823] *** Channel 0: Frame wait timeout/error, generating frame ***
[   87.075849] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.075857] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.075864] *** Channel 0: Frame completion wait ***
[   87.075869] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.075876] *** Channel 0: Frame wait returned 10 ***
[   87.075881] *** Channel 0: Frame was ready, consuming it ***
[   87.075889] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.075910] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.075916] *** Channel 0: Frame completion wait ***
[   87.075922] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.076086] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   87.076097] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   87.076103] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   87.076109] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   87.076117] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   87.076124] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   87.076131] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   87.076139] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   87.076145] *** Channel 0: QBUF - Queue buffer index=1 ***
[   87.076151] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   87.076159] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   87.076165] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   87.076173] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   87.076180] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   87.076187] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   87.076195] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   87.076203] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   87.076209] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   87.076215] *** Channel 0: QBUF EVENT SUCCESS ***
[   87.076222] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   87.076230] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   87.076238] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   87.076246] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   87.076252] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   87.076259] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   87.076270] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   87.076336] *** Channel 0: DQBUF wait returned 19 ***
[   87.076347] *** Channel 0: DQBUF complete - buffer[2] seq=5 flags=0x3 ***
[   87.076364] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #23) to prevent CSI PHY corruption
[   87.076387] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.076507] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   87.076518] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   87.076525] *** Channel 0: DQBUF - dequeue buffer request ***
[   87.076531] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   87.076539] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   87.076546] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   87.076553] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   87.076560] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   87.076567] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   87.076575] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   87.076582] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   87.076589] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   87.076595] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   87.076602] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   87.076609] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   87.076615] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   87.076620] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   87.076626] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   87.076631] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   87.076637] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   87.076643] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   87.076649] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   87.076654] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   87.076659] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   87.076665] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   87.076672] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   87.076679] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   87.086781] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   87.086794] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   87.086801] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   87.086807] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   87.086815] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   87.086822] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   87.086829] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   87.086836] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   87.086843] *** Channel 0: QBUF - Queue buffer index=2 ***
[   87.086849] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   87.086856] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   87.086863] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   87.086871] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   87.086877] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   87.086884] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   87.086891] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   87.086899] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   87.086906] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   87.086912] *** Channel 0: QBUF EVENT SUCCESS ***
[   87.086919] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   87.086927] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   87.086935] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   87.086943] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   87.086949] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   87.086956] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   87.086968] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   87.087034] *** Channel 0: Frame wait returned 9 ***
[   87.087041] *** Channel 0: Frame was ready, consuming it ***
[   87.087054] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.087061] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.087067] *** Channel 0: Frame completion wait ***
[   87.087073] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.185780] *** Channel 0: Frame wait returned 0 ***
[   87.185792] *** Channel 0: Frame wait timeout/error, generating frame ***
[   87.185813] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.185821] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.185827] *** Channel 0: Frame completion wait ***
[   87.185833] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.185839] *** Channel 0: Frame wait returned 10 ***
[   87.185845] *** Channel 0: Frame was ready, consuming it ***
[   87.185853] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.185859] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.185865] *** Channel 0: Frame completion wait ***
[   87.185871] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.275777] *** Channel 0: DQBUF wait returned 0 ***
[   87.275789] *** Channel 0: DQBUF timeout, generating frame ***
[   87.275798] *** Channel 0: DQBUF complete - buffer[3] seq=6 flags=0x3 ***
[   87.275823] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #24) to prevent CSI PHY corruption
[   87.275829] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.275944] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   87.275954] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   87.275961] *** Channel 0: DQBUF - dequeue buffer request ***
[   87.275967] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   87.275975] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   87.275982] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   87.275990] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   87.275997] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   87.276004] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   87.276011] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   87.276019] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   87.276025] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   87.276031] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   87.276039] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   87.276045] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   87.276051] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   87.276057] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   87.276063] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   87.276068] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   87.276073] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   87.276079] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   87.276085] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   87.276091] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   87.276097] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   87.276102] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   87.276109] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   87.276115] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   87.285795] *** Channel 0: Frame wait returned 0 ***
[   87.285810] *** Channel 0: Frame wait timeout/error, generating frame ***
[   87.285835] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.285844] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.285851] *** Channel 0: Frame completion wait ***
[   87.285856] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.285877] *** Channel 0: Frame wait returned 10 ***
[   87.285883] *** Channel 0: Frame was ready, consuming it ***
[   87.285891] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.285899] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.285905] *** Channel 0: Frame completion wait ***
[   87.285911] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.286075] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   87.286085] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   87.286091] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   87.286097] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   87.286105] *** Channel 0: QBUF - Buffer received: index=3, type=1, memory=2 ***
[   87.286113] *** Channel 0: QBUF - Buffer m.offset=0x79d0000, m.userptr=0x79d0000 ***
[   87.286119] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   87.286127] *** Channel 0: QBUF - Validation: buffer.index=3, state->buffer_count=4 ***
[   87.286133] *** Channel 0: QBUF - Queue buffer index=3 ***
[   87.286139] *** QBUF: No buffer allocated for index 3 - VBM initialization mode ***
[   87.286147] *** Channel 0: QBUF - Using buffer struct   (null) for index 3 ***
[   87.286153] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   87.286161] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   87.286168] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   87.286175] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   87.286182] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   87.286190] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   87.286197] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   87.286203] *** Channel 0: QBUF EVENT SUCCESS ***
[   87.286210] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x79d0000 ***
[   87.286218] *** Channel 0: QBUF - Buffer 3: phys_addr=0x79d0000, size=4147200 (VALIDATED) ***
[   87.286226] *** Channel 0: QBUF VBM - Stored buffer[3] = 0x79d0000, total_count=4 ***
[   87.286251] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   87.286258] *** Channel 0: QBUF - VBM buffer slot[3] available ***
[   87.286265] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x79d0000 ***
[   87.286275] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   87.286364] *** Channel 0: DQBUF wait returned 19 ***
[   87.286375] *** Channel 0: DQBUF complete - buffer[0] seq=7 flags=0x3 ***
[   87.286393] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #25) to prevent CSI PHY corruption
[   87.286400] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.286517] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   87.286529] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   87.286535] *** Channel 0: DQBUF - dequeue buffer request ***
[   87.286542] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   87.286550] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   87.286557] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   87.286564] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   87.286571] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   87.286579] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   87.286585] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   87.286593] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   87.286599] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   87.286605] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   87.286613] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   87.286619] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   87.286625] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   87.286631] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   87.286637] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   87.286642] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   87.286648] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   87.286653] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   87.286659] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   87.286665] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   87.286671] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   87.286676] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   87.286683] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   87.286689] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   87.296714] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   87.296727] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   87.296733] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   87.296740] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   87.296747] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   87.296755] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   87.296762] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   87.296769] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   87.296775] *** Channel 0: QBUF - Queue buffer index=0 ***
[   87.296781] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   87.296789] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   87.296796] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   87.296804] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   87.296811] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   87.296817] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   87.296825] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   87.296833] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   87.296839] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   87.296845] *** Channel 0: QBUF EVENT SUCCESS ***
[   87.296852] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   87.296860] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   87.296868] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   87.296876] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   87.296882] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   87.296889] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   87.296901] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   87.296968] *** Channel 0: Frame wait returned 9 ***
[   87.296975] *** Channel 0: Frame was ready, consuming it ***
[   87.296989] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.296995] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.297002] *** Channel 0: Frame completion wait ***
[   87.297007] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.395774] *** Channel 0: Frame wait returned 0 ***
[   87.395786] *** Channel 0: Frame wait timeout/error, generating frame ***
[   87.400912] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #26) to prevent CSI PHY corruption
[   87.400923] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.485784] *** Channel 0: DQBUF wait returned 1 ***
[   87.485800] *** Channel 0: DQBUF complete - buffer[1] seq=8 flags=0x3 ***
[   87.485824] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #27) to prevent CSI PHY corruption
[   87.485830] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.485948] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   87.485958] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   87.485965] *** Channel 0: DQBUF - dequeue buffer request ***
[   87.485971] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   87.485979] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   87.485986] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   87.485993] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   87.486000] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   87.486007] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   87.486014] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   87.486022] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   87.486028] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   87.486034] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   87.486042] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   87.486049] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   87.486054] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   87.486060] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   87.486066] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   87.486071] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   87.486077] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   87.486082] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   87.486088] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   87.486094] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   87.486100] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   87.486105] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   87.486112] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   87.486118] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   87.486358] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.486372] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.486379] *** Channel 0: Frame completion wait ***
[   87.486385] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.496126] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   87.496139] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   87.496146] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   87.496152] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   87.496160] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   87.496168] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   87.496174] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   87.496182] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   87.496188] *** Channel 0: QBUF - Queue buffer index=1 ***
[   87.496194] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   87.496202] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   87.496209] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   87.496217] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   87.496224] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   87.496230] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   87.496238] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   87.496246] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   87.496252] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   87.496258] *** Channel 0: QBUF EVENT SUCCESS ***
[   87.496265] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   87.496273] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   87.496281] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   87.496289] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   87.496295] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   87.496302] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   87.496314] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   87.496380] *** Channel 0: Frame wait returned 9 ***
[   87.496387] *** Channel 0: Frame was ready, consuming it ***
[   87.685763] *** Channel 0: DQBUF wait returned 0 ***
[   87.685775] *** Channel 0: DQBUF timeout, generating frame ***
[   87.685784] *** Channel 0: DQBUF complete - buffer[2] seq=9 flags=0x3 ***
[   87.685808] TUNING DISABLED: Blocking continuous tuning command 0xc00c56c6 (call #28) to prevent CSI PHY corruption
[   87.685814] TUNING DISABLED: CSI PHY registers must remain stable for VIC interrupts
[   87.685932] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   87.685942] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   87.685948] *** Channel 0: DQBUF - dequeue buffer request ***
[   87.685954] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   87.685963] *** tx_isp_get_sensor: subdevs[0] = 85be2400, ops = c068b238 ***
[   87.685970] *** tx_isp_get_sensor: subdevs[0] ops->sensor = c068b250 ***
[   87.685977] *** tx_isp_get_sensor: subdevs[1] = 85209400, ops = c068b480 ***
[   87.685984] *** tx_isp_get_sensor: subdevs[1] ops->sensor = c068b498 ***
[   87.685991] *** tx_isp_get_sensor: subdevs[2] = 8116e200, ops = c068c2b4 ***
[   87.685999] *** tx_isp_get_sensor: subdevs[2] ops->sensor =   (null) ***
[   87.686006] *** tx_isp_get_sensor: subdevs[3] = 85be2000, ops = c068b410 ***
[   87.686013] *** tx_isp_get_sensor: subdevs[3] ops->sensor = c068b450 ***
[   87.686019] *** tx_isp_get_sensor: subdevs[4] = NULL ***
[   87.686026] *** tx_isp_get_sensor: subdevs[5] = 85e1d400, ops = c06b1ff8 ***
[   87.686033] *** tx_isp_get_sensor: subdevs[5] ops->sensor = c06b200c ***
[   87.686038] *** tx_isp_get_sensor: subdevs[6] = NULL ***
[   87.686044] *** tx_isp_get_sensor: subdevs[7] = NULL ***
[   87.686050] *** tx_isp_get_sensor: subdevs[8] = NULL ***
[   87.686056] *** tx_isp_get_sensor: subdevs[9] = NULL ***
[   87.686061] *** tx_isp_get_sensor: subdevs[10] = NULL ***
[   87.686067] *** tx_isp_get_sensor: subdevs[11] = NULL ***
[   87.686072] *** tx_isp_get_sensor: subdevs[12] = NULL ***
[   87.686078] *** tx_isp_get_sensor: subdevs[13] = NULL ***
[   87.686084] *** tx_isp_get_sensor: subdevs[14] = NULL ***
[   87.686089] *** tx_isp_get_sensor: subdevs[15] = NULL ***
[   87.686096] *** tx_isp_get_sensor: Found real sensor at index 5: 85e1d400 ***
[   87.686102] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   87.686344] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   87.686358] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   87.686365] *** Channel 0: Frame completion wait ***
[   87.686371] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   87.696035] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   87.696048] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   87.696055] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   87.696062] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   87.696069] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   87.696076] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   87.696084] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   87.696090] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   87.696097] *** Channel 0: QBUF - Queue buffer index=2 ***
[   87.696103] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   87.696111] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   87.696118] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   87.696126] *** tx_isp_send_event_to_remote: SAFE implementation - sd=0x85be2000, event=0x3000008 ***
[   87.696132] *** tx_isp_send_event_to_remote: vic_dev=0x85be2000 ***
[   87.696138] *** tx_isp_send_event_to_remote: event_handler=0xc0661c0c ***
[   87.696146] *** tx_isp_send_event_to_remote: Calling event_handler(0x85be2000, 0x3000008, 0x8119fdb8) ***
[   87.696154] *** vic_core_ops_ioctl: EXACT Binary Ninja implementation - cmd=0x3000008, arg=8119fdb8 ***
[   87.696161] vic_core_ops_ioctl: REFERENCE DRIVER - Unknown cmd=0x3000008, returning 0
[   87.696167] *** Channel 0: QBUF EVENT SUCCESS ***
[   87.696174] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   87.696182] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   87.696190] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   87.696198] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=811e1400, vbm_buffer_count=4 ***
[   87.696204] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   87.696211] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   87.696223] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   87.696306] *** Channel 0: Frame wait returned 9 ***
[   87.696314] *** Channel 0: Frame was ready, consuming it ***
root@ing-wyze-cam3-a000 ~# logcat
I/ao( 2038): AO Enable: 0
I/ao( 2038): AO Ch Enable: 0:0
I/ao( 2038): EXIT AO Ch Enable: 0:0
I/ao( 2038): AO Set Vol: 60
I/ao( 2038): AO Get Gain: 20
I/OSD( 1999): IMP_OSD_SetPoolSize:1048576
I/LIBIMP_CONTROL( 1999): Version: Aug 28 2025_05:46:40_ dlsym
E/IMP-ISP( 1999): Cannot open /dev/tx-isp
I/OSD( 2499): IMP_OSD_SetPoolSize:1048576
D/IMP-ISP( 2499): ~~~~~~ IMP_ISP_Open[331] ~~~~~~~
I/IMP-ISP( 2499): IMP_ISP_AddSensor,480: paddr = 0x6300000, size = 0x477e70
I/Alloc Manager( 2499): MEM Alloc Method is kmalloc
D/KMEM Method( 2499): CMD Line Rmem Size:30408704, Addr:0x06300000
D/KMEM Method( 2499): alloc->mem_alloc.method = kmalloc
 			alloc->mem_alloc.vaddr = 0x74e2b000
 			alloc->mem_alloc.paddr = 0x06300000
 			alloc->mem_alloc.length = 30408704
I/Alloc Manager( 2499): MEM Manager Method is continuous
D/System( 2499): IMP_System_Init SDK Version:1.1.6-a6394f42-Mon Dec 5 14:39:51 2022 +0800, built: Dec 29 2022 15:38:51
D/System( 2499): system_init()
D/System( 2499): Calling DSystem
D/System( 2499): Calling FrameSource
D/System( 2499): [ignored]read /proc/cpuinfo ret is NULLD/System( 2499): Calling IVS
D/System( 2499): Calling OSD
D/System( 2499): Calling Encoder
D/System( 2499): Calling FB
E/aenc( 2499): ai_buf size error 0
I/ai( 2499): AI Enable: 1
I/ai( 2499): AI Enable Chn: 1-0
I/ai( 2499): EXIT AI Enable Chn: 1-0
I/ai( 2499): AI Set Vol: 80
I/ai( 2499): AI Get Vol: 80
I/ai( 2499): AI Set Gain: 25
I/ai( 2499): AI Get Gain: 25
E/Framesource( 2499): IMP_FrameSource_GetChnAttr(): chnAttr was not set yet
D/Encoder( 2499): IMP_Encoder_SetbufshareChn: encChn:2, shareChn:0
E/MemPool( 2499): IMP_Encoder_GetPool(64):chnNum: 0 not bind pool
I/Encoder( 2499): encChn=0,srcFrameCnt=3,srcFrameSize=3133440
I/Encoder( 2499): encChn=0,srcStreamCnt=2,enc_chn->stream_frame_size=949248
I/OSD( 2499): IMP_OSD_SetPoolSize:1048576
I/OSD( 2499): IMP_OSD_CreateRgn(1227) create handle=0 success
I/OSD( 2499): IMP_OSD_CreateRgn(1227) create handle=1 success
I/OSD( 2499): IMP_OSD_CreateRgn(1227) create handle=2 success
I/OSD( 2499): IMP_OSD_CreateRgn(1227) create handle=3 success
D/System( 2499): system_bind(): bind DST-OSD-0(4.0.0) to SRC-Framesource-0(0.0.0)
D/System( 2499): system_bind(): bind DST-Encoder-0(1.0.0) to SRC-OSD-0(4.0.0)
I/Framesource( 2499): [chn0]: width = 1920 height = 1080
I/VBM( 2499): VBMCreatePool()-0: w=1920 h=1080 f=842094158 nrVBs=4
I/VBM( 2499): VBMCreatePool()-0: pool->config.fmt.fmt.pix.sizeimage=0 sizeimage=3133440
E/Framesource( 2499): IMP_FrameSource_GetPool(3294):chnNum: 0 not bind pool
E/VBM( 2499): VBMCreatePool()-0: sizeimage=3133440
I/VBM( 2499): PoolId:0, frame=0x74cf77a0, frame->priv=0x74cf77cc, frame[0].virAddr=75c04000, frame[0].phyAddr=70d9000
I/VBM( 2499): PoolId:0, frame=0x74cf7bc8, frame->priv=0x74cf7bf4, frame[1].virAddr=75f01000, frame[1].phyAddr=73d6000
I/VBM( 2499): PoolId:0, frame=0x74cf7ff0, frame->priv=0x74cf801c, frame[2].virAddr=761fe000, frame[2].phyAddr=76d3000
I/VBM( 2499): PoolId:0, frame=0x74cf8418, frame->priv=0x74cf8444, frame[3].virAddr=764fb000, frame[3].phyAddr=79d0000
E/MemPool( 2499): IMP_Encoder_GetPool(64):chnNum: 2 not bind pool
I/Encoder( 2499): encChn=2,srcFrameCnt=2,srcFrameSize=3133440
I/Encoder( 2499): encChn=2,srcStreamCnt=0,enc_chn->stream_frame_size=0
I/OSD( 2499): IMP_OSD_SetPoolSize:1048576
E/IMP-ISP( 2499): err:video drop 
I/Encoder( 2499): framePriv->i_fps_num=25, framePriv->i_fps_den=1
D/Encoder( 2499): enc_chn->index=0, gopAttr->uGopCtrlMode=2, gopAttr->uGopLength=20, gopAttr->uNotifyUserLTInter=0, gopAttr->uMaxSameSenceCnt=2, gopAttr->bEnableLT=0, gopAttr->uFreqLT=0, gopAttr->bLTRC=0
D/Encoder( 2499): enc_chn->index=0, enc_chn->chnFpsMask=1, enc_chn->inFrmRate.frmRateNum=25, enc_chn->inFrmRate.frmRateDen=1, enc_chn->setFrmRate.frmRateNum=25, enc_chn->setFrmRate.frmRateDen=1, rcAttr->outFrmRate.frmRateNum=25, rcAttr->outFrmRate.frmRateDen=1
D/Encoder( 2499): do_day_night_change(664):enc_chn->inStat.is_day=1
I/Encoder( 2499): framePriv->i_fps_num=25, framePriv->i_fps_den=1
D/Encoder( 2499): enc_chn->index=2, gopAttr->uGopCtrlMode=2, gopAttr->uGopLength=0, gopAttr->uNotifyUserLTInter=0, gopAttr->uMaxSameSenceCnt=1, gopAttr->bEnableLT=0, gopAttr->uFreqLT=0, gopAttr->bLTRC=0
D/Encoder( 2499): enc_chn->index=2, enc_chn->chnFpsMask=1fff7ff, enc_chn->inFrmRate.frmRateNum=25, enc_chn->inFrmRate.frmRateDen=1, enc_chn->setFrmRate.frmRateNum=24, enc_chn->setFrmRate.frmRateDen=1, rcAttr->outFrmRate.frmRateNum=24, rcAttr->outFrmRate.frmRateDen=1
D/Encoder( 2499): do_day_night_change(664):enc_chn->inStat.is_day=1
E/IMP-ISP( 2499): err:video drop 
E/IMP-ISP( 2499): err:video drop 
root@ing-wyze-cam3-a000 ~# cat /proc/interrupts 
           CPU0       
  9:          0   jz-intc  i2s_irq
 11:      24472   jz-intc  jz-timerost
 14:        180   jz-intc  ipu
 15:      12794   jz-intc  jz-sfc
 18:          0   jz-intc  pdma
 23:          0   jz-intc  GPIO C
 24:          1   jz-intc  GPIO B
 25:          0   jz-intc  GPIO A
 29:          1   jz-intc  dwc2
 37:          0   jz-intc  isp-m0
 38:          0   jz-intc  isp-w02
 44:       9016   jz-intc  jzmmc_v1.2.1
 45:          0   jz-intc  jzmmc_v1.2.0
 58:        388   jz-intc  uart1
 68:          7   jz-intc  jz-i2c.0
 70:         55   jz-intc  avpu.0
126:          0    GPIO B  GPIO Button
134:          1    GPIO B  mmc-insert-detect
ERR:          0
