[    7.999343] RTW: hal_com_config_channel_plan chplan:0x20
[    8.083164] RTW: [RF_PATH] ver_id.RF_TYPE:RF_1T1R
[    8.083179] RTW: [RF_PATH] HALSPEC's rf_reg_trx_path_bmp:0x11, rf_reg_path_avail_num:1, max_tx_cnt:1
[    8.083186] RTW: [RF_PATH] PG's trx_path_bmp:0x00, max_tx_cnt:0
[    8.083193] RTW: [RF_PATH] Registry's trx_path_bmp:0x00, tx_path_lmt:0, rx_path_lmt:0
[    8.083199] RTW: [RF_PATH] HALDATA's trx_path_bmp:0x11, max_tx_cnt:1
[    8.083206] RTW: [RF_PATH] HALDATA's rf_type:RF_1T1R, NumTotalRFPath:1
[    8.083213] RTW: [TRX_Nss] HALSPEC - tx_nss:1, rx_nss:1
[    8.083219] RTW: [TRX_Nss] Registry - tx_nss:0, rx_nss:0
[    8.083226] RTW: [TRX_Nss] HALDATA - tx_nss:1, rx_nss:1
[    8.084430] RTW: rtw_regsty_chk_target_tx_power_valid return _FALSE for band:0, path:0, rs:0, t:-1
[    8.104494] RTW: rtw_ndev_init(wlan0) if1 mac_addr=4c:31:2d:6a:d0:0d
[    8.117681] RTW: rtw_ndev_init(wlan1) if2 mac_addr=4e:31:2d:6a:d0:0d
[    8.133333] RTW: module init ret=0
[    8.761758] RTW: txpath=0x1, rxpath=0x1
[    8.761770] RTW: txpath_1ss:0x1, num:1
[    8.847628] IPv6: ADDRCONF(NETDEV_UP): wlan0: link is not ready
[   10.533095] RTW: rtw_set_802_11_connect(wlan0)  fw_state=0x00000008
[   10.772169] RTW: start auth
[   10.777393] RTW: auth success, start assoc
[   10.782979] RTW: assoc success
[   10.783071] IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
[   10.784550] RTW: ============ STA [e8:9c:25:02:11:0c]  ===================
[   10.784561] RTW: mac_id : 0
[   10.784567] RTW: wireless_mode : 0x0b
[   10.784572] RTW: mimo_type : 0
[   10.784578] RTW: static smps : N
[   10.784584] RTW: bw_mode : 20MHz, ra_bw_mode : 20MHz
[   10.784589] RTW: rate_id : 3
[   10.784595] RTW: rssi : -1 (%), rssi_level : 0
[   10.784601] RTW: is_support_sgi : Y, is_vht_enable : N
[   10.784607] RTW: disable_ra : N, disable_pt : N
[   10.784613] RTW: is_noisy : N
[   10.784618] RTW: txrx_state : 0
[   10.784625] RTW: curr_tx_rate : CCK_1M (L)
[   10.784630] RTW: curr_tx_bw : 20MHz
[   10.784635] RTW: curr_retry_ratio : 0
[   10.784641] RTW: ra_mask : 0x00000000000fffff
[   10.784641] 
[   10.787571] RTW: recv eapol packet 1/4
[   10.788753] RTW: send eapol packet 2/4
[   10.794141] RTW: recv eapol packet 3/4
[   10.794504] RTW: send eapol packet 4/4
[   10.795688] RTW: set pairwise key camid:0, addr:e8:9c:25:02:11:0c, kid:0, type:AES
[   10.795984] RTW: set group key camid:1, addr:e8:9c:25:02:11:0c, kid:1, type:AES
[   13.747011] codec_codec_ctl: set repaly channel...
[   13.747049] cgu_set_rate, parent = 1392000000, rate = 4096000, n = 10875, reg val = 0x22002a7b
[   13.747056] codec_codec_ctl: set sample rate...
[   13.747143] codec_codec_ctl: set device...
[   13.979150] codec_set_device: set device: speaker...
[   27.724020] *** tx_isp_init: EXACT Binary Ninja MCP reference implementation ***
[   27.726508] *** PROBE: tx_isp_platform_probe CALLED for device tx-isp ***
[   27.726526] *** PROBE: ISP device allocated successfully: 846b8000 ***
[   27.726542] *** PROBE: ISP core registers mapped at 0x13300000 for system_reg_write ***
[   27.726548] *** PROBE: ISP device mutex and spinlock initialized ***
[   27.726555] *** PROBE: Event callback structure initialized at 0x85acae00 (offset 0xc from isp_dev) ***
[   27.726566] parse_rmem_bootarg: Found rmem=29M@0x06300000 (size=0x01d00000)
[   27.726573] *** PROBE: Initialized rmem_addr=0x06300000, size=0x01d00000 ***
[   27.726579] *** PROBE: Platform data: c06b7790 ***
[   27.726584] *** PROBE: Platform data validation passed ***
[   27.726590] *** REFERENCE DRIVER: Individual subdevices will initialize their own memory regions ***
[   27.726596] *** PLATFORM DEVICES ALREADY REGISTERED IN INIT - SKIPPING DUPLICATE REGISTRATION ***
[   27.726601] *** tx_isp_module_init: EXACT Binary Ninja reference implementation ***
[   27.726606] *** tx_isp_module_init: Registering subdev platform drivers FIRST ***
[   27.726612] *** TX ISP SUBDEV PLATFORM DRIVERS REGISTRATION ***
[   27.750919] All ISP subdev platform drivers registered successfully
[   27.753710] *** tx_isp_create_graph_and_nodes: EXACT Binary Ninja reference implementation ***
[   27.753724] *** Registering platform device 0 from platform data ***
[   27.756250] *** tx_isp_subdev_init: CALLED for device 'isp-w01' ***
[   27.756265] *** tx_isp_subdev_init: pdev=c06b7470, sd=85217800, ops=c06b7a90 ***
[   27.756272] *** tx_isp_subdev_init: ourISPdev=846b8000 ***
[   27.756278] *** tx_isp_subdev_init: ops=c06b7a90, ops->core=c06b7ac4 ***
[   27.756284] *** tx_isp_subdev_init: ops->core->init=c066d0e8 ***
[   27.756291] *** tx_isp_subdev_init: Set sd->dev=c06b7480, sd->pdev=c06b7470 ***
[   27.756298] *** tx_isp_subdev_init: CSI subdev registered at slot 0 ***
[   27.756304] tx_isp_module_init: Module initialized for isp-w01
[   27.756310] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   27.756316] *** isp-w01: Skipping IRQ request - device has no IRQ resource ***
[   27.756323] tx_isp_subdev_init: platform_get_resource returned c06b7568 for device isp-w01
[   27.756331] tx_isp_subdev_init: Memory resource found: start=0x10022000, end=0x10022fff, size=0x00001000
[   27.756340] *** tx_isp_subdev_init: Clock initialization deferred until streaming starts ***
[   27.756346] *** tx_isp_subdev_init: Clock count stored: 2 ***
[   27.756354] *** tx_isp_subdev_auto_link: ENTRY - pdev=c06b7470, sd=85217800, ourISPdev=846b8000 ***
[   27.756361] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-w01' to ourISPdev=846b8000 ***
[   27.756366] *** DEBUG: Device name comparison - checking 'isp-w01' ***
[   27.756372] *** DEBUG: About to check device name matches ***
[   27.756378] *** DEBUG: VIN device name matched! Setting up VIN device ***
[   27.756383] *** LINKED VIN device: 85217800 ***
[   27.756391] *** VIN SUBDEV OPS CONFIGURED: core=c06b8914, video=c06b8908, s_stream=c068f418 ***
[   27.756397] *** REGISTERED VIN SUBDEV AT SLOT 1 WITH VIDEO OPS ***
[   27.756404] *** CSI PROBE: Set dev_priv to csi_dev 85217800 AFTER subdev_init ***
[   27.756410] *** CSI PROBE: Set host_priv to csi_dev 85217800 AFTER subdev_init ***
[   27.756416] *** CSI PROBE: Using register mapping from tx_isp_subdev_init: b0022000 ***
[   27.756422] *** CSI PROBE: Device linking handled automatically by tx_isp_subdev_init ***
[   27.756442] *** Platform device 0 (isp-w01) registered successfully ***
[   27.756448] *** Registering platform device 1 from platform data ***
[   27.760410] *** VIC PROBE: IRQ numbers initialized to 38 ***
[   27.760424] *** VIC PROBE: Primary VIC registers mapped at 0x133e0000 -> b33e0000 ***
[   27.760431] *** VIC PROBE: VIC control registers mapped at 0x10023000 -> b0023000 ***
[   27.760437] *** VIC PROBE: Hardware IRQ function pointers set using SAFE struct members (tx_isp_enable/disable_irq) ***
[   27.760444] *** VIC PROBE: Secondary VIC register test - 0x1e0 = 0x00000000 (mapping verified) ***
[   27.760450] *** VIC PROBE: VIC interrupt registers will be configured during tx_isp_vic_start ***
[   27.760455] *** BINARY NINJA MCP: VIC buffer management ENABLED - following reference driver ***
[   27.760461] *** VIC will operate in FULL mode with complete buffer operations ***
[   27.760466] *** BINARY NINJA MCP: VIC full initialization complete - buffer management ENABLED ***
[   27.760473] *** VIC PROBE: Initialized default dimensions 1920x1080 and critical fields ***
[   27.760479] *** VIC PROBE: Event callback structure stored in VIC device field ***
[   27.760485] *** VIC PROBE: Stored vic_dev pointer 846be000 in subdev dev_priv ***
[   27.760492] *** VIC PROBE: Set host_priv to vic_dev 846be000 for Binary Ninja compatibility ***
[   27.760498] *** VIC PROBE: Skipping tx_isp_vic_hw_init - working branch configures interrupts during VIC operations ***
[   27.760505] *** tx_isp_subdev_init: CALLED for device 'isp-w02' ***
[   27.760512] *** tx_isp_subdev_init: pdev=c06b7588, sd=846be000, ops=c06b7a10 ***
[   27.760518] *** tx_isp_subdev_init: ourISPdev=846b8000 ***
[   27.760525] *** tx_isp_subdev_init: ops=c06b7a10, ops->core=c06b7a2c ***
[   27.760531] *** tx_isp_subdev_init: ops->core->init=c0682c5c ***
[   27.760538] *** tx_isp_subdev_init: Set sd->dev=c06b7598, sd->pdev=c06b7588 ***
[   27.760544] *** tx_isp_subdev_init: VIC device linked and registered at slot 2 ***
[   27.760550] tx_isp_module_init: Module initialized for isp-w02
[   27.760556] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   27.760564] *** tx_isp_request_irq: platform_get_irq returned 38 for device isp-w02 ***
[   27.760571] *** tx_isp_request_irq: Using main ISP device as dev_id for IRQ 38 (device: isp-w02) ***
[   27.760581] *** tx_isp_request_irq: About to call request_threaded_irq(irq=38, handler=c0675780, thread=c0668584, flags=0x80, name=isp-w02, dev_id=846b8000) ***
[   27.760589] *** tx_isp_request_irq: About to register IRQ 38 with handlers: main=c0675780, thread=c0668584 ***
[   27.770278] *** tx_isp_request_irq: request_threaded_irq returned 0 ***
[   27.770288] *** tx_isp_request_irq: IRQ 38 LEFT ENABLED (working version behavior) ***
[   27.770296] *** tx_isp_request_irq: IRQ 38 registered successfully for isp-w02 ***
[   27.770304] tx_isp_subdev_init: platform_get_resource returned c06b7680 for device isp-w02
[   27.770312] tx_isp_subdev_init: Memory resource found: start=0x10023000, end=0x10023fff, size=0x00001000
[   27.770321] *** tx_isp_subdev_init: Clock initialization deferred until streaming starts ***
[   27.770326] *** tx_isp_subdev_init: Clock count stored: 2 ***
[   27.770334] *** tx_isp_subdev_auto_link: ENTRY - pdev=c06b7588, sd=846be000, ourISPdev=846b8000 ***
[   27.770342] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-w02' to ourISPdev=846b8000 ***
[   27.770348] *** DEBUG: Device name comparison - checking 'isp-w02' ***
[   27.770352] *** DEBUG: About to check device name matches ***
[   27.770358] *** DEBUG: VIC DEVICE NAME MATCHED! Processing VIC device linking ***
[   27.770364] *** DEBUG: Retrieved vic_dev from subdev data: 846be000 ***
[   27.770370] *** DEBUG: About to set ourISPdev->vic_dev = 846be000 ***
[   27.770376] *** DEBUG: ourISPdev before linking: 846b8000 ***
[   27.770382] *** DEBUG: ourISPdev->vic_dev set to: 846be000 ***
[   27.770388] *** VIC AUTO-LINK: VIC IRQ already registered (irq=38) ***
[   27.770393] *** VIC AUTO-LINK: Using existing VIC register mapping (0x133e0000) - NOT remapping ***
[   27.770399] *** VIC AUTO-LINK: Registers are mapped, registering interrupt handler ***
[   27.770406] *** VIC PROBE: Device linking handled automatically by tx_isp_subdev_init ***
[   27.770412] *** VIC PROBE: Sensor dimensions will be cached when sensor module loads ***
[   27.770417] *** VIC PROBE: VIC frame channel streaming will be initialized via tisp_init ***
[   27.770423] *** VIC PROBE: Waiting for core subdev init to call tisp_init which calls tx_isp_subdev_pipo ***
[   27.770443] *** Platform device 1 (isp-w02) registered successfully ***
[   27.770450] *** Registering platform device 2 from platform data ***
[   27.771464] *** tx_isp_subdev_init: CALLED for device 'isp-w00' ***
[   27.771479] *** tx_isp_subdev_init: pdev=c06b7398, sd=84cdb000, ops=c06b88f4 ***
[   27.771485] *** tx_isp_subdev_init: ourISPdev=846b8000 ***
[   27.771492] *** tx_isp_subdev_init: ops=c06b88f4, ops->core=c06b8914 ***
[   27.771498] *** tx_isp_subdev_init: ops->core->init=c068f220 ***
[   27.771504] *** tx_isp_subdev_init: Set sd->dev=c06b73a8, sd->pdev=c06b7398 ***
[   27.771511] *** tx_isp_subdev_init: NOT A SENSOR - ops=c06b88f4 ***
[   27.771518] *** tx_isp_subdev_init: ops->sensor=  (null), csi_subdev_ops=c06b7a90 ***
[   27.771524] tx_isp_module_init: Module initialized for isp-w00
[   27.771530] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   27.771538] *** tx_isp_subdev_auto_link: ENTRY - pdev=c06b7398, sd=84cdb000, ourISPdev=846b8000 ***
[   27.771545] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-w00' to ourISPdev=846b8000 ***
[   27.771551] *** DEBUG: Device name comparison - checking 'isp-w00' ***
[   27.771556] *** DEBUG: About to check device name matches ***
[   27.771562] *** LINKED CSI device: 84cdb000, regs:   (null) ***
[   27.771569] *** VIN PROBE: Set dev_priv to vin_dev 84cdb000 AFTER subdev_init ***
[   27.771574] *** VIN PROBE: Device linking handled automatically by tx_isp_subdev_init ***
[   27.771594] *** Platform device 2 (isp-w00) registered successfully ***
[   27.771601] *** Registering platform device 3 from platform data ***
[   27.774161] *** tx_isp_subdev_init: CALLED for device 'isp-fs' ***
[   27.774176] *** tx_isp_subdev_init: pdev=c06b7258, sd=85409800, ops=c06b7b44 ***
[   27.774182] *** tx_isp_subdev_init: ourISPdev=846b8000 ***
[   27.774190] *** tx_isp_subdev_init: ops=c06b7b44, ops->core=c06be9cc ***
[   27.774195] *** tx_isp_subdev_init: WARNING - ops->core->init is NULL! ***
[   27.774202] *** tx_isp_subdev_init: Set sd->dev=c06b7268, sd->pdev=c06b7258 ***
[   27.774208] *** tx_isp_subdev_init: NOT A SENSOR - ops=c06b7b44 ***
[   27.774215] *** tx_isp_subdev_init: ops->sensor=c06be9c0, csi_subdev_ops=c06b7a90 ***
[   27.774221] tx_isp_module_init: Module initialized for isp-fs
[   27.774226] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   27.774233] *** isp-fs: Skipping IRQ request - device has no IRQ resource ***
[   27.774240] tx_isp_subdev_init: platform_get_resource returned   (null) for device isp-fs
[   27.774246] tx_isp_subdev_init: No memory resource for device isp-fs (logical device - OK)
[   27.774253] *** FS PROBE: Set dev_priv to fs_dev 85409800 AFTER subdev_init ***
[   27.774259] *** FS PROBE: Device linking handled automatically by tx_isp_subdev_auto_link() ***
[   27.774278] *** Platform device 3 (isp-fs) registered successfully ***
[   27.774285] *** Registering platform device 4 from platform data ***
[   27.776774] *** tx_isp_core_probe: NEW ARCHITECTURE - Creating separate core device ***
[   27.776787] *** tx_isp_create_core_device: Creating ISP core device ***
[   27.776797] *** tx_isp_create_core_device: Core device created successfully: 846be400 ***
[   27.776804] *** CORE PROBE: Set dev_priv to core_dev 846be400 ***
[   27.776810] *** CORE PROBE: Set host_priv to core_dev 846be400 - PREVENTS BadVA CRASH ***
[   27.776816] *** tx_isp_subdev_init: CALLED for device 'isp-m0' ***
[   27.776824] *** tx_isp_subdev_init: pdev=c06b7120, sd=846be400, ops=c06b7848 ***
[   27.776830] *** tx_isp_subdev_init: ourISPdev=846b8000 ***
[   27.776837] *** tx_isp_subdev_init: ops=c06b7848, ops->core=c06b7874 ***
[   27.776842] *** tx_isp_subdev_init: WARNING - ops->core->init is NULL! ***
[   27.776850] *** tx_isp_subdev_init: Set sd->dev=c06b7130, sd->pdev=c06b7120 ***
[   27.776856] *** tx_isp_subdev_init: Core ISP subdev registered at slot 3 ***
[   27.776862] tx_isp_module_init: Module initialized for isp-m0
[   27.776868] *** tx_isp_subdev_init: VIC interrupt registration will happen in auto-linking function ***
[   27.776876] *** tx_isp_request_irq: platform_get_irq returned 37 for device isp-m0 ***
[   27.776882] *** tx_isp_request_irq: Using main ISP device as dev_id for IRQ 37 (device: isp-m0) ***
[   27.776892] *** tx_isp_request_irq: About to call request_threaded_irq(irq=37, handler=c0675780, thread=c0668584, flags=0x80, name=isp-m0, dev_id=846b8000) ***
[   27.776900] *** tx_isp_request_irq: About to register IRQ 37 with handlers: main=c0675780, thread=c0668584 ***
[   27.779178] *** tx_isp_request_irq: request_threaded_irq returned 0 ***
[   27.779190] *** tx_isp_request_irq: IRQ 37 LEFT ENABLED (working version behavior) ***
[   27.779197] *** tx_isp_request_irq: IRQ 37 registered successfully for isp-m0 ***
[   27.779206] tx_isp_subdev_init: platform_get_resource returned c06b7220 for device isp-m0
[   27.779214] tx_isp_subdev_init: Memory resource found: start=0x13300000, end=0x133fffff, size=0x00100000
[   27.779224] *** tx_isp_subdev_init: Clock initialization deferred until streaming starts ***
[   27.779229] *** tx_isp_subdev_init: Clock count stored: 3 ***
[   27.779237] *** tx_isp_subdev_auto_link: ENTRY - pdev=c06b7120, sd=846be400, ourISPdev=846b8000 ***
[   27.779244] *** tx_isp_subdev_auto_link: Auto-linking device 'isp-m0' to ourISPdev=846b8000 ***
[   27.779250] *** DEBUG: Device name comparison - checking 'isp-m0' ***
[   27.779256] *** DEBUG: About to check device name matches ***
[   27.779262] *** DEBUG: CORE device name matched! Setting up Core device ***
[   27.779268] *** CRITICAL FIX: CORE regs mapped to core device: b3300000 ***
[   27.779276] *** tx_isp_link_core_device: Linking core device 846be400 to ISP device 846b8000 ***
[   27.779282] *** tx_isp_link_core_device: Core device linked successfully ***
[   27.779288] *** Core subdev already registered at slot 3: 846be400 ***
[   27.779294] *** LINKED CORE device: 846be400 ***
[   27.779299] *** CORE SUBDEV REGISTERED AT INDEX 0 ***
[   27.779304] *** tx_isp_core_probe: Core subdev initialized successfully ***
[   27.779311] *** tx_isp_core_device_init: Initializing core device: 846be400 ***
[   27.779322] *** tx_isp_core_device_init: State transitions handled by slake_module ***
[   27.779328] *** tx_isp_core_device_init: Core device initialized successfully ***
[   27.779333] *** tx_isp_core_device_init: Core sensor IOCTL handler set for sensor registration ***
[   27.779340] *** tx_isp_link_core_device: Linking core device 846be400 to ISP device 846b8000 ***
[   27.779346] *** tx_isp_link_core_device: Core device linked successfully ***
[   27.779352] *** Core subdev already registered at slot 3: 846be400 ***
[   27.779366] *** tx_isp_core_probe: Assigned frame_channels=846be800 to core_dev ***
[   27.779372] *** tx_isp_core_probe: VIC device creation deferred to platform driver system ***
[   27.779377] *** tx_isp_core_probe: Platform drivers will call tx_isp_subdev_init for proper initialization ***
[   27.779383] *** tx_isp_core_probe: Calling sensor_early_init ***
[   27.779388] *** tx_isp_core_probe: ISP clock management handled by infrastructure ***
[   27.779394] *** tx_isp_core_probe: ispcore_slake_module will be called when VIC reaches streaming state ***
[   27.779400] *** tx_isp_core_probe: Core device setup complete ***
[   27.779405] ***   - Core device: 846be400 ***
[   27.779410] ***   - Channel count: 6 ***
[   27.779416] ***   - Linked to ISP device: 846b8000 ***
[   27.779421] *** tx_isp_core_probe: Initializing core tuning system ***
[   27.779426] isp_core_tuning_init: Initializing tuning data structure
[   27.779439] isp_core_tuning_init: Tuning data structure initialized at 84d56000
[   27.779445] isp_core_tuning_init: Structure size: 4356 bytes (vs Binary Ninja 0x40d0)
[   27.779450] *** SAFE: mode_flag properly initialized using struct member access ***
[   27.779456] *** tx_isp_core_probe: Tuning init SUCCESS ***
[   27.779461] *** tx_isp_core_probe: Set platform driver data ***
[   27.779466] *** tx_isp_core_probe: Set global core device reference ***
[   27.779471] *** tx_isp_core_probe: SUCCESS - Core device fully initialized ***
[   27.779477] ***   - Core device: 846be400 ***
[   27.779482] ***   - Tuning device: 84d56000 ***
[   27.779488] *** tx_isp_core_probe: Creating frame channel devices ***
[   27.779493] *** tx_isp_create_framechan_devices: Creating frame channel devices ***
[   27.779846] *** Created frame channel device: /dev/framechan0 (major=10, minor=54) ***
[   27.790400] *** Created frame channel device: /dev/framechan1 (major=10, minor=53) ***
[   27.793028] *** Created frame channel device: /dev/framechan2 (major=10, minor=52) ***
[   27.795545] *** Created frame channel device: /dev/framechan3 (major=10, minor=51) ***
[   27.795556] *** tx_isp_create_framechan_devices: All frame channel devices created ***
[   27.795561] *** tx_isp_core_probe: Frame channel devices created successfully ***
[   27.795566] *** tx_isp_core_probe: Creating ISP M0 tuning device node ***
[   27.795572] tisp_code_create_tuning_node: Creating ISP M0 tuning device node
[   27.795582] tisp_code_create_tuning_node: Allocated dynamic major 251
[   27.803187] *** ISP M0 TUNING DEVICE CREATED: /dev/isp-m0 (major=251, minor=0) ***
[   27.803198] *** tx_isp_core_probe: ISP M0 tuning device node created successfully ***
[   27.803204] *** tx_isp_core_probe: Core probe completed successfully ***
[   27.803223] *** Platform device 4 (isp-m0) registered successfully ***
[   27.803229] *** tx_isp_create_graph_and_nodes: Creating /proc/jz/isp entries ***
[   27.803252] *** Created /proc/jz/isp directory ***
[   27.803260] *** PROC ENTRY DEBUG: Using isp_vic_frd_fops for isp-w01 (with ioctl handler) ***
[   27.803268] *** Created /proc/jz/isp/isp-w01 entry with file ops ***
[   27.803275] *** PROC ENTRY DEBUG: Using vic_w02_proc_fops for isp-w02 (with write handler) ***
[   27.803282] *** PROC ENTRY DEBUG: vic_w02_proc_fops.write=c0684cac ***
[   27.803290] *** PROC ENTRY FIX: Using ISP device 846b8000 instead of VIC device 846be000 for isp-w02 ***
[   27.803298] *** Created /proc/jz/isp/isp-w02 entry with file ops ***
[   27.803304] *** PROC ENTRY DEBUG: Using isp_vic_frd_fops for isp-w00 (with ioctl handler) ***
[   27.803313] *** Created /proc/jz/isp/isp-w00 entry with file ops ***
[   27.803322] *** Created /proc/jz/isp/isp-fs entry with file ops ***
[   27.803332] *** Created /proc/jz/isp/isp-m0 entry with file ops ***
[   27.803337] *** tx_isp_create_graph_and_nodes: Registering misc devices ***
[   27.803342] *** Misc device registration handled via main tx-isp device ***
[   27.803348] *** Misc device registration handled via main tx-isp device ***
[   27.803353] *** Misc device registration handled via main tx-isp device ***
[   27.803358] *** Misc device registration handled via main tx-isp device ***
[   27.803364] *** Misc device registration handled via main tx-isp device ***
[   27.803369] *** tx_isp_create_graph_and_nodes: Initializing frame channels ***
[   27.803378] *** Frame channel 0 initialized: 1920x1080, state=2 ***
[   27.803386] *** Frame channel 1 initialized: 640x360, state=2 ***
[   27.803391] *** tx_isp_create_graph_and_nodes: Binary Ninja reference implementation complete ***
[   27.803398] *** tx_isp_module_init: VIC device linkage check - isp_dev->vic_dev = 846be000 ***
[   27.803403] *** ENABLING HARDWARE INTERRUPT GENERATION ***
[   27.803408] *** WRITING VIC INTERRUPT ENABLE REGISTERS ***
[   27.803415] *** EARLY VIC ENABLES (MODULE INIT): PRIMARY [1e0]=0x00000000 [1e4]=0x00000000 ***
[   27.803422] *** EARLY VIC ENABLES (MODULE INIT): CONTROL [1e0]=0x00000000 [1e4]=0x00000000 ***
[   27.803428] *** ENABLING ISP CORE INTERRUPT REGISTERS FOR MIPI DATA ***
[   27.803433] *** ISP CORE INTERRUPT REGISTERS ENABLED at legacy(+0xb*) and new(+0x98b*) ***
[   27.803438] *** BOTH VIC AND ISP CORE INTERRUPTS NOW ENABLED! ***
[   27.803444] *** tx_isp_module_init: Binary Ninja reference implementation complete ***
[   27.803449] *** PROBE: Binary Ninja reference implementation complete ***
[   27.806252] *** tx_isp_init: Platform device and driver registered successfully ***
[   29.208397] === gc2053 SENSOR MODULE INIT ===
[   29.218506] gc2053 I2C driver registered, waiting for device creation by ISP
[   31.381868] ISP opened successfully
[   31.382206] ISP IOCTL: cmd=0x805056c1 arg=0x77460d60
[   31.382221] subdev_sensor_ops_ioctl: cmd=0x2000000
[   31.382227] *** subdev_sensor_ops_ioctl: IOCTL 0x2000000 - Creating I2C sensor device ***
[   31.382233] *** Creating I2C sensor device on adapter 0 ***
[   31.382242] *** Creating I2C device: gc2053 at 0x37 ***
[   31.382247] *** isp_i2c_new_subdev_board: MIPS-SAFE implementation - FIXED CRASH ***
[   31.382255] Creating I2C subdev: type=gc2053 addr=0x37 on adapter i2c0 (MIPS-safe)
[   31.382261] *** MIPS-SAFE: Requesting sensor module gc2053 ***
[   31.385051] *** MIPS-SAFE: Valid I2C address 0x37, creating device ***
[   31.390604] === GC2053 SENSOR PROBE START ===
[   31.390621] sensor_probe: client=854ccb00, addr=0x37, adapter=84074c10 (i2c0)
[   31.390627] === PERFORMING GPIO RESET SEQUENCE BEFORE I2C ===
[   31.390633] Requesting reset GPIO 18
[   31.390641] GPIO reset sequence: HIGH -> LOW -> HIGH
root@ing-wyze-cam3-a000 ~# dmesg 
[   31.620732] sensor_read: reg=0xf0, client=854ccb00, adapter=i2c0, addr=0x37
[   31.623912] sensor_read: reg=0xf0 value=0x20 SUCCESS
[   31.623924] I2C test read (0xf0): ret=0, val=0x20 (expected 0x20)
[   31.623930] *** SUCCESS: I2C communication working after GPIO reset! ***
[   31.623940] sensor_read: reg=0xf1, client=854ccb00, adapter=i2c0, addr=0x37
[   31.624606] sensor_read: reg=0xf1 value=0x53 SUCCESS
[   31.624616] I2C test read (0xf1): ret=0, val=0x53 (expected 0x53)
[   31.624622] === I2C COMMUNICATION TEST COMPLETE ===
[   31.624630] Registering gc2053 with ISP framework (sd=85f69400, sensor=85f69400)
[   31.624636] gc2053 registered with ISP framework successfully
[   31.624660] *** MIPS-SAFE: I2C device created successfully at 0x854ccb00 ***
[   31.624668] *** MIPS-SAFE: Module reference acquired for gc2053 ***
[   31.624673] *** MIPS-SAFE: Sensor subdev data found, device ready ***
[   31.624680] *** I2C DEVICE READY: gc2053 at 0x37 (MIPS-safe) ***
[   31.624686] *** I2C sensor device created successfully: gc2053 at 0x37 ***
[   31.624729] ISP IOCTL: cmd=0xc050561a arg=0x7f9d3c28
[   31.624736] TX_ISP_SENSOR_ENUM_INPUT: Enumerating sensor at index 0
[   31.624744] TX_ISP_SENSOR_ENUM_INPUT: Returning sensor 'gc2053' at index 0
[   31.624752] ISP IOCTL: cmd=0xc050561a arg=0x7f9d3c28
[   31.624758] TX_ISP_SENSOR_ENUM_INPUT: Enumerating sensor at index 1
[   31.624763] TX_ISP_SENSOR_ENUM_INPUT: No sensor at index 1 - returning error to end enumeration
[   31.624771] ISP IOCTL: cmd=0xc0045627 arg=0x7f9d3c80
[   31.624782] ISP IOCTL: cmd=0x800856d5 arg=0x7f9d3c78
[   31.624788] TX_ISP_GET_BUF: IOCTL handler called
[   31.624794] TX_ISP_GET_BUF: core_dev=846be400, isp_dev=846b8000
[   31.624801] TX_ISP_GET_BUF: Using dimensions 1920x1080 from core device
[   31.624808] TX_ISP_GET_BUF: Returning buffer size=4685424, paddr=0x6300000
[   31.699696] ISP IOCTL: cmd=0x800856d4 arg=0x7f9d3c78
[   31.699710] TX_ISP_SET_BUF: addr=0x6300000 size=0
[   31.704857] ISP IOCTL: cmd=0x40045626 arg=0x7f9d3c90
[   31.704872] subdev_sensor_ops_ioctl: cmd=0x2000003
[   31.704877] subdev_sensor_ops_ioctl: IOCTL 0x2000003 - Get sensor input
[   31.704884] subdev_sensor_ops_ioctl: Auto-selected first sensor at slot 2 as index 0
[   31.704890] subdev_sensor_ops_ioctl: Returning current sensor index 0
[   31.704899] ISP IOCTL: cmd=0x80045612 arg=0x0
[   31.704906] *** tx_isp_video_s_stream: EXACT Binary Ninja reference implementation - enable=1 ***
[   31.704911] === ISP Subdevice Array Status ===
[   31.704919]   [0]: isp-w01 (sd=85217800)
[   31.704926]   [1]: isp-w01 (sd=85217800)
[   31.704932]   [2]: isp-w02 (sd=846be000)
[   31.704938]   [3]: isp-m0 (sd=846be400)
[   31.704945]   [4]: gc2053 (sd=85f69400)
[   31.704951]   [5]: gc2053 (sd=85f69400)
[   31.704956]   [6]: (empty)
[   31.704962]   [7]: (empty)
[   31.704966]   [8]: (empty)
[   31.704971]   [9]: (empty)
[   31.704976]   [10]: (empty)
[   31.704981]   [11]: (empty)
[   31.704986]   [12]: (empty)
[   31.704991]   [13]: (empty)
[   31.704996]   [14]: (empty)
[   31.705001]   [15]: (empty)
[   31.705006] === End Subdevice Array ===
[   31.705011] *** tx_isp_video_s_stream: STREAM ON - Initializing core first ***
[   31.705016] *** tx_isp_video_s_stream: VIC state is 1, calling activate_module ***
[   31.705022] *** ispcore_activate_module: Fixed for our struct layouts ***
[   31.705028] *** VIC device in state 1, proceeding with activation ***
[   31.705034] *** CLOCK CONFIGURATION SECTION: clk_array=  (null), clk_count=2 ***
[   31.705039] *** SUBDEVICE VALIDATION SECTION ***
[   31.705044] VIC device state set to 2 (activated)
[   31.705049] *** CRITICAL FUNCTION POINTER CALL SECTION ***
[   31.705054] *** CALLING CRITICAL VIC INITIALIZATION FUNCTION ***
[   31.705060] *** VIC control register written with 0x4000000 to ISP+0x9a00 ***
[   31.705064] *** SUBDEVICE INITIALIZATION LOOP ***
[   31.705070] *** SUBDEVICE INITIALIZATION: Traversing backwards to initialize sensors first ***
[   31.705076] Calling subdev 5 initialization (REVERSE ORDER - sensors first)
[   31.705084] *** SENSOR_INIT: gc2053 enable=1 ***
[   31.705092] SENSOR_INIT: Configuring gc2053 (chip_id=0x2053, 1920x1080)
[   31.705098] *** CALLING SENSOR_WRITE_ARRAY WITH c06e1e20 (should be 137 registers) ***
[   31.705108] sensor_write: reg=0xfe val=0x80, client=854ccb00, adapter=i2c0, addr=0x37
[   31.705429] sensor_write: reg=0xfe val=0x80 SUCCESS
[   31.705437] sensor_write_array: reg[1] 0xfe=0x80 OK
[   31.705445] sensor_write: reg=0xfe val=0x80, client=854ccb00, adapter=i2c0, addr=0x37
[   31.705765] sensor_write: reg=0xfe val=0x80 SUCCESS
[   31.705772] sensor_write_array: reg[2] 0xfe=0x80 OK
[   31.705780] sensor_write: reg=0xfe val=0x80, client=854ccb00, adapter=i2c0, addr=0x37
[   31.711694] sensor_write: reg=0xfe val=0x80 SUCCESS
[   31.711707] sensor_write_array: reg[3] 0xfe=0x80 OK
[   31.711717] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.712034] sensor_write: reg=0xfe val=0x00 SUCCESS
[   31.712041] sensor_write_array: reg[4] 0xfe=0x00 OK
[   31.712049] sensor_write: reg=0xf2 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.712383] sensor_write: reg=0xf2 val=0x00 SUCCESS
[   31.712390] sensor_write_array: reg[5] 0xf2=0x00 OK
[   31.712399] sensor_write: reg=0xf3 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.712714] sensor_write: reg=0xf3 val=0x00 SUCCESS
[   31.712721] sensor_write_array: reg[6] 0xf3=0x00 OK
[   31.712730] sensor_write: reg=0xf4 val=0x36, client=854ccb00, adapter=i2c0, addr=0x37
[   31.713041] sensor_write: reg=0xf4 val=0x36 SUCCESS
[   31.713048] sensor_write_array: reg[7] 0xf4=0x36 OK
[   31.713056] sensor_write: reg=0xf5 val=0xc0, client=854ccb00, adapter=i2c0, addr=0x37
[   31.713370] sensor_write: reg=0xf5 val=0xc0 SUCCESS
[   31.713376] sensor_write_array: reg[8] 0xf5=0xc0 OK
[   31.713385] sensor_write: reg=0xf6 val=0x44, client=854ccb00, adapter=i2c0, addr=0x37
[   31.713698] sensor_write: reg=0xf6 val=0x44 SUCCESS
[   31.713705] sensor_write_array: reg[9] 0xf6=0x44 OK
[   31.713713] sensor_write: reg=0xf7 val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.714026] sensor_write: reg=0xf7 val=0x01 SUCCESS
[   31.714033] sensor_write_array: reg[10] 0xf7=0x01 OK
[   31.714041] sensor_write: reg=0xf8 val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.714354] sensor_write: reg=0xf8 val=0x68 SUCCESS
[   31.714362] sensor_write: reg=0xf9 val=0x40, client=854ccb00, adapter=i2c0, addr=0x37
[   31.714676] sensor_write: reg=0xf9 val=0x40 SUCCESS
[   31.714684] sensor_write: reg=0xfc val=0x8e, client=854ccb00, adapter=i2c0, addr=0x37
[   31.715051] sensor_write: reg=0xfc val=0x8e SUCCESS
[   31.715061] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.715376] sensor_write: reg=0xfe val=0x00 SUCCESS
[   31.715385] sensor_write: reg=0x87 val=0x18, client=854ccb00, adapter=i2c0, addr=0x37
[   31.715698] sensor_write: reg=0x87 val=0x18 SUCCESS
[   31.715707] sensor_write: reg=0xee val=0x30, client=854ccb00, adapter=i2c0, addr=0x37
[   31.718236] sensor_write: reg=0xee val=0x30 SUCCESS
[   31.718252] sensor_write: reg=0xd0 val=0xb7, client=854ccb00, adapter=i2c0, addr=0x37
[   31.718570] sensor_write: reg=0xd0 val=0xb7 SUCCESS
[   31.718579] sensor_write: reg=0x03 val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.718895] sensor_write: reg=0x03 val=0x04 SUCCESS
[   31.718904] sensor_write: reg=0x04 val=0x60, client=854ccb00, adapter=i2c0, addr=0x37
[   31.719217] sensor_write: reg=0x04 val=0x60 SUCCESS
[   31.719226] sensor_write: reg=0x05 val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.719538] sensor_write: reg=0x05 val=0x04 SUCCESS
[   31.719547] sensor_write: reg=0x06 val=0x4c, client=854ccb00, adapter=i2c0, addr=0x37
[   31.719860] sensor_write: reg=0x06 val=0x4c SUCCESS
[   31.719868] sensor_write: reg=0x07 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.720414] sensor_write: reg=0x07 val=0x00 SUCCESS
[   31.720424] sensor_write: reg=0x08 val=0x11, client=854ccb00, adapter=i2c0, addr=0x37
[   31.720738] sensor_write: reg=0x08 val=0x11 SUCCESS
[   31.720746] sensor_write: reg=0x09 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.725041] sensor_write: reg=0x09 val=0x00 SUCCESS
[   31.725056] sensor_write: reg=0x0a val=0x02, client=854ccb00, adapter=i2c0, addr=0x37
[   31.725374] sensor_write: reg=0x0a val=0x02 SUCCESS
[   31.725383] sensor_write: reg=0x0b val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.725701] sensor_write: reg=0x0b val=0x00 SUCCESS
[   31.725710] sensor_write: reg=0x0c val=0x02, client=854ccb00, adapter=i2c0, addr=0x37
[   31.726024] sensor_write: reg=0x0c val=0x02 SUCCESS
[   31.726032] sensor_write: reg=0x0d val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.726345] sensor_write: reg=0x0d val=0x04 SUCCESS
[   31.726353] sensor_write: reg=0x0e val=0x40, client=854ccb00, adapter=i2c0, addr=0x37
[   31.726666] sensor_write: reg=0x0e val=0x40 SUCCESS
[   31.726675] sensor_write: reg=0x12 val=0xe2, client=854ccb00, adapter=i2c0, addr=0x37
[   31.726988] sensor_write: reg=0x12 val=0xe2 SUCCESS
[   31.726996] sensor_write: reg=0x13 val=0x16, client=854ccb00, adapter=i2c0, addr=0x37
[   31.727309] sensor_write: reg=0x13 val=0x16 SUCCESS
[   31.727318] sensor_write: reg=0x19 val=0x0a, client=854ccb00, adapter=i2c0, addr=0x37
[   31.727630] sensor_write: reg=0x19 val=0x0a SUCCESS
[   31.727638] sensor_write: reg=0x21 val=0x1c, client=854ccb00, adapter=i2c0, addr=0x37
[   31.727952] sensor_write: reg=0x21 val=0x1c SUCCESS
[   31.727960] sensor_write: reg=0x28 val=0x0a, client=854ccb00, adapter=i2c0, addr=0x37
[   31.728273] sensor_write: reg=0x28 val=0x0a SUCCESS
[   31.728281] sensor_write: reg=0x29 val=0x24, client=854ccb00, adapter=i2c0, addr=0x37
[   31.735152] sensor_write: reg=0x29 val=0x24 SUCCESS
[   31.735168] sensor_write: reg=0x2b val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.735486] sensor_write: reg=0x2b val=0x04 SUCCESS
[   31.735495] sensor_write: reg=0x32 val=0xf8, client=854ccb00, adapter=i2c0, addr=0x37
[   31.735812] sensor_write: reg=0x32 val=0xf8 SUCCESS
[   31.735821] sensor_write: reg=0x37 val=0x03, client=854ccb00, adapter=i2c0, addr=0x37
[   31.736134] sensor_write: reg=0x37 val=0x03 SUCCESS
[   31.736143] sensor_write: reg=0x39 val=0x15, client=854ccb00, adapter=i2c0, addr=0x37
[   31.736456] sensor_write: reg=0x39 val=0x15 SUCCESS
[   31.736464] sensor_write: reg=0x43 val=0x07, client=854ccb00, adapter=i2c0, addr=0x37
[   31.736778] sensor_write: reg=0x43 val=0x07 SUCCESS
[   31.736786] sensor_write: reg=0x44 val=0x40, client=854ccb00, adapter=i2c0, addr=0x37
[   31.737099] sensor_write: reg=0x44 val=0x40 SUCCESS
[   31.737107] sensor_write: reg=0x46 val=0x0b, client=854ccb00, adapter=i2c0, addr=0x37
[   31.737420] sensor_write: reg=0x46 val=0x0b SUCCESS
[   31.737428] sensor_write: reg=0x4b val=0x20, client=854ccb00, adapter=i2c0, addr=0x37
[   31.737742] sensor_write: reg=0x4b val=0x20 SUCCESS
[   31.737750] sensor_write: reg=0x4e val=0x08, client=854ccb00, adapter=i2c0, addr=0x37
[   31.738062] sensor_write: reg=0x4e val=0x08 SUCCESS
[   31.738071] sensor_write: reg=0x55 val=0x20, client=854ccb00, adapter=i2c0, addr=0x37
[   31.738384] sensor_write: reg=0x55 val=0x20 SUCCESS
[   31.738392] sensor_write: reg=0x66 val=0x05, client=854ccb00, adapter=i2c0, addr=0x37
[   31.738705] sensor_write: reg=0x66 val=0x05 SUCCESS
[   31.738714] sensor_write: reg=0x67 val=0x05, client=854ccb00, adapter=i2c0, addr=0x37
[   31.739031] sensor_write: reg=0x67 val=0x05 SUCCESS
[   31.739040] sensor_write: reg=0x77 val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.739353] sensor_write: reg=0x77 val=0x01 SUCCESS
[   31.739361] sensor_write: reg=0x78 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.739674] sensor_write: reg=0x78 val=0x00 SUCCESS
[   31.739682] sensor_write: reg=0x7c val=0x93, client=854ccb00, adapter=i2c0, addr=0x37
[   31.739995] sensor_write: reg=0x7c val=0x93 SUCCESS
[   31.740002] sensor_write_array: reg[50] 0x7c=0x93 OK
[   31.740011] sensor_write: reg=0x8c val=0x12, client=854ccb00, adapter=i2c0, addr=0x37
[   31.740324] sensor_write: reg=0x8c val=0x12 SUCCESS
[   31.740332] sensor_write: reg=0x8d val=0x92, client=854ccb00, adapter=i2c0, addr=0x37
[   31.740668] sensor_write: reg=0x8d val=0x92 SUCCESS
[   31.740677] sensor_write: reg=0x90 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.740989] sensor_write: reg=0x90 val=0x00 SUCCESS
[   31.740998] sensor_write: reg=0x41 val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.741312] sensor_write: reg=0x41 val=0x04 SUCCESS
[   31.741320] sensor_write: reg=0x42 val=0x9d, client=854ccb00, adapter=i2c0, addr=0x37
[   31.741632] sensor_write: reg=0x42 val=0x9d SUCCESS
[   31.741640] sensor_write: reg=0x9d val=0x10, client=854ccb00, adapter=i2c0, addr=0x37
[   31.745420] sensor_write: reg=0x9d val=0x10 SUCCESS
[   31.745435] sensor_write: reg=0xce val=0x7c, client=854ccb00, adapter=i2c0, addr=0x37
[   31.745750] sensor_write: reg=0xce val=0x7c SUCCESS
[   31.745758] sensor_write: reg=0xd2 val=0x41, client=854ccb00, adapter=i2c0, addr=0x37
[   31.746077] sensor_write: reg=0xd2 val=0x41 SUCCESS
[   31.746086] sensor_write: reg=0xd3 val=0xdc, client=854ccb00, adapter=i2c0, addr=0x37
[   31.746397] sensor_write: reg=0xd3 val=0xdc SUCCESS
[   31.746406] sensor_write: reg=0xe6 val=0x50, client=854ccb00, adapter=i2c0, addr=0x37
[   31.746719] sensor_write: reg=0xe6 val=0x50 SUCCESS
[   31.746728] sensor_write: reg=0xb6 val=0xc0, client=854ccb00, adapter=i2c0, addr=0x37
[   31.747040] sensor_write: reg=0xb6 val=0xc0 SUCCESS
[   31.747049] sensor_write: reg=0xb0 val=0x70, client=854ccb00, adapter=i2c0, addr=0x37
[   31.747362] sensor_write: reg=0xb0 val=0x70 SUCCESS
[   31.747370] sensor_write: reg=0xb1 val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.747684] sensor_write: reg=0xb1 val=0x01 SUCCESS
[   31.747692] sensor_write: reg=0xb2 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.748004] sensor_write: reg=0xb2 val=0x00 SUCCESS
[   31.748013] sensor_write: reg=0xb3 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.755382] sensor_write: reg=0xb3 val=0x00 SUCCESS
[   31.755398] sensor_write: reg=0xb4 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.755717] sensor_write: reg=0xb4 val=0x00 SUCCESS
[   31.755726] sensor_write: reg=0xb8 val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.756043] sensor_write: reg=0xb8 val=0x01 SUCCESS
[   31.756052] sensor_write: reg=0xb9 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.756366] sensor_write: reg=0xb9 val=0x00 SUCCESS
[   31.756374] sensor_write: reg=0x26 val=0x30, client=854ccb00, adapter=i2c0, addr=0x37
[   31.756688] sensor_write: reg=0x26 val=0x30 SUCCESS
[   31.756696] sensor_write: reg=0xfe val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.757009] sensor_write: reg=0xfe val=0x01 SUCCESS
[   31.757018] sensor_write: reg=0x40 val=0x23, client=854ccb00, adapter=i2c0, addr=0x37
[   31.757330] sensor_write: reg=0x40 val=0x23 SUCCESS
[   31.757339] sensor_write: reg=0x55 val=0x07, client=854ccb00, adapter=i2c0, addr=0x37
[   31.757652] sensor_write: reg=0x55 val=0x07 SUCCESS
[   31.757660] sensor_write: reg=0x60 val=0x40, client=854ccb00, adapter=i2c0, addr=0x37
[   31.757973] sensor_write: reg=0x60 val=0x40 SUCCESS
[   31.757982] sensor_write: reg=0xfe val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.758294] sensor_write: reg=0xfe val=0x04 SUCCESS
[   31.758303] sensor_write: reg=0x14 val=0x78, client=854ccb00, adapter=i2c0, addr=0x37
[   31.758616] sensor_write: reg=0x14 val=0x78 SUCCESS
[   31.758624] sensor_write: reg=0x15 val=0x78, client=854ccb00, adapter=i2c0, addr=0x37
[   31.758937] sensor_write: reg=0x15 val=0x78 SUCCESS
[   31.758945] sensor_write: reg=0x16 val=0x78, client=854ccb00, adapter=i2c0, addr=0x37
[   31.759258] sensor_write: reg=0x16 val=0x78 SUCCESS
[   31.759266] sensor_write: reg=0x17 val=0x78, client=854ccb00, adapter=i2c0, addr=0x37
[   31.759580] sensor_write: reg=0x17 val=0x78 SUCCESS
[   31.759588] sensor_write: reg=0xfe val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.759900] sensor_write: reg=0xfe val=0x01 SUCCESS
[   31.759909] sensor_write: reg=0x92 val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.760222] sensor_write: reg=0x92 val=0x00 SUCCESS
[   31.760230] sensor_write: reg=0x94 val=0x03, client=854ccb00, adapter=i2c0, addr=0x37
[   31.760566] sensor_write: reg=0x94 val=0x03 SUCCESS
[   31.760575] sensor_write: reg=0x95 val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.760887] sensor_write: reg=0x95 val=0x04 SUCCESS
[   31.760896] sensor_write: reg=0x96 val=0x38, client=854ccb00, adapter=i2c0, addr=0x37
[   31.761207] sensor_write: reg=0x96 val=0x38 SUCCESS
[   31.761215] sensor_write: reg=0x97 val=0x07, client=854ccb00, adapter=i2c0, addr=0x37
[   31.761530] sensor_write: reg=0x97 val=0x07 SUCCESS
[   31.761538] sensor_write: reg=0x98 val=0x80, client=854ccb00, adapter=i2c0, addr=0x37
[   31.761852] sensor_write: reg=0x98 val=0x80 SUCCESS
[   31.761860] sensor_write: reg=0xfe val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.762173] sensor_write: reg=0xfe val=0x01 SUCCESS
[   31.762181] sensor_write: reg=0x01 val=0x05, client=854ccb00, adapter=i2c0, addr=0x37
[   31.764013] sensor_write: reg=0x01 val=0x05 SUCCESS
[   31.764029] sensor_write: reg=0x02 val=0x89, client=854ccb00, adapter=i2c0, addr=0x37
[   31.764346] sensor_write: reg=0x02 val=0x89 SUCCESS
[   31.764354] sensor_write: reg=0x04 val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.765637] sensor_write: reg=0x04 val=0x01 SUCCESS
[   31.765652] sensor_write: reg=0x07 val=0xa6, client=854ccb00, adapter=i2c0, addr=0x37
[   31.765966] sensor_write: reg=0x07 val=0xa6 SUCCESS
[   31.765975] sensor_write: reg=0x08 val=0xa9, client=854ccb00, adapter=i2c0, addr=0x37
[   31.766286] sensor_write: reg=0x08 val=0xa9 SUCCESS
[   31.766294] sensor_write: reg=0x09 val=0xa8, client=854ccb00, adapter=i2c0, addr=0x37
[   31.768522] sensor_write: reg=0x09 val=0xa8 SUCCESS
[   31.768538] sensor_write: reg=0x0a val=0xa7, client=854ccb00, adapter=i2c0, addr=0x37
[   31.774873] sensor_write: reg=0x0a val=0xa7 SUCCESS
[   31.774889] sensor_write: reg=0x0b val=0xff, client=854ccb00, adapter=i2c0, addr=0x37
[   31.775206] sensor_write: reg=0x0b val=0xff SUCCESS
[   31.775214] sensor_write: reg=0x0c val=0xff, client=854ccb00, adapter=i2c0, addr=0x37
[   31.775606] sensor_write: reg=0x0c val=0xff SUCCESS
[   31.775616] sensor_write: reg=0x0f val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.775932] sensor_write: reg=0x0f val=0x00 SUCCESS
[   31.775941] sensor_write: reg=0x50 val=0x1c, client=854ccb00, adapter=i2c0, addr=0x37
[   31.776255] sensor_write: reg=0x50 val=0x1c SUCCESS
[   31.776264] sensor_write: reg=0x89 val=0x03, client=854ccb00, adapter=i2c0, addr=0x37
[   31.776577] sensor_write: reg=0x89 val=0x03 SUCCESS
[   31.776585] sensor_write: reg=0xfe val=0x04, client=854ccb00, adapter=i2c0, addr=0x37
[   31.777259] sensor_write: reg=0xfe val=0x04 SUCCESS
[   31.777388] sensor_write: reg=0x28 val=0x86, client=854ccb00, adapter=i2c0, addr=0x37
[   31.782134] sensor_write: reg=0x28 val=0x86 SUCCESS
[   31.782146] sensor_write_array: reg[100] 0x28=0x86 OK
[   31.782157] sensor_write: reg=0x29 val=0x86, client=854ccb00, adapter=i2c0, addr=0x37
[   31.782476] sensor_write: reg=0x29 val=0x86 SUCCESS
[   31.782484] sensor_write: reg=0x2a val=0x86, client=854ccb00, adapter=i2c0, addr=0x37
[   31.782800] sensor_write: reg=0x2a val=0x86 SUCCESS
[   31.782809] sensor_write: reg=0x2b val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.783120] sensor_write: reg=0x2b val=0x68 SUCCESS
[   31.783129] sensor_write: reg=0x2c val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.783442] sensor_write: reg=0x2c val=0x68 SUCCESS
[   31.783450] sensor_write: reg=0x2d val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.783764] sensor_write: reg=0x2d val=0x68 SUCCESS
[   31.783772] sensor_write: reg=0x2e val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.784085] sensor_write: reg=0x2e val=0x68 SUCCESS
[   31.784093] sensor_write: reg=0x2f val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.784406] sensor_write: reg=0x2f val=0x68 SUCCESS
[   31.784414] sensor_write: reg=0x30 val=0x4f, client=854ccb00, adapter=i2c0, addr=0x37
[   31.784728] sensor_write: reg=0x30 val=0x4f SUCCESS
[   31.784736] sensor_write: reg=0x31 val=0x68, client=854ccb00, adapter=i2c0, addr=0x37
[   31.785049] sensor_write: reg=0x31 val=0x68 SUCCESS
[   31.785057] sensor_write: reg=0x32 val=0x67, client=854ccb00, adapter=i2c0, addr=0x37
[   31.785370] sensor_write: reg=0x32 val=0x67 SUCCESS
[   31.785378] sensor_write: reg=0x33 val=0x66, client=854ccb00, adapter=i2c0, addr=0x37
[   31.785752] sensor_write: reg=0x33 val=0x66 SUCCESS
[   31.785761] sensor_write: reg=0x34 val=0x66, client=854ccb00, adapter=i2c0, addr=0x37
[   31.786073] sensor_write: reg=0x34 val=0x66 SUCCESS
[   31.786081] sensor_write: reg=0x35 val=0x66, client=854ccb00, adapter=i2c0, addr=0x37
[   31.786396] sensor_write: reg=0x35 val=0x66 SUCCESS
[   31.786405] sensor_write: reg=0x36 val=0x66, client=854ccb00, adapter=i2c0, addr=0x37
[   31.790422] sensor_write: reg=0x36 val=0x66 SUCCESS
[   31.790437] sensor_write: reg=0x37 val=0x66, client=854ccb00, adapter=i2c0, addr=0x37
[   31.790755] sensor_write: reg=0x37 val=0x66 SUCCESS
[   31.790764] sensor_write: reg=0x38 val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.791082] sensor_write: reg=0x38 val=0x62 SUCCESS
[   31.791091] sensor_write: reg=0x39 val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.791414] sensor_write: reg=0x39 val=0x62 SUCCESS
[   31.791423] sensor_write: reg=0x3a val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.791737] sensor_write: reg=0x3a val=0x62 SUCCESS
[   31.791746] sensor_write: reg=0x3b val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.792058] sensor_write: reg=0x3b val=0x62 SUCCESS
[   31.792066] sensor_write: reg=0x3c val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.792380] sensor_write: reg=0x3c val=0x62 SUCCESS
[   31.792388] sensor_write: reg=0x3d val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.792701] sensor_write: reg=0x3d val=0x62 SUCCESS
[   31.792710] sensor_write: reg=0x3e val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.793023] sensor_write: reg=0x3e val=0x62 SUCCESS
[   31.793032] sensor_write: reg=0x3f val=0x62, client=854ccb00, adapter=i2c0, addr=0x37
[   31.793344] sensor_write: reg=0x3f val=0x62 SUCCESS
[   31.793353] sensor_write: reg=0xfe val=0x01, client=854ccb00, adapter=i2c0, addr=0x37
[   31.793666] sensor_write: reg=0xfe val=0x01 SUCCESS
[   31.793674] sensor_write: reg=0x9a val=0x06, client=854ccb00, adapter=i2c0, addr=0x37
[   31.795800] sensor_write: reg=0x9a val=0x06 SUCCESS
[   31.795814] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.796130] sensor_write: reg=0xfe val=0x00 SUCCESS
[   31.796139] sensor_write: reg=0x7b val=0x2a, client=854ccb00, adapter=i2c0, addr=0x37
[   31.796456] sensor_write: reg=0x7b val=0x2a SUCCESS
[   31.796465] sensor_write: reg=0x23 val=0x2d, client=854ccb00, adapter=i2c0, addr=0x37
[   31.796785] sensor_write: reg=0x23 val=0x2d SUCCESS
[   31.796794] sensor_write: reg=0xfe val=0x03, client=854ccb00, adapter=i2c0, addr=0x37
[   31.797105] sensor_write: reg=0xfe val=0x03 SUCCESS
[   31.797113] sensor_write: reg=0x01 val=0x27, client=854ccb00, adapter=i2c0, addr=0x37
[   31.805916] sensor_write: reg=0x01 val=0x27 SUCCESS
[   31.805931] sensor_write: reg=0x02 val=0x56, client=854ccb00, adapter=i2c0, addr=0x37
[   31.806249] sensor_write: reg=0x02 val=0x56 SUCCESS
[   31.806258] sensor_write: reg=0x03 val=0x8e, client=854ccb00, adapter=i2c0, addr=0x37
[   31.806575] sensor_write: reg=0x03 val=0x8e SUCCESS
[   31.806584] sensor_write: reg=0x12 val=0x80, client=854ccb00, adapter=i2c0, addr=0x37
[   31.806898] sensor_write: reg=0x12 val=0x80 SUCCESS
[   31.806906] sensor_write: reg=0x13 val=0x07, client=854ccb00, adapter=i2c0, addr=0x37
[   31.807220] sensor_write: reg=0x13 val=0x07 SUCCESS
[   31.807228] sensor_write: reg=0x15 val=0x12, client=854ccb00, adapter=i2c0, addr=0x37
[   31.807541] sensor_write: reg=0x15 val=0x12 SUCCESS
[   31.807550] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   31.807862] sensor_write: reg=0xfe val=0x00 SUCCESS
[   31.807871] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   31.808184] sensor_write: reg=0x3e val=0x91 SUCCESS
[   31.808191] sensor_write_array: Complete - wrote 137 registers, 0 errors
[   31.808197] *** SENSOR_WRITE_ARRAY RETURNED: 0 ***
[   31.808204] *** SENSOR_INIT: gc2053 initialization complete - marked as initialized ***
[   31.808211] Calling subdev 4 initialization (REVERSE ORDER - sensors first)
[   31.808218] *** SENSOR_INIT: gc2053 enable=1 ***
[   31.808224] *** SENSOR_INIT: gc2053 already initialized, skipping to prevent CSI PHY reconfiguration ***
[   31.808230] *** SENSOR_INIT: This prevents register reset that disables ISP/VIC interrupts ***
[   31.808236] Calling subdev 2 initialization (REVERSE ORDER - sensors first)
[   31.808244] *** vic_core_ops_init: ENTRY - sd=846be000, enable=1 ***
[   31.808250] *** vic_core_ops_init: vic_dev=846be000, current state check ***
[   31.808256] *** vic_core_ops_init: current_state=2, enable=1 ***
[   31.808262] *** vic_core_ops_init: Calling VIC hardware init for interrupt setup ***
[   31.808268] *** VIC HW INIT: Using PRIMARY VIC space for interrupt configuration ***
[   31.808273] *** VIC HW INIT: Configuring ACTUAL VIC interrupt registers (0x1e0-0x1f4 range) ***
[   31.808279] *** VIC HW INIT: Basic interrupt clearing complete - full interrupt config happens later ***
[   31.808285] *** VIC HW INIT: Interrupt handler registration SKIPPED - main module handles IRQ 38 routing ***
[   31.808292] *** VIC HW INIT VERIFY: 0x00=0x00000000 (should be 0), 0x20=0x00000000 (should be 0) ***
[   31.808298] *** VIC HW INIT: SUCCESS - Basic VIC hardware initialization complete ***
[   31.808304] *** VIC HW INIT: Hardware interrupt configuration complete - ready for main module IRQ routing ***
[   31.808310] *** vic_core_ops_init: VIC hardware init SUCCESS - interrupts should now work ***
[   31.808316] *** tx_vic_enable_irq: EXACT Binary Ninja implementation from working reference ***
[   31.808321] tx_vic_enable_irq: VIC interrupts enabled (irq_enabled = 1)
[   31.808328] *** tx_vic_enable_irq: CRITICAL FIX - Enabling VIC interrupt (IRQ 38) at kernel level ***
[   31.808335] *** tx_vic_enable_irq: VIC interrupt (IRQ 38) ENABLED at kernel level ***
[   31.808341] tx_vic_enable_irq: VIC interrupt flag set and kernel interrupt enabled
[   31.808346] *** tx_vic_enable_irq: completed successfully ***
[   31.808352] Calling subdev 1 initialization (REVERSE ORDER - sensors first)
[   31.808359] VIN: tx_isp_vin_init: EXACT Binary Ninja implementation with safety checks = 0x1
[   31.808365] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   31.808373] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   31.808380] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   31.808386] VIN: tx_isp_vin_init: a0 (sensor) = 85f69400
[   31.808392] VIN: tx_isp_vin_init: using VIN device from global ISP: 85217800
[   31.808398] VIN: tx_isp_vin_init: calling sensor init function = 0x1
[   31.808404] *** SENSOR_INIT: gc2053 enable=1 ***
[   31.808410] *** SENSOR_INIT: gc2053 already initialized, skipping to prevent CSI PHY reconfiguration ***
[   31.808416] *** SENSOR_INIT: This prevents register reset that disables ISP/VIC interrupts ***
[   31.808422] VIN: tx_isp_vin_init: sensor init returned = 0x0
[   31.808428] VIN: tx_isp_vin_init: *** VIN STATE SET SAFELY *** = 0x3
[   31.808434] VIN: tx_isp_vin_init: EXACT Binary Ninja result = 0x0
[   31.808439] Calling subdev 0 initialization (REVERSE ORDER - sensors first)
[   31.808445] VIN: tx_isp_vin_init: EXACT Binary Ninja implementation with safety checks = 0x1
[   31.808450] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   31.808458] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   31.808464] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   31.808470] VIN: tx_isp_vin_init: a0 (sensor) = 85f69400
[   31.808476] VIN: tx_isp_vin_init: using VIN device from global ISP: 85217800
[   31.808482] VIN: tx_isp_vin_init: calling sensor init function = 0x1
[   31.808488] *** SENSOR_INIT: gc2053 enable=1 ***
[   31.808494] *** SENSOR_INIT: gc2053 already initialized, skipping to prevent CSI PHY reconfiguration ***
[   31.808500] *** SENSOR_INIT: This prevents register reset that disables ISP/VIC interrupts ***
[   31.808506] VIN: tx_isp_vin_init: sensor init returned = 0x0
[   31.808511] VIN: tx_isp_vin_init: *** VIN STATE SET SAFELY *** = 0x3
[   31.808517] VIN: tx_isp_vin_init: EXACT Binary Ninja result = 0x0
[   31.808522] *** VIC device final state set to 2 (fully activated) ***
[   31.808528] *** ispcore_activate_module: SUCCESS - ALL REGISTER WRITES SHOULD NOW BE TRIGGERED ***
[   31.808534] *** tx_isp_video_s_stream: ispcore_activate_module completed ***
[   31.808539] *** tx_isp_video_s_stream: VIC state is 2, calling VIC core->init ***
[   31.808546] *** vic_core_ops_init: ENTRY - sd=846be000, enable=1 ***
[   31.808552] *** vic_core_ops_init: vic_dev=846be000, current state check ***
[   31.808558] *** vic_core_ops_init: current_state=2, enable=1 ***
[   31.808563] *** vic_core_ops_init: Calling VIC hardware init for interrupt setup ***
[   31.808568] *** VIC HW INIT: Using PRIMARY VIC space for interrupt configuration ***
[   31.808574] *** VIC HW INIT: Configuring ACTUAL VIC interrupt registers (0x1e0-0x1f4 range) ***
[   31.808580] *** VIC HW INIT: Basic interrupt clearing complete - full interrupt config happens later ***
[   31.808586] *** VIC HW INIT: Interrupt handler registration SKIPPED - main module handles IRQ 38 routing ***
[   31.808593] *** VIC HW INIT VERIFY: 0x00=0x00000000 (should be 0), 0x20=0x00000000 (should be 0) ***
[   31.808598] *** VIC HW INIT: SUCCESS - Basic VIC hardware initialization complete ***
[   31.808604] *** VIC HW INIT: Hardware interrupt configuration complete - ready for main module IRQ routing ***
[   31.808610] *** vic_core_ops_init: VIC hardware init SUCCESS - interrupts should now work ***
[   31.808616] *** tx_vic_enable_irq: EXACT Binary Ninja implementation from working reference ***
[   31.808621] tx_vic_enable_irq: VIC interrupts enabled (irq_enabled = 1)
[   31.808627] *** tx_vic_enable_irq: CRITICAL FIX - Enabling VIC interrupt (IRQ 38) at kernel level ***
[   31.808634] *** tx_vic_enable_irq: VIC interrupt (IRQ 38) ENABLED at kernel level ***
[   31.808639] tx_vic_enable_irq: VIC interrupt flag set and kernel interrupt enabled
[   31.808644] *** tx_vic_enable_irq: completed successfully ***
[   31.808650] *** tx_isp_video_s_stream: VIC core->init completed, VIC should now be state 3 ***
[   31.808656] *** tx_isp_video_s_stream: Core initialization complete, proceeding with subdev streaming ***
[   31.808662] *** tx_isp_video_s_stream: CRITICAL FIX - Initializing all subdevs before streaming ***
[   31.808670] *** tx_isp_video_s_stream: Activating CSI subdev (state 1 -> 2) before CSI init ***
[   31.808677] tx_isp_csi_activate_subdev: Initializing 2 clocks for CSI before enabling
[   31.808684] isp_subdev_init_clks: EXACT Binary Ninja MCP - Initializing 2 clocks
[   31.808690] isp_subdev_init_clks: Using platform data clock arrays: c06b7558
[   31.808698] isp_subdev_init_clks: Using platform data clock configs
[   31.808705] Platform data clock[0]: name=cgu_isp, rate=100000000
[   31.808716] Clock cgu_isp: set rate 100000000 Hz, result=0
[   31.808724] Clock cgu_isp enabled successfully
[   31.808730] Platform data clock[1]: name=isp, rate=65535
[   31.808738] Clock isp enabled successfully
[   31.830432] CPM clock gates configured
[   31.830447] isp_subdev_init_clks: Successfully initialized 2 clocks
[   31.830456] *** tx_isp_video_s_stream: CSI subdev activation done, state=2 ***
[   31.830462] *** tx_isp_video_s_stream: Initializing CSI subdev ***
[   31.830468] VIN: tx_isp_vin_init: EXACT Binary Ninja implementation with safety checks = 0x1
[   31.830475] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   31.830486] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   31.830492] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   31.830499] VIN: tx_isp_vin_init: a0 (sensor) = 85f69400
[   31.830505] VIN: tx_isp_vin_init: using VIN device from global ISP: 85217800
[   31.830512] VIN: tx_isp_vin_init: calling sensor init function = 0x1
[   31.830519] *** SENSOR_INIT: gc2053 enable=1 ***
[   31.830526] *** SENSOR_INIT: gc2053 already initialized, skipping to prevent CSI PHY reconfiguration ***
[   31.830532] *** SENSOR_INIT: This prevents register reset that disables ISP/VIC interrupts ***
[   31.830538] VIN: tx_isp_vin_init: sensor init returned = 0x0
[   31.830544] VIN: tx_isp_vin_init: *** VIN STATE SET SAFELY *** = 0x3
[   31.830549] VIN: tx_isp_vin_init: EXACT Binary Ninja result = 0x0
[   31.830554] *** tx_isp_video_s_stream: CSI init SUCCESS ***
[   31.830560] *** tx_isp_video_s_stream: Initializing VIC subdev ***
[   31.830567] *** vic_core_ops_init: ENTRY - sd=846be000, enable=1 ***
[   31.830573] *** vic_core_ops_init: vic_dev=846be000, current state check ***
[   31.830580] *** vic_core_ops_init: current_state=3, enable=1 ***
[   31.830585] *** tx_isp_video_s_stream: VIC init SUCCESS ***
[   31.830590] *** tx_isp_video_s_stream: Initializing Sensor subdev ***
[   31.830596] *** SENSOR_INIT: gc2053 enable=1 ***
[   31.830603] *** SENSOR_INIT: gc2053 already initialized, skipping to prevent CSI PHY reconfiguration ***
[   31.830609] *** SENSOR_INIT: This prevents register reset that disables ISP/VIC interrupts ***
[   31.830614] *** tx_isp_video_s_stream: Sensor init SUCCESS ***
[   31.830620] *** tx_isp_video_s_stream: All subdev initialization complete - proceeding with s_stream ***
[   31.830627] *** tx_isp_video_s_stream: Calling subdev[0]->ops->video->s_stream(1) ***
[   31.830634] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   31.830640] vin_s_stream: VIN state = 3, enable = 1
[   31.830646] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   31.830652] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   31.830659] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   31.830664] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   31.830670] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   31.830676] *** tx_isp_video_s_stream: subdev[0] s_stream SUCCESS ***
[   31.830683] *** tx_isp_video_s_stream: Calling subdev[1]->ops->video->s_stream(1) ***
[   31.830690] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   31.830696] vin_s_stream: VIN state = 4, enable = 1
[   31.830700] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   31.830708] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   31.830714] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   31.830720] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   31.830726] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   31.830731] *** tx_isp_video_s_stream: subdev[1] s_stream SUCCESS ***
[   31.830738] *** tx_isp_video_s_stream: Calling subdev[2]->ops->video->s_stream(1) ***
[   31.830745] *** vic_core_s_stream: BINARY NINJA EXACT - sd=846be000, enable=1 ***
[   31.830751] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=3 ***
[   31.830756] *** vic_core_s_stream: STREAM ON ***
[   31.830762] *** vic_core_s_stream: EXACT Binary Ninja - State != 4, calling VIC start sequence ***
[   31.830768] *** vic_core_s_stream: SKIPPING tx_vic_disable_irq before VIC start to preserve first frame IRQ ***
[   31.830774] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   31.830781] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   31.830787] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   31.830793] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   31.830799] *** STREAMING: Configuring CPM registers for VIC access ***
[   31.860432] STREAMING: CPM clocks configured for VIC access
[   31.860448] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   31.860454] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   31.860461] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   31.860467] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   31.860473] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   31.860479] *** tx_isp_vic_start: Adding CRITICAL missing VIC configuration registers ***
[   31.860488] *** tx_isp_vic_start: CRITICAL VIC configuration registers written - hardware protection should be prevented ***
[   31.860494] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   31.860502] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   31.860508] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   31.860513] *** VIC unlock: Commands written, checking VIC status register ***
[   31.860520] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   31.860526] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   31.860532] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   31.860537] *** tx_isp_vic_start: CRITICAL FIX - Writing VIC Control register sequence ***
[   31.860543] *** tx_isp_vic_start: VIC processing enabled (0x0=0x1, 0x4=0x1) ***
[   31.860548] *** tx_isp_vic_start: Configuring VIC hardware prerequisites for interrupt registers ***
[   31.860632] read_sensor_dimensions: Successfully read 1920x1080 from /proc/jz/sensor/
[   31.860639] *** VIC DIMENSIONS: Using /proc/jz/sensor/ dimensions 1920x1080 (RELIABLE) ***
[   31.860646] *** VIC REGISTER CONFIG: Writing VIC configuration registers (vic_start_ok=0) ***
[   31.860654] *** VIC REGISTER CONFIG: VIC configuration registers written (0xc=2, 0x10=0x07800438, 0x14=3840) ***
[   31.860661] *** VIC HARDWARE PREREQUISITES: Dimensions 1920x1080, stride 3840, MIPI mode 2 ***
[   31.860668] *** VIC INTERRUPT CONFIG: VIC unlock sequence will be completed first, then interrupt config ***
[   31.860675] *** VIC INTERRUPT STATUS CHECK (BEFORE UNLOCK): STATUS=0x00000000, MASK_STATUS=0x00000000 ***
[   31.860681] *** VIC INTERRUPT CONFIG: Using WORKING BRANCH registers (NOT Binary Ninja) ***
[   31.860687] *** VIC INTERRUPT CONFIG: Configuring interrupt masks (WORKING BRANCH) ***
[   31.860693] *** VIC INTERRUPT CONFIG: Configuring ISP control interrupts (WORKING BRANCH) ***
[   31.860699] *** VIC INTERRUPT CONFIG: Applying VIC interrupt system configuration (WORKING BRANCH) ***
[   31.860706] *** VIC PRIMARY: leaving 0x14=stride as-is (readback=0x00000000) ***
[   31.860711] *** VIC INTERRUPT CONFIG: WORKING BRANCH interrupt configuration complete ***
[   31.860717] *** VIC INTERRUPT CONFIG: Mirroring WORKING BRANCH registers to control bank ***
[   31.860724] *** VIC CONTROL VERIFY: 0x0c(IMCR)=0x00000000 (expect 0xb5742249) ***
[   31.860730] *** VIC INTERRUPT CONFIG: Control bank configuration complete ***
[   31.860735] *** ISP CORE INTERRUPT CONFIG: Enabling ISP core interrupt generation (MISSING FROM CURRENT BRANCH) ***
[   31.860742] *** ISP CORE CONFIG: Writing ISP core interrupt registers at VIC start ***
[   31.860748] *** ISP CORE CONFIG: ISP core interrupt registers written (0x30=0xffffffff, 0x10=0x133) ***
[   31.860754] *** ISP CORE: Hardware interrupt generation ENABLED (0x30=0xffffffff, 0x10=0x133) ***
[   31.860760] *** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***
[   31.860767] *** ISP CORE VERIFY: 0x30=0x8fffffff, 0x10=0x00000000 ***
[   31.860772] *** VIC INTERRUPT CONFIG: Starting verification of WORKING BRANCH interrupt registers ***
[   31.860782] *** VIC INTERRUPT CONTROL VERIFY (WORKING BRANCH REGS): 0x04=0x07800438, 0x0c=0x00000001, 0x100=0x000002d0, 0x14=0x00000000 ***
[   31.860788] *** VIC INTERRUPT: Some WORKING BRANCH interrupt register configuration failed ***
[   31.860794] *** VIC INTERRUPT: Expected: 0x04=0x07800438, 0x0c=0xb5742249, 0x100=0x2d0, 0x14=0x2b ***
[   31.860802] *** VIC INTERRUPT: imr_ok=1, imcr_ok=0, config_ok=1, control_ok=0 ***
[   31.860808] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   31.860814] *** tx_isp_vic_start: VIC Control register sequence complete - streaming should start ***
[   31.860820] *** tx_isp_vic_start: VIC should now generate frame done interrupts! ***
[   31.860826] *** tx_isp_vic_start: VIC interrupt will be enabled by tx_vic_enable_irq callback ***
[   31.860832] *** vic_core_s_stream: Forcing ispvic_frame_channel_qbuf to program buffer addresses before MDMA ***
[   31.860838] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   31.860846] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   31.860852] *** vic_core_s_stream: ispvic_frame_channel_qbuf SUCCESS ***
[   31.860858] *** vic_core_s_stream: Calling ispvic_frame_channel_s_stream(ENABLE) to start MDMA before enabling IRQ ***
[   31.860864] *** ispvic_frame_channel_s_stream: EXACT Binary Ninja implementation ***
[   31.860871] ispvic_frame_channel_s_stream: arg1=846be000, arg2=1
[   31.860877] ispvic_frame_channel_s_stream: s0 (vic_dev) = 846be000
[   31.860884] ispvic_frame_channel_s_stream[2441]: streamon
[   31.860890] *** ispvic_frame_channel_s_stream: Checking stream state - current=0, requested=1 ***
[   31.860896] *** ispvic_frame_channel_s_stream: Stream state different - proceeding with streaming setup ***
[   31.860902] *** VIC CONTROL (PRIMARY): WROTE 2 to [0x0] before MDMA/config ***
[   31.860908] *** CRITICAL: Calling vic_pipo_mdma_enable - required for VIC interrupts ***
[   31.860914] *** vic_pipo_mdma_enable: EXACT Binary Ninja MCP implementation ***
[   31.860921] vic_pipo_mdma_enable: Using cached sensor dimensions 1920x1080 (ATOMIC CONTEXT SAFE)
[   31.860926] vic_pipo_mdma_enable: reg 0x308 = 1 (MDMA enable)
[   31.860934] vic_pipo_mdma_enable: reg 0x304 = 0x7800438 (dimensions 1920x1080)
[   31.860940] vic_pipo_mdma_enable: reg 0x310 = 3840 (stride)
[   31.860946] vic_pipo_mdma_enable: reg 0x314 = 3840 (stride)
[   31.860951] *** CRITICAL FIX: Writing buffer addresses to VIC hardware registers ***
[   31.860957] *** CRITICAL: No VBM buffer addresses - using fallback addresses from reserved memory ***
[   31.860964] *** vbm_buffer_addresses=  (null), vbm_buffer_count=0 ***
[   31.860971] *** VIC FALLBACK BUFFER 0: Wrote reserved memory address 0x6300000 to reg 0x318 ***
[   31.860979] *** VIC FALLBACK BUFFER 1: Wrote reserved memory address 0x66f4800 to reg 0x31c ***
[   31.860986] *** VIC FALLBACK BUFFER 2: Wrote reserved memory address 0x6ae9000 to reg 0x320 ***
[   31.860994] *** VIC FALLBACK BUFFER 3: Wrote reserved memory address 0x6edd800 to reg 0x324 ***
[   31.861002] *** VIC FALLBACK BUFFER 4: Wrote reserved memory address 0x72d2000 to reg 0x328 ***
[   31.861008] *** CRITICAL: VIC fallback buffer addresses configured - hardware can now generate interrupts! ***
[   31.861014] *** VIC PIPO MDMA ENABLE COMPLETE - VIC should now generate interrupts! ***
[   31.861019] *** vic_pipo_mdma_enable completed - VIC MDMA should now generate interrupts! ***
[   31.861026] *** Binary Ninja EXACT: Wrote 0x80040020 to reg 0x300 (4 buffers) ***
[   31.861032] *** vic_core_s_stream: CORE W1C [9a70/9a7c] then GATE REASSERT [9ac0/9ac8] ***
[   31.861038] *** vic_core_s_stream: Re-writing buffer addresses AFTER MDMA start ***
[   31.861044] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   31.861050] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   31.861056] *** vic_core_s_stream: Post-MDMA QBUF SUCCESS ***
[   31.861068] *** VIC VERIFY (PRIMARY): [0x0]=0x00000000 [0x4]=0x07800438 [0x300]=0x80040020 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 (UNMASK-ALL)***
[   31.861077] *** VIC VERIFY (PRIMARY EXTRA): [0x100]=0x000002d0 [0x14]=0x00000000 (PRIMARY 0x14=stride) ***
[   31.861141] *** VIC VERIFY (CONTROL): [0x0]=0x00000000 [0x4]=0x00000000 [0x100]=0x00000000 [0x14]=0x00000000 [0x300]=0x00000000 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 ***
[   31.861153] *** VIC BUFS (PRIMARY): [0x318]=0x06300000 [0x31c]=0x066f4800 [0x320]=0x06ae9000 [0x324]=0x06edd800 [0x328]=0x072d2000 ***
[   31.861160] *** VIC CTRL (PRIMARY): [0x300]=0x80040020 ***
[   31.861168] *** VIC BUFS (CONTROL): [0x318]=0x00000000 [0x31c]=0x00000000 [0x320]=0x00000000 [0x324]=0x00000000 [0x328]=0x00000000 ***
[   31.861175] *** VIC CTRL (CONTROL): [0x300]=0x00000000 ***
[   31.861180] *** VIC CONTROL BANK: Re-applying enable sequence on CONTROL bank ***
[   31.861186] *** VIC CONTROL BANK: Post-enable [0x0]=0x00000000 ***
[   31.861194] *** VIC UNMASK-ALL TEST: [0x1e8]=0x00000000 [0x1ec]=0x00000000 (expect 0) ***
[   31.862202] *** VIC UNMASK-ALL TEST: No status bits asserted during pre-IRQ sample ***
[   31.862208] *** VIC MASK: Keeping UNMASK-ALL (0x1e8=0) during debug ***
[   31.862213] *** VIC CONTROL (PRIMARY): WROTE 1 to [0x0] before enabling IRQ ***
[   31.862321] *** VIC PRIMARY ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   31.862428] *** VIC CONTROL ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   31.862436] *** CORE VIC GATE REASSERT: [0x9ac0]=0x00000000 [0x9ac8]=0x00000000 ***
[   31.862442] *** vic_core_s_stream: Enabling VIC IRQ AFTER final re-assert/verify ***
[   31.862447] *** tx_vic_enable_irq: EXACT Binary Ninja implementation from working reference ***
[   31.862453] tx_vic_enable_irq: VIC interrupts enabled (irq_enabled = 1)
[   31.862459] *** tx_vic_enable_irq: CRITICAL FIX - Enabling VIC interrupt (IRQ 38) at kernel level ***
[   31.862467] *** tx_vic_enable_irq: VIC interrupt (IRQ 38) ENABLED at kernel level ***
[   31.862472] tx_vic_enable_irq: VIC interrupt flag set and kernel interrupt enabled
[   31.862478] *** tx_vic_enable_irq: completed successfully ***
[   32.290152] *** VIC POST-IRQ SAMPLE: No status bits asserted in 200ms window ***
[   32.290165] *** vic_core_s_stream: VIC state transition 3  4 (STREAMING) ***
[   32.290171] *** VIC STATE 4: Calling ispcore_slake_module to initialize ISP core ***
[   32.290178] *** ispcore_slake_module: EXACT Binary Ninja MCP implementation ***
[   32.290185] ispcore_slake_module: VIC device=846be000, state=4ispcore_slake_module: ISP state >= 3, calling ispcore_core_ops_init
[   32.290194] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.290203] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.290210] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.290215] ispcore_slake_module: Using sensor attributes from connected sensor
[   32.290221] *** ispcore_core_ops_init_with_sensor: GOOD-THINGS approach - isp=846b8000, sensor_attr=c06e20cc ****** ispcore_core_ops_init_with_sensor: Calling tisp_init with sensor parameters (good-things approach) ***
[   32.290230] *** This will configure MIPI CSI lanes and enable proper interrupt flow ****** ispcore_core_ops_init_with_sensor: Calling tisp_init(&sensor_params, "gc2053") ***
[   32.290239] *** tisp_init: IMPLEMENTING MISSING HARDWARE REGISTER INITIALIZATION ***
[   32.290245] *** THIS FUNCTION CONTAINS ALL THE system_reg_write CALLS FROM REFERENCE ***
[   32.290252] *** tisp_init: Invalid sensor dimensions 2x0, using defaults 1920x1080 ***
[   32.290259] *** tisp_init: FIXED - Extracted dimensions from sensor_attr: 1920x1080 ***
[   32.290265] tisp_init: Initializing ISP hardware for sensor (1920x1080)
[   32.290271] *** tisp_init: Event system ready for on-demand processing (Binary Ninja reference) ***
[   32.290276] *** tisp_init: INITIALIZING ISP EVENT SYSTEM ***
[   32.290281] tisp_event_init: Initializing ISP event system
[   32.290289] tisp_event_init: SAFE event system initialized with 20 nodes
[   32.290295] tisp_event_set_cb: Setting callback for event 4
[   32.290301] tisp_event_set_cb: Event 4 callback set to c06858d4
[   32.290307] tisp_event_set_cb: Setting callback for event 5
[   32.290313] tisp_event_set_cb: Event 5 callback set to c0685d9c
[   32.290319] tisp_event_set_cb: Setting callback for event 7
[   32.290325] tisp_event_set_cb: Event 7 callback set to c0685968
[   32.290331] tisp_event_set_cb: Setting callback for event 9
[   32.290337] tisp_event_set_cb: Event 9 callback set to c06859f0
[   32.290343] tisp_event_set_cb: Setting callback for event 8
[   32.290349] tisp_event_set_cb: Event 8 callback set to c0685ab4
[   32.290356] *** system_irq_func_set: Registered handler c067e790 at index 13 ***
[   32.318274] *** WRITING ISP CORE CONTROL REGISTERS - FROM BINARY NINJA tisp_init ***
[   32.318291] *** SYSTEM_REG_WRITE: reg[0xb004] = 0xf001f001 (Binary Ninja EXACT) ***
[   32.318298] *** SYSTEM_REG_WRITE: reg[0xb008] = 0x40404040 (Binary Ninja EXACT) ***
[   32.318305] *** SYSTEM_REG_WRITE: reg[0xb00c] = 0x40404040 (Binary Ninja EXACT) ***
[   32.318311] *** SYSTEM_REG_WRITE: reg[0xb010] = 0x40404040 (Binary Ninja EXACT) ***
[   32.318319] *** SYSTEM_REG_WRITE: reg[0xb014] = 0x404040 (Binary Ninja EXACT) ***
[   32.318326] system_reg_write: BLOCKED core-control reg[0xb018]=0x40404040 during streaming (preserve interrupts)
[   32.318333] system_reg_write: BLOCKED core-control reg[0xb01c]=0x40404040 during streaming (preserve interrupts)
[   32.318341] system_reg_write: BLOCKED core-control reg[0xb020]=0x40404040 during streaming (preserve interrupts)
[   32.318348] system_reg_write: BLOCKED core-control reg[0xb024]=0x404040 during streaming (preserve interrupts)
[   32.318355] *** SYSTEM_REG_WRITE: reg[0xb028] = 0x1000080 (Binary Ninja EXACT) ***
[   32.318362] *** SYSTEM_REG_WRITE: reg[0xb02c] = 0x1000080 (Binary Ninja EXACT) ***
[   32.318369] *** SYSTEM_REG_WRITE: reg[0xb030] = 0x100 (Binary Ninja EXACT) ***
[   32.318375] *** SYSTEM_REG_WRITE: reg[0xb034] = 0xffff0100 (Binary Ninja EXACT) ***
[   32.318382] *** SYSTEM_REG_WRITE: reg[0xb038] = 0x1ff00 (Binary Ninja EXACT) ***
[   32.318389] *** SYSTEM_REG_WRITE: reg[0xb04c] = 0x103 (Binary Ninja EXACT) ***
[   32.318395] *** SYSTEM_REG_WRITE: reg[0xb050] = 0x3 (Binary Ninja EXACT) ***
[   32.318401] *** WRITING CRITICAL VARYING REGISTERS - USING EXACT REFERENCE VALUES ***
[   32.318407] *** SYSTEM_REG_WRITE: reg[0xb07c] = 0x341b (Binary Ninja EXACT) ***
[   32.318414] *** SYSTEM_REG_WRITE: reg[0xb080] = 0x46b0 (Binary Ninja EXACT) ***
[   32.318421] *** SYSTEM_REG_WRITE: reg[0xb084] = 0x1813 (Binary Ninja EXACT) ***
[   32.318427] *** SYSTEM_REG_WRITE: reg[0xb08c] = 0x10a (Binary Ninja EXACT) ***
[   32.318433] *** ISP CORE CONTROL REGISTERS WRITTEN - NOW MATCHES REFERENCE DRIVER ***
[   32.318438] *** WRITING ISP CONTROL REGISTERS - FROM BINARY NINJA tisp_init ***
[   32.318445] system_reg_write: BLOCKED reg[0x9804]=0x3f00 during streaming to protect interrupts
[   32.318452] *** SYSTEM_REG_WRITE: reg[0x9864] = 0x7800438 (Binary Ninja EXACT) ***
[   32.318459] *** SYSTEM_REG_WRITE: reg[0x987c] = 0xc0000000 (Binary Ninja EXACT) ***
[   32.318465] *** SYSTEM_REG_WRITE: reg[0x9880] = 0x1 (Binary Ninja EXACT) ***
[   32.318472] *** SYSTEM_REG_WRITE: reg[0x9884] = 0x1 (Binary Ninja EXACT) ***
[   32.318479] *** SYSTEM_REG_WRITE: reg[0x9890] = 0x1010001 (Binary Ninja EXACT) ***
[   32.318485] *** SYSTEM_REG_WRITE: reg[0x989c] = 0x1010001 (Binary Ninja EXACT) ***
[   32.318493] *** SYSTEM_REG_WRITE: reg[0x98a8] = 0x1010001 (Binary Ninja EXACT) ***
[   32.318498] *** WRITING VIC CONTROL REGISTERS - FROM BINARY NINJA tisp_init ***
[   32.318505] *** SYSTEM_REG_WRITE: reg[0x9a00] = 0x50002d0 (Binary Ninja EXACT) ***
[   32.318511] *** SYSTEM_REG_WRITE: reg[0x9a04] = 0x3000300 (Binary Ninja EXACT) ***
[   32.318519] *** SYSTEM_REG_WRITE: reg[0x9a2c] = 0x50002d0 (Binary Ninja EXACT) ***
[   32.318525] *** SYSTEM_REG_WRITE: reg[0x9a34] = 0x1 (Binary Ninja EXACT) ***
[   32.318531] *** SYSTEM_REG_WRITE: reg[0x9a70] = 0x1 (Binary Ninja EXACT) ***
[   32.318538] *** SYSTEM_REG_WRITE: reg[0x9a7c] = 0x1 (Binary Ninja EXACT) ***
[   32.318545] *** SYSTEM_REG_WRITE: reg[0x9a80] = 0x500 (Binary Ninja EXACT) ***
[   32.318551] *** SYSTEM_REG_WRITE: reg[0x9a88] = 0x1 (Binary Ninja EXACT) ***
[   32.318558] *** SYSTEM_REG_WRITE: reg[0x9a94] = 0x1 (Binary Ninja EXACT) ***
[   32.318564] *** SYSTEM_REG_WRITE: reg[0x9a98] = 0x500 (Binary Ninja EXACT) ***
[   32.318570] *** TUNING SYSTEM: VIC control registers 0x9ac0/0x9ac8 REMOVED - not in Binary Ninja reference ***
[   32.318578] tisp_init: CRITICAL FIX - Using ACTUAL sensor image dimensions 1920x1080 (not frame size 1920x1080)
[   32.318585] *** SYSTEM_REG_WRITE: reg[0x4] = 0x7800438 (Binary Ninja EXACT) ***
[   32.318591] *** SYSTEM_REG_WRITE: reg[0x8] = 0x0 (Binary Ninja EXACT) ***
[   32.318598] *** SYSTEM_REG_WRITE: reg[0x1c] = 0x3f08 (Binary Ninja EXACT) ***
[   32.318603] *** tisp_init: ISP control register set to enable processing pipeline ***
[   32.318610] *** SYSTEM_REG_WRITE: reg[0x10] = 0x133 (Binary Ninja EXACT) ***
[   32.318616] *** tisp_init: REFERENCE DRIVER format register 0x10 = 0x133 ***
[   32.318623] *** SYSTEM_REG_WRITE: reg[0x30] = 0xffffffff (Binary Ninja EXACT) ***
[   32.318628] *** tisp_init: REFERENCE DRIVER register 0x30 = 0xffffffff ***
[   32.318635] *** SYSTEM_REG_WRITE: reg[0x24] = 0x1 (Binary Ninja EXACT) ***
[   32.318641] *** SYSTEM_REG_WRITE: reg[0x28] = 0x1 (Binary Ninja EXACT) ***
[   32.318647] *** tisp_init: ISP data flow configured (input->processing->output) ***
[   32.318653] *** SYSTEM_REG_WRITE: reg[0x804] = 0x1c (Binary Ninja EXACT) ***
[   32.318659] *** tisp_init: STREAMING ACTIVE - Skipping ISP control register write to prevent shutdown ***
[   32.318665] *** tisp_init: VIC streaming detected - keeping ISP controls enabled ***
[   32.318671] *** SYSTEM_REG_WRITE: reg[0x800] = 0x1 (Binary Ninja EXACT) ***
[   32.318679] *** tisp_init: REFERENCE DRIVER final configuration - 0x804=0x1c, 0x1c=SKIPPED, 0x800=1 ***
[   32.318685] *** SYSTEM_REG_WRITE: reg[0x4] = 0x7800438 (Binary Ninja EXACT) ***
[   32.318692] *** tisp_init: ISP frame size configured - 1920x1080 (ACTUAL sensor image) ***
[   32.318699] *** SYSTEM_REG_WRITE: reg[0x8] = 0x1 (Binary Ninja EXACT) ***
[   32.318705] *** tisp_init: CRITICAL FIX - Bayer pattern configured: mbus=0x3001 -> pattern=1 (register 8) ***
[   32.318711] *** tisp_init: CONFIGURING RAW10 BAYER PROCESSING PIPELINE ***
[   32.318717] *** SYSTEM_REG_WRITE: reg[0x14] = 0x2b (Binary Ninja EXACT) ***
[   32.318724] *** SYSTEM_REG_WRITE: reg[0x18] = 0xa0a (Binary Ninja EXACT) ***
[   32.318731] *** SYSTEM_REG_WRITE: reg[0x40] = 0x1 (Binary Ninja EXACT) ***
[   32.318737] *** SYSTEM_REG_WRITE: reg[0x44] = 0x1 (Binary Ninja EXACT) ***
[   32.318743] *** SYSTEM_REG_WRITE: reg[0x5000] = 0x1 (Binary Ninja EXACT) ***
[   32.318750] *** SYSTEM_REG_WRITE: reg[0x5004] = 0x1000000 (Binary Ninja EXACT) ***
[   32.318757] *** SYSTEM_REG_WRITE: reg[0x5006] = 0x100 (Binary Ninja EXACT) ***
[   32.318765] *** SYSTEM_REG_WRITE: reg[0x5008] = 0x0 (Binary Ninja EXACT) ***
[   32.318772] *** SYSTEM_REG_WRITE: reg[0x500a] = 0x1000000 (Binary Ninja EXACT) ***
[   32.318779] *** SYSTEM_REG_WRITE: reg[0x500c] = 0x100 (Binary Ninja EXACT) ***
[   32.318786] *** SYSTEM_REG_WRITE: reg[0x5018] = 0x0 (Binary Ninja EXACT) ***
[   32.318793] *** SYSTEM_REG_WRITE: reg[0x501c] = 0x1 (Binary Ninja EXACT) ***
[   32.318799] *** SYSTEM_REG_WRITE: reg[0x5020] = 0x0 (Binary Ninja EXACT) ***
[   32.318805] *** CRITICAL FIX: CCM configured using EXACT Binary Ninja register addresses ***
[   32.318810] *** CCM registers 0x5004-0x5014 programmed with identity matrix ***
[   32.318815] *** This should eliminate green frames by enabling proper color processing ***
[   32.318822] *** SYSTEM_REG_WRITE: reg[0x200] = 0x4d (Binary Ninja EXACT) ***
[   32.318829] *** SYSTEM_REG_WRITE: reg[0x204] = 0x96 (Binary Ninja EXACT) ***
[   32.318835] *** SYSTEM_REG_WRITE: reg[0x208] = 0x1d (Binary Ninja EXACT) ***
[   32.318841] *** SYSTEM_REG_WRITE: reg[0x20c] = 0x70 (Binary Ninja EXACT) ***
[   32.318848] *** SYSTEM_REG_WRITE: reg[0x210] = 0x5a (Binary Ninja EXACT) ***
[   32.318855] *** SYSTEM_REG_WRITE: reg[0x214] = 0x80 (Binary Ninja EXACT) ***
[   32.318861] *** SYSTEM_REG_WRITE: reg[0x218] = 0x80 (Binary Ninja EXACT) ***
[   32.318868] *** SYSTEM_REG_WRITE: reg[0x21c] = 0x6a (Binary Ninja EXACT) ***
[   32.318875] *** SYSTEM_REG_WRITE: reg[0x220] = 0x16 (Binary Ninja EXACT) ***
[   32.318880] *** CRITICAL FIX: RGB to YUV conversion matrix configured properly ***
[   32.318885] *** tisp_init: RAW10 BAYER PROCESSING PIPELINE CONFIGURED ***
[   32.318891] *** tisp_init: Loading ISP tuning parameters from /etc/sensor/ ***
[   32.318896] *** tisp_init: Standard tuning parameters loaded successfully ***
[   32.318901] *** tisp_init: Custom tuning parameters loaded successfully ***
[   32.318907] tisp_set_csc_version: Setting CSC version 0
[   32.318914] *** SYSTEM_REG_WRITE: reg[0xc] = 0x80700008 (Binary Ninja EXACT) ***
[   32.318921] *** CRITICAL FIX: ISP bypass register set to EXACT reference value 0x80700008 - prevents hardware reset ***
[   32.318926] *** tisp_init: CONFIGURING ISP FOR NV12 OUTPUT FORMAT ***
[   32.318933] *** SYSTEM_REG_WRITE: reg[0x10] = 0x133 (Binary Ninja EXACT) ***
[   32.318939] *** SYSTEM_REG_WRITE: reg[0x30] = 0xffffffff (Binary Ninja EXACT) ***
[   32.318945] *** tisp_init: ISP configured for NV12 4:2:0 output format ***
[   32.318950] *** tisp_init: INITIALIZING ALL ISP PIPELINE COMPONENTS ***
[   32.318957] *** SYSTEM_REG_WRITE: reg[0x5000] = 0x1 (Binary Ninja EXACT) ***
[   32.318963] *** SYSTEM_REG_WRITE: reg[0x5004] = 0x0 (Binary Ninja EXACT) ***
[   32.318969] *** tisp_init: ISP-VIC frame synchronization enabled ***
[   32.318975] *** SYSTEM_REG_WRITE: reg[0x6000] = 0x1 (Binary Ninja EXACT) ***
[   32.318981] *** SYSTEM_REG_WRITE: reg[0x6004] = 0x1 (Binary Ninja EXACT) ***
[   32.318987] *** tisp_init: ISP processing pipeline fully enabled ***
[   32.318993] *** SYSTEM_REG_WRITE: reg[0x7000] = 0x1 (Binary Ninja EXACT) ***
[   32.318999] *** SYSTEM_REG_WRITE: reg[0x7004] = 0x1 (Binary Ninja EXACT) ***
[   32.319005] *** tisp_init: ISP master processing enabled - pipeline should now work ***
[   32.319012] *** SYSTEM_REG_WRITE: reg[0x30] = 0xffffffff (Binary Ninja EXACT) ***
[   32.319019] *** SYSTEM_REG_WRITE: reg[0x10] = 0x133 (Binary Ninja EXACT) ***
[   32.319024] tisp_init: ISP memory buffers configured
[   32.319029] *** tisp_init: INITIALIZING ALL ISP PIPELINE COMPONENTS ***
[   32.319036] tiziano_ae_init: Initializing Auto Exposure (1920x1080@25) - Binary Ninja EXACT
[   32.319045] tiziano_ae_params_refresh: Refreshing AE parameters
[   32.319055] tiziano_ae_params_refresh: AE parameters refreshed
[   32.319061] tiziano_ae_init_exp_th: Initializing AE exposure thresholds
[   32.319067] tiziano_ae_init_exp_th: AE exposure thresholds initialized
[   32.319073] tiziano_ae_para_addr: Setting up AE parameter addresses
[   32.319078] tiziano_ae_para_addr: AE parameter addresses configured
[   32.319084] tiziano_ae_set_hardware_param: ae_id=0, update_only=0
[   32.319091] *** SYSTEM_REG_WRITE: reg[0xa004] = 0xff0ff (Binary Ninja EXACT) ***
[   32.319098] *** SYSTEM_REG_WRITE: reg[0xa008] = 0x40d0b00 (Binary Ninja EXACT) ***
[   32.319105] *** SYSTEM_REG_WRITE: reg[0xa00c] = 0x80d0b00 (Binary Ninja EXACT) ***
[   32.319111] *** SYSTEM_REG_WRITE: reg[0xa010] = 0xc0d0b00 (Binary Ninja EXACT) ***
[   32.319118] *** SYSTEM_REG_WRITE: reg[0xa014] = 0xd0b00 (Binary Ninja EXACT) ***
[   32.319125] *** SYSTEM_REG_WRITE: reg[0xa018] = 0xd0b0010 (Binary Ninja EXACT) ***
[   32.319132] *** SYSTEM_REG_WRITE: reg[0xa01c] = 0x6b885814 (Binary Ninja EXACT) ***
[   32.319139] *** SYSTEM_REG_WRITE: reg[0xa020] = 0x1000c0 (Binary Ninja EXACT) ***
[   32.319145] *** SYSTEM_REG_WRITE: reg[0xa024] = 0x43800 (Binary Ninja EXACT) ***
[   32.319152] *** SYSTEM_REG_WRITE: reg[0xa000] = 0x1 (Binary Ninja EXACT) ***
[   32.319159] *** SYSTEM_REG_WRITE: reg[0xa028] = 0x100000 (Binary Ninja EXACT) ***
[   32.319165] tiziano_ae_set_hardware_param: Parameters written to AE0
[   32.319171] tiziano_ae_set_hardware_param: ae_id=1, update_only=0
[   32.319177] *** SYSTEM_REG_WRITE: reg[0xa804] = 0x0 (Binary Ninja EXACT) ***
[   32.319184] *** SYSTEM_REG_WRITE: reg[0xa808] = 0x0 (Binary Ninja EXACT) ***
[   32.319190] *** SYSTEM_REG_WRITE: reg[0xa80c] = 0x0 (Binary Ninja EXACT) ***
[   32.319197] *** SYSTEM_REG_WRITE: reg[0xa810] = 0x0 (Binary Ninja EXACT) ***
[   32.319203] *** SYSTEM_REG_WRITE: reg[0xa814] = 0x0 (Binary Ninja EXACT) ***
[   32.319210] *** SYSTEM_REG_WRITE: reg[0xa818] = 0x0 (Binary Ninja EXACT) ***
[   32.319216] *** SYSTEM_REG_WRITE: reg[0xa81c] = 0x0 (Binary Ninja EXACT) ***
[   32.319223] *** SYSTEM_REG_WRITE: reg[0xa820] = 0x0 (Binary Ninja EXACT) ***
[   32.319229] *** SYSTEM_REG_WRITE: reg[0xa824] = 0x0 (Binary Ninja EXACT) ***
[   32.319236] *** SYSTEM_REG_WRITE: reg[0xa800] = 0x1 (Binary Ninja EXACT) ***
[   32.319242] *** SYSTEM_REG_WRITE: reg[0xa828] = 0x0 (Binary Ninja EXACT) ***
[   32.319248] tiziano_ae_set_hardware_param: Parameters written to AE1
[   32.319254] *** DEBUGGING: Registering ONLY callback for bit 10 (status 0x400) ***
[   32.319261] *** system_irq_func_set: Registered handler c0686aac at index 10 ***
[   32.338473] *** system_irq_func_set: Registered handler c0686ba0 at index 27 ***
[   32.346135] *** system_irq_func_set: Registered handler c0686aac at index 26 ***
[   32.363909] *** system_irq_func_set: Registered handler c0686c88 at index 29 ***
[   32.378606] *** system_irq_func_set: Registered handler c0686c14 at index 28 ***
[   32.393642] *** system_irq_func_set: Registered handler c0686cfc at index 30 ***
root@ing-wyze-cam3-a000 ~# dm---- FPGA board is ready ----
  Board UID : 30AB6E51
  Board HW ID : 72000460
  Board rev.  : 5DE5A975
  Board date  : 20190326
-----------------------------
root@ing-wyze-cam3-a000 ~# dmesg 
[   32.487482] tiziano_dpc_init: Initializing DPC processing
[   32.487487] tiziano_dpc_params_refresh: Refreshing DPC parameters
[   32.487493] tiziano_dpc_params_refresh: DPC parameters updated based on EV
[   32.487500] tisp_dpc_par_refresh: EV=0, threshold=0, enable=1
[   32.487505] tisp_dpc_all_reg_refresh: Writing DPC parameters to registers
[   32.487521] tisp_dpc_all_reg_refresh: DPC registers written to hardware
[   32.487527] *** SYSTEM_REG_WRITE: reg[0xa200] = 0x1 (Binary Ninja EXACT) ***
[   32.487533] tiziano_hldc_init: Initializing HLDC processing
[   32.487539] *** SYSTEM_REG_WRITE: reg[0x9044] = 0x3 (Binary Ninja EXACT) ***
[   32.487545] tiziano_defog_init: Initializing Defog processing (1920x1080)
[   32.487552] tiziano_adr_init: Initializing ADR processing (1920x1080)
[   32.487559] *** SYSTEM_REG_WRITE: reg[0x4000] = 0x10e0140 (Binary Ninja EXACT) ***
[   32.487566] *** SYSTEM_REG_WRITE: reg[0x4010] = 0x10e0000 (Binary Ninja EXACT) ***
[   32.487573] *** SYSTEM_REG_WRITE: reg[0x4014] = 0x21c021c (Binary Ninja EXACT) ***
[   32.487580] *** SYSTEM_REG_WRITE: reg[0x4018] = 0x438 (Binary Ninja EXACT) ***
[   32.487587] *** SYSTEM_REG_WRITE: reg[0x401c] = 0x1400000 (Binary Ninja EXACT) ***
[   32.487594] *** SYSTEM_REG_WRITE: reg[0x4020] = 0x3c00280 (Binary Ninja EXACT) ***
[   32.487601] *** SYSTEM_REG_WRITE: reg[0x4024] = 0x50003c0 (Binary Ninja EXACT) ***
[   32.487607] *** SYSTEM_REG_WRITE: reg[0x4028] = 0x780 (Binary Ninja EXACT) ***
[   32.487614] *** SYSTEM_REG_WRITE: reg[0x4454] = 0x3f60042 (Binary Ninja EXACT) ***
[   32.487621] *** SYSTEM_REG_WRITE: reg[0x4458] = 0x7300050 (Binary Ninja EXACT) ***
[   32.487627] tiziano_adr_params_refresh: Refreshing ADR parameters
[   32.487632] tiziano_adr_params_refresh: ADR ratio updated to 0x180
[   32.487637] tiziano_adr_params_init: Initializing ADR parameter arrays
[   32.487645] tisp_adr_set_params: Writing ADR parameters to registers
[   32.487677] tisp_adr_set_params: ADR parameters written to hardware
[   32.487683] tisp_event_set_cb: Setting callback for event 18
[   32.487690] tisp_event_set_cb: Event 18 callback set to c0686da4
[   32.487696] tisp_event_set_cb: Setting callback for event 2
[   32.487703] tisp_event_set_cb: Event 2 callback set to c06858a8
[   32.487707] tiziano_adr_init: ADR processing initialized successfully
[   32.487714] tiziano_af_init: Initializing Auto Focus (1920x1080)
[   32.487719] tiziano_bcsh_init: Initializing BCSH processing
[   32.487725] tiziano_ydns_init: Initializing YDNS processing
[   32.487729] tiziano_rdns_init: Initializing RDNS processing
[   32.487735] *** tisp_init: ALLOCATING ISP PROCESSING BUFFERS ***
[   32.487749] *** SYSTEM_REG_WRITE: reg[0xa02c] = 0x498000 (Binary Ninja EXACT) ***
[   32.487757] *** SYSTEM_REG_WRITE: reg[0xa030] = 0x499000 (Binary Ninja EXACT) ***
[   32.487763] *** SYSTEM_REG_WRITE: reg[0xa034] = 0x49a000 (Binary Ninja EXACT) ***
[   32.487770] *** SYSTEM_REG_WRITE: reg[0xa038] = 0x49b000 (Binary Ninja EXACT) ***
[   32.487777] *** SYSTEM_REG_WRITE: reg[0xa03c] = 0x49c000 (Binary Ninja EXACT) ***
[   32.487784] *** SYSTEM_REG_WRITE: reg[0xa040] = 0x49c800 (Binary Ninja EXACT) ***
[   32.487791] *** SYSTEM_REG_WRITE: reg[0xa044] = 0x49d000 (Binary Ninja EXACT) ***
[   32.487798] *** SYSTEM_REG_WRITE: reg[0xa048] = 0x49d800 (Binary Ninja EXACT) ***
[   32.487805] *** SYSTEM_REG_WRITE: reg[0xa04c] = 0x33 (Binary Ninja EXACT) ***
[   32.487811] *** tisp_init: AE0 buffer allocated at 0x00498000 ***
[   32.487817] *** CRITICAL FIX: data_b2f3c initialized to 0x80498000 (prevents stack corruption) ***
[   32.487826] *** SYSTEM_REG_WRITE: reg[0xa82c] = 0x1140000 (Binary Ninja EXACT) ***
[   32.487833] *** SYSTEM_REG_WRITE: reg[0xa830] = 0x1141000 (Binary Ninja EXACT) ***
[   32.487840] *** SYSTEM_REG_WRITE: reg[0xa834] = 0x1142000 (Binary Ninja EXACT) ***
[   32.487847] *** SYSTEM_REG_WRITE: reg[0xa838] = 0x1143000 (Binary Ninja EXACT) ***
[   32.487854] *** SYSTEM_REG_WRITE: reg[0xa83c] = 0x1144000 (Binary Ninja EXACT) ***
[   32.487861] *** SYSTEM_REG_WRITE: reg[0xa840] = 0x1144800 (Binary Ninja EXACT) ***
[   32.487868] *** SYSTEM_REG_WRITE: reg[0xa844] = 0x1145000 (Binary Ninja EXACT) ***
[   32.487875] *** SYSTEM_REG_WRITE: reg[0xa848] = 0x1145800 (Binary Ninja EXACT) ***
[   32.487881] *** SYSTEM_REG_WRITE: reg[0xa84c] = 0x33 (Binary Ninja EXACT) ***
[   32.487887] *** tisp_init: AE1 buffer allocated at 0x01140000 ***
[   32.487893] *** tisp_init: FINAL REGISTER SEQUENCE ***
[   32.487899] *** SYSTEM_REG_WRITE: reg[0x804] = 0x1c (Binary Ninja EXACT) ***
[   32.487905] *** tisp_init: STREAMING ACTIVE - Skipping second ISP control register write ***
[   32.487911] *** SYSTEM_REG_WRITE: reg[0x800] = 0x1 (Binary Ninja EXACT) ***
[   32.487917] *** tisp_init: INITIALIZING ISP SUB-MODULES ***
[   32.487924] tiziano_ae_init: Initializing Auto Exposure (1920x1080@25) - Binary Ninja EXACT
[   32.487933] tiziano_ae_params_refresh: Refreshing AE parameters
[   32.487945] tiziano_ae_params_refresh: AE parameters refreshed
[   32.487951] tiziano_ae_init_exp_th: Initializing AE exposure thresholds
[   32.487957] tiziano_ae_init_exp_th: AE exposure thresholds initialized
[   32.487963] tiziano_ae_para_addr: Setting up AE parameter addresses
[   32.487968] tiziano_ae_para_addr: AE parameter addresses configured
[   32.487975] tiziano_ae_set_hardware_param: ae_id=0, update_only=0
[   32.487981] *** SYSTEM_REG_WRITE: reg[0xa004] = 0xff0ff (Binary Ninja EXACT) ***
[   32.487988] *** SYSTEM_REG_WRITE: reg[0xa008] = 0x40d0b00 (Binary Ninja EXACT) ***
[   32.487995] *** SYSTEM_REG_WRITE: reg[0xa00c] = 0x80d0b00 (Binary Ninja EXACT) ***
[   32.488002] *** SYSTEM_REG_WRITE: reg[0xa010] = 0xc0d0b00 (Binary Ninja EXACT) ***
[   32.488009] *** SYSTEM_REG_WRITE: reg[0xa014] = 0xd0b00 (Binary Ninja EXACT) ***
[   32.488016] *** SYSTEM_REG_WRITE: reg[0xa018] = 0xd0b0010 (Binary Ninja EXACT) ***
[   32.488023] *** SYSTEM_REG_WRITE: reg[0xa01c] = 0x6b885814 (Binary Ninja EXACT) ***
[   32.488030] *** SYSTEM_REG_WRITE: reg[0xa020] = 0x1000c0 (Binary Ninja EXACT) ***
[   32.488037] *** SYSTEM_REG_WRITE: reg[0xa024] = 0x43800 (Binary Ninja EXACT) ***
[   32.488043] *** SYSTEM_REG_WRITE: reg[0xa000] = 0x1 (Binary Ninja EXACT) ***
[   32.488050] *** SYSTEM_REG_WRITE: reg[0xa028] = 0x100000 (Binary Ninja EXACT) ***
[   32.488056] tiziano_ae_set_hardware_param: Parameters written to AE0
[   32.488062] tiziano_ae_set_hardware_param: ae_id=1, update_only=0
[   32.488069] *** SYSTEM_REG_WRITE: reg[0xa804] = 0x0 (Binary Ninja EXACT) ***
[   32.488075] *** SYSTEM_REG_WRITE: reg[0xa808] = 0x0 (Binary Ninja EXACT) ***
[   32.488082] *** SYSTEM_REG_WRITE: reg[0xa80c] = 0x0 (Binary Ninja EXACT) ***
[   32.488088] *** SYSTEM_REG_WRITE: reg[0xa810] = 0x0 (Binary Ninja EXACT) ***
[   32.488095] *** SYSTEM_REG_WRITE: reg[0xa814] = 0x0 (Binary Ninja EXACT) ***
[   32.488101] *** SYSTEM_REG_WRITE: reg[0xa818] = 0x0 (Binary Ninja EXACT) ***
[   32.488108] *** SYSTEM_REG_WRITE: reg[0xa81c] = 0x0 (Binary Ninja EXACT) ***
[   32.488136] *** SYSTEM_REG_WRITE: reg[0xa820] = 0x0 (Binary Ninja EXACT) ***
[   32.488144] *** SYSTEM_REG_WRITE: reg[0xa824] = 0x0 (Binary Ninja EXACT) ***
[   32.488151] *** SYSTEM_REG_WRITE: reg[0xa800] = 0x1 (Binary Ninja EXACT) ***
[   32.488157] *** SYSTEM_REG_WRITE: reg[0xa828] = 0x0 (Binary Ninja EXACT) ***
[   32.488163] tiziano_ae_set_hardware_param: Parameters written to AE1
[   32.488169] *** DEBUGGING: Registering ONLY callback for bit 10 (status 0x400) ***
[   32.488176] *** system_irq_func_set: Registered handler c0686aac at index 10 ***
[   32.505992] *** system_irq_func_set: Registered handler c0686ba0 at index 27 ***
[   32.520457] *** system_irq_func_set: Registered handler c0686aac at index 26 ***
[   32.534589] *** system_irq_func_set: Registered handler c0686c88 at index 29 ***
[   32.557350] *** system_irq_func_set: Registered handler c0686c14 at index 28 ***
[   32.575169] *** system_irq_func_set: Registered handler c0686cfc at index 30 ***
[   32.590473] *** system_irq_func_set: Registered handler c0686d50 at index 20 ***
[   32.608296] *** system_irq_func_set: Registered handler c0686da4 at index 18 ***
[   32.628483] *** system_irq_func_set: Registered handler c0686df8 at index 31 ***
[   32.636147] *** system_irq_func_set: Registered handler c0686e4c at index 11 ***
[   32.650468] tiziano_deflicker_expt: flicker_t=0, param2=4096, param3=25, param4=1
[   32.650490] tiziano_deflicker_expt: Generated 119 LUT entries
[   32.650497] tisp_event_set_cb: Setting callback for event 1
[   32.650504] tisp_event_set_cb: Event 1 callback set to c06866ac
[   32.650510] tisp_event_set_cb: Setting callback for event 6
[   32.650516] tisp_event_set_cb: Event 6 callback set to c0685c0c
[   32.650522] *** CRITICAL FIX: Skipping NULL spinlock initialization that was causing 6+ second delays ***
[   32.650528] tiziano_ae_init: AE initialization complete - Binary Ninja EXACT implementation
[   32.650535] tiziano_awb_init: Initializing Auto White Balance (1920x1080)
[   32.650543] *** SYSTEM_REG_WRITE: reg[0xb000] = 0x1 (Binary Ninja EXACT) ***
[   32.650549] *** SYSTEM_REG_WRITE: reg[0x1800] = 0x1 (Binary Ninja EXACT) ***
[   32.650554] tiziano_awb_init: AWB hardware blocks enabled
[   32.650559] tiziano_gamma_init: Initializing Gamma processing
[   32.650565] tiziano_gamma_lut_parameter: Writing gamma LUT to registers
[   32.650625] tiziano_gamma_lut_parameter: Gamma LUT written to hardware
[   32.650630] tiziano_gib_init: Initializing GIB processing
[   32.650635] tiziano_lsc_init: Initializing LSC processing
[   32.650641] tiziano_lsc_params_refresh: Refreshing LSC parameters
[   32.650647] tiziano_lsc_params_refresh: Updated LSC strength=0x800, CT=9984
[   32.650654] *** SYSTEM_REG_WRITE: reg[0x3800] = 0x11 (Binary Ninja EXACT) ***
[   32.650661] *** SYSTEM_REG_WRITE: reg[0x3804] = 0x108002 (Binary Ninja EXACT) ***
[   32.650666] tisp_lsc_write_lut_datas: Writing LSC LUT data
[   32.650723] tiziano_ccm_init: Initializing Color Correction Matrix
[   32.650729] tiziano_ccm_init: Using linear CCM parameters
[   32.650735] tiziano_ccm_params_refresh: Refreshing CCM parameters
[   32.650741] jz_isp_ccm: EV=64, CT=9984
[   32.650747] tiziano_ct_ccm_interpolation: CT=9984, threshold=100
[   32.650753] cm_control: saturation=128
[   32.650758] tiziano_ccm_lut_parameter: Writing CCM matrix to registers
[   32.650765] tiziano_ccm_lut_parameter: CCM matrix written to hardware
[   32.650770] tiziano_ccm_init: CCM initialized successfully
[   32.650775] tiziano_dmsc_init: Initializing DMSC processing
[   32.650780] tiziano_sharpen_init: Initializing Sharpening
[   32.650786] tiziano_sharpen_init: Using linear sharpening parameters
[   32.650791] tiziano_sharpen_params_refresh: Refreshing sharpening parameters (simple version)
[   32.650798] tisp_sharpen_par_refresh: EV=0, threshold=0, enable=1
[   32.650804] tisp_sharpen_all_reg_refresh: Writing sharpening parameters to registers
[   32.650830] tisp_sharpen_all_reg_refresh: Sharpening registers written to hardware
[   32.650837] *** SYSTEM_REG_WRITE: reg[0xb400] = 0x1 (Binary Ninja EXACT) ***
[   32.650842] tiziano_sharpen_init: Sharpening initialized successfully
[   32.650847] tiziano_sdns_init: Initializing SDNS processing
[   32.650856] tiziano_sdns_init: Using linear SDNS parameters
[   32.650861] tiziano_sdns_params_refresh: Refreshing SDNS parameters (simple version)
[   32.650868] tisp_sdns_par_refresh: EV=0, threshold=0, enable=1
[   32.650874] tisp_sdns_all_reg_refresh: Writing SDNS parameters to registers
[   32.650907] tisp_sdns_all_reg_refresh: SDNS registers written to hardware
[   32.650913] *** SYSTEM_REG_WRITE: reg[0x8b4c] = 0x1 (Binary Ninja EXACT) ***
[   32.650919] tiziano_sdns_init: SDNS processing initialized successfully
[   32.650925] tiziano_mdns_init: Initializing MDNS processing (1920x1080)
[   32.650930] tiziano_mdns_init: Using linear MDNS parameters
[   32.650941] tiziano_mdns_init: MDNS processing initialized successfully
[   32.650945] tiziano_clm_init: Initializing CLM processing
[   32.650951] tiziano_dpc_init: Initializing DPC processing
[   32.650956] tiziano_dpc_params_refresh: Refreshing DPC parameters
[   32.650962] tiziano_dpc_params_refresh: DPC parameters updated based on EV
[   32.650969] tisp_dpc_par_refresh: EV=0, threshold=0, enable=1
[   32.650975] tisp_dpc_all_reg_refresh: Writing DPC parameters to registers
[   32.650989] tisp_dpc_all_reg_refresh: DPC registers written to hardware
[   32.650996] *** SYSTEM_REG_WRITE: reg[0xa200] = 0x1 (Binary Ninja EXACT) ***
[   32.651001] tiziano_hldc_init: Initializing HLDC processing
[   32.651007] *** SYSTEM_REG_WRITE: reg[0x9044] = 0x3 (Binary Ninja EXACT) ***
[   32.651014] tiziano_defog_init: Initializing Defog processing (1920x1080)
[   32.651021] tiziano_adr_init: Initializing ADR processing (1920x1080)
[   32.651027] *** SYSTEM_REG_WRITE: reg[0x4000] = 0x10e0140 (Binary Ninja EXACT) ***
[   32.651034] *** SYSTEM_REG_WRITE: reg[0x4010] = 0x10e0000 (Binary Ninja EXACT) ***
[   32.651041] *** SYSTEM_REG_WRITE: reg[0x4014] = 0x21c021c (Binary Ninja EXACT) ***
[   32.651048] *** SYSTEM_REG_WRITE: reg[0x4018] = 0x438 (Binary Ninja EXACT) ***
[   32.651055] *** SYSTEM_REG_WRITE: reg[0x401c] = 0x1400000 (Binary Ninja EXACT) ***
[   32.651061] *** SYSTEM_REG_WRITE: reg[0x4020] = 0x3c00280 (Binary Ninja EXACT) ***
[   32.651069] *** SYSTEM_REG_WRITE: reg[0x4024] = 0x50003c0 (Binary Ninja EXACT) ***
[   32.651075] *** SYSTEM_REG_WRITE: reg[0x4028] = 0x780 (Binary Ninja EXACT) ***
[   32.651082] *** SYSTEM_REG_WRITE: reg[0x4454] = 0x3f60042 (Binary Ninja EXACT) ***
[   32.651089] *** SYSTEM_REG_WRITE: reg[0x4458] = 0x7300050 (Binary Ninja EXACT) ***
[   32.651094] tiziano_adr_params_refresh: Refreshing ADR parameters
[   32.651100] tiziano_adr_params_refresh: ADR ratio updated to 0x180
[   32.651105] tiziano_adr_params_init: Initializing ADR parameter arrays
[   32.651112] tisp_adr_set_params: Writing ADR parameters to registers
[   32.651144] tisp_adr_set_params: ADR parameters written to hardware
[   32.651150] tisp_event_set_cb: Setting callback for event 18
[   32.651156] tisp_event_set_cb: Event 18 callback set to c0686da4
[   32.651162] tisp_event_set_cb: Setting callback for event 2
[   32.651168] tisp_event_set_cb: Event 2 callback set to c06858a8
[   32.651173] tiziano_adr_init: ADR processing initialized successfully
[   32.651180] tiziano_af_init: Initializing Auto Focus (1920x1080)
[   32.651185] tiziano_bcsh_init: Initializing BCSH processing
[   32.651190] tiziano_ydns_init: Initializing YDNS processing
[   32.651195] tiziano_rdns_init: Initializing RDNS processing
[   32.651201] *** tisp_init: INITIALIZING ISP EVENT SYSTEM ***
[   32.651205] tisp_event_init: Initializing ISP event system
[   32.651213] tisp_event_init: SAFE event system initialized with 20 nodes
[   32.651218] tisp_event_set_cb: Setting callback for event 4
[   32.651225] tisp_event_set_cb: Event 4 callback set to c06858d4
[   32.651230] tisp_event_set_cb: Setting callback for event 5
[   32.651237] tisp_event_set_cb: Event 5 callback set to c0685d9c
[   32.651242] tisp_event_set_cb: Setting callback for event 7
[   32.651248] tisp_event_set_cb: Event 7 callback set to c0685968
[   32.651254] tisp_event_set_cb: Setting callback for event 9
[   32.651260] tisp_event_set_cb: Event 9 callback set to c06859f0
[   32.651265] tisp_event_set_cb: Setting callback for event 8
[   32.651272] tisp_event_set_cb: Event 8 callback set to c0685ab4
[   32.651277] *** tisp_init: BINARY NINJA REFERENCE - No event processing thread created ***
[   32.651283] *** tisp_init: Event system ready for on-demand processing (Binary Ninja reference) ***
[   32.651289] tisp_param_operate_init: Initializing parameter operations
[   32.651297] tisp_netlink_init: Initializing netlink communication
[   32.651302] tisp_netlink_init: Trying standard NETLINK_GENERIC protocol (16)
[   32.651333] tisp_netlink_init: NETLINK_GENERIC failed, trying custom protocol 0x17
[   32.651343] tisp_netlink_init: Netlink socket created successfully
[   32.651349] tisp_code_create_tuning_node: Creating ISP M0 tuning device node
[   32.651354] tisp_code_create_tuning_node: Device already created, skipping
[   32.651361] *** tisp_init: ISP HARDWARE PIPELINE FULLY INITIALIZED - THIS SHOULD TRIGGER REGISTER ACTIVITY ***
[   32.651366] *** tisp_init: All hardware blocks enabled, registers configured, events ready ***
[   32.651373] *** ispcore_core_ops_init_with_sensor: tisp_init SUCCESS - MIPI CSI should now be configured ***
[   32.651379] *** ispcore_core_ops_init_with_sensor: VIC already in state 4 (>= 3) ****** ispcore_core_ops_init_with_sensor: SUCCESS - Core initialized with sensor attributes ***
[   32.651388] ispcore_slake_module: Initializing channelsispcore_slake_module: Channel 0 enabled
[   32.651396] ispcore_slake_module: Channel 1 enabledispcore_slake_module: Channel 2 enabled
[   32.651403] ispcore_slake_module: Channel 3 enabledispcore_slake_module: Channel 4 enabled
[   32.651411] ispcore_slake_module: Channel 5 enabledispcore_slake_module: Calling VIC control function (0x4000001, 0)
[   32.651419] ispcore_slake_module: VIC control register written: 0x4000001ispcore_slake_module: Set VIC state to INIT (1)
[   32.651426] ispcore_slake_module: Processing subdevices*** DEBUG: isp_dev=846b8000, isp_dev->subdevs=846bb274 ***
[   32.651440] *** ispcore_slake_module: Calling slake_module for CSI subdev ***
[   32.651447] *** tx_isp_vin_slake_subdev: VIN slake/shutdown - current state=4, refcnt=0 ***
[   32.651453] tx_isp_vin_slake_subdev: VIN in streaming state, stopping stream
[   32.651459] *** vin_s_stream: SAFE implementation - sd=85217800, enable=0 ***
[   32.651466] vin_s_stream: VIN state = 4, enable = 0
[   32.651471] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.651481] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.651487] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.651493] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   32.651499] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   32.651505] tx_isp_vin_slake_subdev: VIN in state 3, calling tx_isp_vin_init(disable)
[   32.651511] VIN: tx_isp_vin_init: EXACT Binary Ninja implementation with safety checks = 0x0
[   32.651516] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.651523] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.651530] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.651536] VIN: tx_isp_vin_init: a0 (sensor) = 85f69400
[   32.651542] VIN: tx_isp_vin_init: using VIN device from global ISP: 85217800
[   32.651548] VIN: tx_isp_vin_init: calling sensor init function = 0x0
[   32.651555] *** SENSOR_INIT: gc2053 enable=0 ***
[   32.651561] SENSOR_INIT: Disabled, returning success
[   32.651566] VIN: tx_isp_vin_init: sensor init returned = 0x0
[   32.651572] VIN: tx_isp_vin_init: *** VIN STATE SET SAFELY *** = 0x2
[   32.651577] VIN: tx_isp_vin_init: EXACT Binary Ninja result = 0x0
[   32.651583] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.651590] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.651596] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.651601] tx_isp_vin_slake_subdev: Releasing sensor input
[   32.651607] tx_isp_vin_slake_subdev: Releasing all sensors
[   32.651612] ispcore_sensor_ops_release_all_sensor: Releasing all sensors
[   32.651617] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.651625] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.651631] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.651637] tx_isp_vin_slake_subdev: VIN state 2->1
[   32.651642] *** tx_isp_vin_slake_subdev: VIN slake complete, final state=1 ***
[   32.651647] ispcore_slake_module: CSI slake success
[   32.651652] *** ispcore_slake_module: Calling slake_module for VIC subdev ***
[   32.651658] *** tx_isp_vic_slake_subdev: ENTRY - sd=846be000 ***
[   32.651665] *** tx_isp_vic_slake_subdev: VIC slake/shutdown - vic_dev=846be000, current state=1 ***
[   32.651672] *** tx_isp_vic_slake_subdev: VIC slake complete, final state=1 ***
[   32.651677] ispcore_slake_module: VIC slake success
[   32.651682] *** ispcore_slake_module: All subdev slake operations completed using helper functions ***
[   32.651687] ispcore_slake_module: Managing ISP clocks
[   32.651692] ispcore_slake_module: Disabled IPU clockispcore_slake_module: Disabled ISP clock
[   32.651700] ispcore_slake_module: Complete, result=0<6>[   32.651706] *** ispcore_slake_module SUCCESS - ISP core should now be initialized ***
[   32.651712] *** vic_core_s_stream: VIC initialized, final state=1 ***
[   32.651718] *** tx_isp_video_s_stream: subdev[2] s_stream SUCCESS ***
[   32.651725] *** tx_isp_video_s_stream: Calling subdev[4]->ops->video->s_stream(1) ***
[   32.651731] gc2053: s_stream called with enable=1
[   32.651739] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   32.651744] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   32.651751] gc2053: About to write streaming registers for interface 1
[   32.651757] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   32.651766] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   32.652089] sensor_write: reg=0xfe val=0x00 SUCCESS
[   32.652097] sensor_write_array: reg[1] 0xfe=0x00 OK
[   32.652105] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   32.653944] sensor_write: reg=0x3e val=0x91 SUCCESS
[   32.653956] sensor_write_array: reg[2] 0x3e=0x91 OK
[   32.653963] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   32.653970] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   32.653977] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   32.653982] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   32.653989] *** tx_isp_video_s_stream: subdev[4] s_stream SUCCESS ***
[   32.653995] *** tx_isp_video_s_stream: Calling subdev[5]->ops->video->s_stream(1) ***
[   32.654002] gc2053: s_stream called with enable=1
[   32.654009] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   32.654015] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   32.654021] gc2053: About to write streaming registers for interface 1
[   32.654027] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   32.654037] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   32.654355] sensor_write: reg=0xfe val=0x00 SUCCESS
[   32.654362] sensor_write_array: reg[1] 0xfe=0x00 OK
[   32.654371] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   32.658520] sensor_write: reg=0x3e val=0x91 SUCCESS
[   32.658533] sensor_write_array: reg[2] 0x3e=0x91 OK
[   32.658540] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   32.658547] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   32.658553] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   32.658560] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   32.658566] *** tx_isp_video_s_stream: subdev[5] s_stream SUCCESS ***
[   32.658573] *** tx_isp_video_s_stream: Post-sensor s_stream re-trigger of CSI core->init ***
[   32.670495] VIN: tx_isp_vin_init: EXACT Binary Ninja implementation with safety checks = 0x1
[   32.670508] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.670519] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.670525] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.670531] VIN: tx_isp_vin_init: a0 (sensor) = 85f69400
[   32.670538] VIN: tx_isp_vin_init: using VIN device from global ISP: 85217800
[   32.670544] VIN: tx_isp_vin_init: calling sensor init function = 0x1
[   32.670552] *** SENSOR_INIT: gc2053 enable=1 ***
[   32.670559] *** SENSOR_INIT: gc2053 already initialized, skipping to prevent CSI PHY reconfiguration ***
[   32.670565] *** SENSOR_INIT: This prevents register reset that disables ISP/VIC interrupts ***
[   32.670570] VIN: tx_isp_vin_init: sensor init returned = 0x0
[   32.670576] VIN: tx_isp_vin_init: *** VIN STATE SET SAFELY *** = 0x3
[   32.670581] VIN: tx_isp_vin_init: EXACT Binary Ninja result = 0x0
[   32.670587] *** VIC POST-SENSOR REASSERT: re-applying routing/mask after sensor stream-on ***
[   32.707345] *** VIC POST-SENSOR REASSERT: No status bits asserted in 20ms window ***
[   32.707391] ISP IOCTL: cmd=0x800456d0 arg=0x7f9d3c90
[   32.707399] TX_ISP_VIDEO_LINK_SETUP: config=0
[   32.707405] TX_ISP_VIDEO_LINK_SETUP: Link config unchanged (0)
[   32.707411] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   32.707418] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[   32.707424] *** tx_isp_video_link_stream: CRITICAL FIX - Calling activate_module on all subdevs first ***
[   32.707431] *** tx_isp_video_link_stream: Calling activate_module on subdev[2] ***
[   32.707438] VIC activated: state 1 -> 2 (READY)
[   32.707443] *** VIC ACTIVATION: Buffer allocation DEFERRED to prevent Wyze Cam memory exhaustion ***
[   32.707449] *** VIC ACTIVATION: Buffers will be allocated on-demand during QBUF operations ***
[   32.707455] *** VIC ACTIVATION: Free buffer list initialized (empty) - allocation deferred ***
[   32.707461] *** VIC ACTIVATION: Using GOOD-THINGS deferred buffer allocation strategy ***
[   32.707467] *** tx_isp_video_link_stream: activate_module SUCCESS on subdev[2] ***
[   32.707473] *** tx_isp_video_link_stream: All activate_module calls complete ***
[   32.707481] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   32.707487] vin_s_stream: VIN state = 3, enable = 1
[   32.707493] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.707502] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.707509] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.707515] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   32.707521] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   32.707527] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   32.707533] vin_s_stream: VIN state = 4, enable = 1
[   32.707538] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.707545] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.707552] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.707557] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   32.707563] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   32.707570] *** vic_core_s_stream: BINARY NINJA EXACT - sd=846be000, enable=1 ***
[   32.707576] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=2 ***
[   32.707581] *** vic_core_s_stream: STREAM ON ***
[   32.707587] *** vic_core_s_stream: EXACT Binary Ninja - State != 4, calling VIC start sequence ***
[   32.707593] *** vic_core_s_stream: SKIPPING tx_vic_disable_irq before VIC start to preserve first frame IRQ ***
[   32.707598] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   32.707605] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   32.707611] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   32.707618] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   32.707623] *** STREAMING: Configuring CPM registers for VIC access ***
[   32.730488] STREAMING: CPM clocks configured for VIC access
[   32.730503] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   32.730509] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   32.730517] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   32.730522] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   32.730528] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   32.730534] *** tx_isp_vic_start: Adding CRITICAL missing VIC configuration registers ***
[   32.730543] *** tx_isp_vic_start: CRITICAL VIC configuration registers written - hardware protection should be prevented ***
[   32.730549] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   32.730556] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   32.730562] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   32.730567] *** VIC unlock: Commands written, checking VIC status register ***
[   32.730575] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   32.730580] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   32.730586] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   32.730591] *** tx_isp_vic_start: CRITICAL FIX - Writing VIC Control register sequence ***
[   32.730597] *** tx_isp_vic_start: VIC processing enabled (0x0=0x1, 0x4=0x1) ***
[   32.730603] *** tx_isp_vic_start: Configuring VIC hardware prerequisites for interrupt registers ***
[   32.730678] read_sensor_dimensions: Successfully read 1920x1080 from /proc/jz/sensor/
[   32.730685] *** VIC DIMENSIONS: Using /proc/jz/sensor/ dimensions 1920x1080 (RELIABLE) ***
[   32.730692] *** VIC REGISTER PROTECTION: SKIPPING interrupt-disrupting registers 0xc, 0x10, 0x14 - VIC interrupts already working ***
[   32.730700] *** VIC HARDWARE PREREQUISITES: Dimensions 1920x1080, stride 3840, MIPI mode 2 ***
[   32.730705] *** VIC INTERRUPT CONFIG: VIC unlock sequence will be completed first, then interrupt config ***
[   32.730713] *** VIC INTERRUPT STATUS CHECK (BEFORE UNLOCK): STATUS=0x00000000, MASK_STATUS=0x00000000 ***
[   32.730719] *** VIC INTERRUPT CONFIG: Using WORKING BRANCH registers (NOT Binary Ninja) ***
[   32.730725] *** VIC INTERRUPT CONFIG: Configuring interrupt masks (WORKING BRANCH) ***
[   32.730731] *** VIC INTERRUPT CONFIG: Configuring ISP control interrupts (WORKING BRANCH) ***
[   32.730737] *** VIC INTERRUPT CONFIG: Applying VIC interrupt system configuration (WORKING BRANCH) ***
[   32.730743] *** VIC PRIMARY: leaving 0x14=stride as-is (readback=0x00000001) ***
[   32.730749] *** VIC INTERRUPT CONFIG: WORKING BRANCH interrupt configuration complete ***
[   32.730754] *** VIC INTERRUPT CONFIG: Mirroring WORKING BRANCH registers to control bank ***
[   32.730761] *** VIC CONTROL VERIFY: 0x0c(IMCR)=0x00000000 (expect 0xb5742249) ***
[   32.730767] *** VIC INTERRUPT CONFIG: Control bank configuration complete ***
[   32.730772] *** ISP CORE INTERRUPT CONFIG: Enabling ISP core interrupt generation (MISSING FROM CURRENT BRANCH) ***
[   32.730779] *** ISP CORE CONFIG: Writing ISP core interrupt registers at VIC start ***
[   32.730785] *** ISP CORE CONFIG: ISP core interrupt registers written (0x30=0xffffffff, 0x10=0x133) ***
[   32.730790] *** ISP CORE: Hardware interrupt generation ENABLED (0x30=0xffffffff, 0x10=0x133) ***
[   32.730796] *** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***
[   32.730803] *** ISP CORE VERIFY: 0x30=0x8fffffff, 0x10=0x00000133 ***
[   32.730809] *** VIC INTERRUPT CONFIG: Starting verification of WORKING BRANCH interrupt registers ***
[   32.730819] *** VIC INTERRUPT CONTROL VERIFY (WORKING BRANCH REGS): 0x04=0x07800438, 0x0c=0x00000001, 0x100=0x000002d0, 0x14=0x00000001 ***
[   32.730825] *** VIC INTERRUPT: Some WORKING BRANCH interrupt register configuration failed ***
[   32.730831] *** VIC INTERRUPT: Expected: 0x04=0x07800438, 0x0c=0xb5742249, 0x100=0x2d0, 0x14=0x2b ***
[   32.730838] *** VIC INTERRUPT: imr_ok=1, imcr_ok=0, config_ok=1, control_ok=0 ***
[   32.730843] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   32.730849] *** tx_isp_vic_start: VIC Control register sequence complete - streaming should start ***
[   32.730855] *** tx_isp_vic_start: VIC should now generate frame done interrupts! ***
[   32.730861] *** tx_isp_vic_start: VIC interrupt will be enabled by tx_vic_enable_irq callback ***
[   32.730867] *** vic_core_s_stream: Forcing ispvic_frame_channel_qbuf to program buffer addresses before MDMA ***
[   32.730873] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   32.730881] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   32.730887] *** vic_core_s_stream: ispvic_frame_channel_qbuf SUCCESS ***
[   32.730893] *** vic_core_s_stream: Calling ispvic_frame_channel_s_stream(ENABLE) to start MDMA before enabling IRQ ***
[   32.730899] *** ispvic_frame_channel_s_stream: EXACT Binary Ninja implementation ***
[   32.730905] ispvic_frame_channel_s_stream: arg1=846be000, arg2=1
[   32.730911] ispvic_frame_channel_s_stream: s0 (vic_dev) = 846be000
[   32.730918] ispvic_frame_channel_s_stream[2441]: streamon
[   32.730925] *** ispvic_frame_channel_s_stream: Checking stream state - current=0, requested=1 ***
[   32.730931] *** ispvic_frame_channel_s_stream: Stream state different - proceeding with streaming setup ***
[   32.730936] *** VIC CONTROL (PRIMARY): WROTE 2 to [0x0] before MDMA/config ***
[   32.730942] *** CRITICAL: Calling vic_pipo_mdma_enable - required for VIC interrupts ***
[   32.730947] *** vic_pipo_mdma_enable: EXACT Binary Ninja MCP implementation ***
[   32.730955] vic_pipo_mdma_enable: Using cached sensor dimensions 1920x1080 (ATOMIC CONTEXT SAFE)
[   32.730960] vic_pipo_mdma_enable: reg 0x308 = 1 (MDMA enable)
[   32.730967] vic_pipo_mdma_enable: reg 0x304 = 0x7800438 (dimensions 1920x1080)
[   32.730973] vic_pipo_mdma_enable: reg 0x310 = 3840 (stride)
[   32.730979] vic_pipo_mdma_enable: reg 0x314 = 3840 (stride)
[   32.730984] *** CRITICAL FIX: Writing buffer addresses to VIC hardware registers ***
[   32.730990] *** CRITICAL: No VBM buffer addresses - using fallback addresses from reserved memory ***
[   32.730997] *** vbm_buffer_addresses=  (null), vbm_buffer_count=0 ***
[   32.731004] *** VIC FALLBACK BUFFER 0: Wrote reserved memory address 0x6300000 to reg 0x318 ***
[   32.731012] *** VIC FALLBACK BUFFER 1: Wrote reserved memory address 0x66f4800 to reg 0x31c ***
[   32.731019] *** VIC FALLBACK BUFFER 2: Wrote reserved memory address 0x6ae9000 to reg 0x320 ***
[   32.731027] *** VIC FALLBACK BUFFER 3: Wrote reserved memory address 0x6edd800 to reg 0x324 ***
[   32.731035] *** VIC FALLBACK BUFFER 4: Wrote reserved memory address 0x72d2000 to reg 0x328 ***
[   32.731040] *** CRITICAL: VIC fallback buffer addresses configured - hardware can now generate interrupts! ***
[   32.731046] *** VIC PIPO MDMA ENABLE COMPLETE - VIC should now generate interrupts! ***
[   32.731052] *** vic_pipo_mdma_enable completed - VIC MDMA should now generate interrupts! ***
[   32.731059] *** Binary Ninja EXACT: Wrote 0x80040020 to reg 0x300 (4 buffers) ***
[   32.731065] *** vic_core_s_stream: CORE W1C [9a70/9a7c] then GATE REASSERT [9ac0/9ac8] ***
[   32.731071] *** vic_core_s_stream: Re-writing buffer addresses AFTER MDMA start ***
[   32.731076] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   32.731083] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   32.731088] *** vic_core_s_stream: Post-MDMA QBUF SUCCESS ***
[   32.731101] *** VIC VERIFY (PRIMARY): [0x0]=0x00000000 [0x4]=0x07800438 [0x300]=0x80040020 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 (UNMASK-ALL)***
[   32.731109] *** VIC VERIFY (PRIMARY EXTRA): [0x100]=0x000002d0 [0x14]=0x00000001 (PRIMARY 0x14=stride) ***
[   32.731173] *** VIC VERIFY (CONTROL): [0x0]=0x00000000 [0x4]=0x00000000 [0x100]=0x00000000 [0x14]=0x00000000 [0x300]=0x00000000 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 ***
[   32.731185] *** VIC BUFS (PRIMARY): [0x318]=0x06300000 [0x31c]=0x066f4800 [0x320]=0x06ae9000 [0x324]=0x06edd800 [0x328]=0x072d2000 ***
[   32.731191] *** VIC CTRL (PRIMARY): [0x300]=0x80040020 ***
[   32.731200] *** VIC BUFS (CONTROL): [0x318]=0x00000000 [0x31c]=0x00000000 [0x320]=0x00000000 [0x324]=0x00000000 [0x328]=0x00000000 ***
[   32.731207] *** VIC CTRL (CONTROL): [0x300]=0x00000000 ***
[   32.731212] *** VIC CONTROL BANK: Re-applying enable sequence on CONTROL bank ***
[   32.731218] *** VIC CONTROL BANK: Post-enable [0x0]=0x00000000 ***
[   32.731225] *** VIC UNMASK-ALL TEST: [0x1e8]=0x00000000 [0x1ec]=0x00000000 (expect 0) ***
[   32.732233] *** VIC UNMASK-ALL TEST: No status bits asserted during pre-IRQ sample ***
[   32.732239] *** VIC MASK: Keeping UNMASK-ALL (0x1e8=0) during debug ***
[   32.732244] *** VIC CONTROL (PRIMARY): WROTE 1 to [0x0] before enabling IRQ ***
[   32.732352] *** VIC PRIMARY ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   32.732459] *** VIC CONTROL ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   32.732467] *** CORE VIC GATE REASSERT: [0x9ac0]=0x00000000 [0x9ac8]=0x00000000 ***
[   32.732472] *** vic_core_s_stream: Enabling VIC IRQ AFTER final re-assert/verify ***
[   32.732477] *** tx_vic_enable_irq: EXACT Binary Ninja implementation from working reference ***
[   32.732483] tx_vic_enable_irq: VIC interrupts enabled (irq_enabled = 1)
[   32.732489] *** tx_vic_enable_irq: CRITICAL FIX - Enabling VIC interrupt (IRQ 38) at kernel level ***
[   32.732497] *** tx_vic_enable_irq: VIC interrupt (IRQ 38) ENABLED at kernel level ***
[   32.732503] tx_vic_enable_irq: VIC interrupt flag set and kernel interrupt enabled
[   32.732509] *** tx_vic_enable_irq: completed successfully ***
[   33.150436] *** VIC POST-IRQ SAMPLE: No status bits asserted in 200ms window ***
[   33.150450] *** vic_core_s_stream: VIC state 2 - letting tx_isp_video_s_stream handle state 2  3 transition ***
[   33.150457] *** vic_core_s_stream: VIC initialized, final state=2 ***
[   33.150494] gc2053: s_stream called with enable=1
[   33.150502] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.150508] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   33.150514] gc2053: About to write streaming registers for interface 1
[   33.150521] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   33.150531] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.150850] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.150858] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.150866] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   33.151185] sensor_write: reg=0x3e val=0x91 SUCCESS
[   33.151192] sensor_write_array: reg[2] 0x3e=0x91 OK
[   33.151198] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.151205] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   33.151211] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   33.151217] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   33.151223] gc2053: s_stream called with enable=1
[   33.151230] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.151236] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   33.151242] gc2053: About to write streaming registers for interface 1
[   33.151248] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   33.151256] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.151570] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.151577] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.151586] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   33.151899] sensor_write: reg=0x3e val=0x91 SUCCESS
[   33.151906] sensor_write_array: reg[2] 0x3e=0x91 OK
[   33.151912] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.151918] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   33.151924] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   33.151930] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   33.330820] ISP M0 device open called from pid 2270
[   33.330850] *** REFERENCE DRIVER IMPLEMENTATION ***
[   33.330858] ISP M0 tuning buffer allocated: 80568000 (size=0x500c, aligned)
[   33.330864] tisp_par_ioctl global variable set: 80568000
[   33.330918] isp_core_tunning_unlocked_ioctl: Auto-initializing tuning for V4L2 control (one-time)
[   33.330926] isp_core_tunning_unlocked_ioctl: Initializing tuning data structure
[   33.330931] isp_core_tuning_init: Initializing tuning data structure
[   33.330949] isp_core_tuning_init: Tuning data structure initialized at 80570000
[   33.330956] isp_core_tuning_init: Structure size: 4356 bytes (vs Binary Ninja 0x40d0)
[   33.330961] *** SAFE: mode_flag properly initialized using struct member access ***
[   33.330968] isp_core_tunning_unlocked_ioctl: Tuning data allocated at 80570000
[   33.330973] *** BINARY NINJA REFERENCE: Skipping auto-initialization - no hardware reset during tuning setup ***
[   33.330979] isp_core_tunning_unlocked_ioctl: ISP tuning auto-enabled for V4L2 controls (permanent)
[   33.330986] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.330993] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   33.330998] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   33.331004] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   33.331010] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   33.331030] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561b
[   33.331038] isp_core_tunning_unlocked_ioctl: Get control cmd=0x980900
[   33.331044] CRITICAL: Cannot access brightness field - PREVENTS BadVA CRASH
[   33.331052] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561b
[   33.331058] isp_core_tunning_unlocked_ioctl: Get control cmd=0x980902
[   33.331065] CRITICAL: Cannot access saturation field at 80570024 - PREVENTING BadVA CRASH
[   33.340556] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.340570] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980901 value=128
[   33.340577] Set control: cmd=0x980901 value=128
[   33.340777] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.340787] isp_core_tunning_unlocked_ioctl: Set control cmd=0x98091b value=128
[   33.340794] Set control: cmd=0x98091b value=128
[   33.341011] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341022] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980902 value=128
[   33.341029] Set control: cmd=0x980902 value=128
[   33.341036] tisp_bcsh_saturation: saturation=128
[   33.341040] tiziano_bcsh_update: Updating BCSH parameters
[   33.341048]   Brightness: 128, Contrast: 128, Saturation: 128, Hue: 0
[   33.341053] tiziano_bcsh_update: BCSH update completed (simplified implementation)
[   33.341186] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341196] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980900 value=128
[   33.341202] Set control: cmd=0x980900 value=128
[   33.341361] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341371] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980901 value=128
[   33.341378] Set control: cmd=0x980901 value=128
[   33.341506] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341516] isp_core_tunning_unlocked_ioctl: Set control cmd=0x98091b value=128
[   33.341522] Set control: cmd=0x98091b value=128
[   33.341641] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341650] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980902 value=128
[   33.341656] Set control: cmd=0x980902 value=128
[   33.341662] tisp_bcsh_saturation: saturation=128
[   33.341668] tiziano_bcsh_update: Updating BCSH parameters
[   33.341675]   Brightness: 128, Contrast: 128, Saturation: 128, Hue: 0
[   33.341680] tiziano_bcsh_update: BCSH update completed (simplified implementation)
[   33.341800] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341809] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980900 value=128
[   33.341816] Set control: cmd=0x980900 value=128
[   33.341941] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.341950] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.341956] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.342086] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.342094] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.342100] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.342220] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.342229] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980914 value=0
[   33.342236] Set control: cmd=0x980914 value=0
[   33.342437] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.342449] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   33.342456] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   33.342461] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   33.342466] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   33.342604] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.342614] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980915 value=0
[   33.342622] Set control: cmd=0x980915 value=0
[   33.342809] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.342820] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.342826] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.342977] ISP IOCTL: cmd=0x800456d3 arg=0x0
[   33.342988] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=0 ***
[   33.342997] *** vin_s_stream: SAFE implementation - sd=85217800, enable=0 ***
[   33.343004] vin_s_stream: VIN state = 4, enable = 0
[   33.343010] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.343018] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.343025] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.343031] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.343037] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   33.343044] *** vin_s_stream: SAFE implementation - sd=85217800, enable=0 ***
[   33.343050] vin_s_stream: VIN state = 3, enable = 0
[   33.343055] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.343062] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.343068] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.343074] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.343080] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   33.343087] *** vic_core_s_stream: BINARY NINJA EXACT - sd=846be000, enable=0 ***
[   33.343093] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=2 ***
[   33.343098] *** vic_core_s_stream: STREAM OFF ***
[   33.343106] gc2053: s_stream called with enable=0
[   33.343114] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.343120] gc2053: *** STOPPING SENSOR HARDWARE STREAMING ***
[   33.343126] gc2053: Writing MIPI stream OFF registers (0x3e=0x00)
[   33.343135] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.343458] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.343466] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.343474] sensor_write: reg=0x3e val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.343793] sensor_write: reg=0x3e val=0x00 SUCCESS
[   33.343800] sensor_write_array: reg[2] 0x3e=0x00 OK
[   33.343807] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.343813] gc2053: Sensor hardware streaming stopped
[   33.343819] gc2053: s_stream called with enable=0
[   33.343826] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.343832] gc2053: *** STOPPING SENSOR HARDWARE STREAMING ***
[   33.343838] gc2053: Writing MIPI stream OFF registers (0x3e=0x00)
[   33.343846] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.344176] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.344183] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.344192] sensor_write: reg=0x3e val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.344506] sensor_write: reg=0x3e val=0x00 SUCCESS
[   33.344513] sensor_write_array: reg[2] 0x3e=0x00 OK
[   33.344519] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.344525] gc2053: Sensor hardware streaming stopped
[   33.344534] ISP IOCTL: cmd=0x800456d1 arg=0x7f9d3c90
[   33.344540] tx_isp_video_link_destroy: Destroying links for config 0
[   33.344548] tx_isp_video_link_destroy: All links destroyed, config reset to -1
[   33.344556] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.344564] isp_core_tunning_unlocked_ioctl: Set control cmd=0x8000164 value=1
[   33.344570] Set control: cmd=0x8000164 value=1
[   33.344578] ISP IOCTL: cmd=0x800456d0 arg=0x7f9d3c90
[   33.344584] TX_ISP_VIDEO_LINK_SETUP: config=0
[   33.344590] TX_ISP_VIDEO_LINK_SETUP: Link config changed from -1 to 0
[   33.344596] TX_ISP_VIDEO_LINK_SETUP: Link config updated to 0
[   33.344603] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   33.344609] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[   33.344614] *** tx_isp_video_link_stream: CRITICAL FIX - Calling activate_module on all subdevs first ***
[   33.344621] *** tx_isp_video_link_stream: Calling activate_module on subdev[2] ***
[   33.344628] *** tx_isp_video_link_stream: activate_module SUCCESS on subdev[2] ***
[   33.344634] *** tx_isp_video_link_stream: All activate_module calls complete ***
[   33.344641] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   33.344647] vin_s_stream: VIN state = 3, enable = 1
[   33.344652] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.344660] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.344666] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.344672] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.344678] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   33.344684] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   33.344690] vin_s_stream: VIN state = 4, enable = 1
[   33.344695] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.344702] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.344708] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.344714] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.344720] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   33.344727] *** vic_core_s_stream: BINARY NINJA EXACT - sd=846be000, enable=1 ***
[   33.344732] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=2 ***
[   33.344738] *** vic_core_s_stream: STREAM ON ***
[   33.344743] *** vic_core_s_stream: EXACT Binary Ninja - State != 4, calling VIC start sequence ***
[   33.344749] *** vic_core_s_stream: SKIPPING tx_vic_disable_irq before VIC start to preserve first frame IRQ ***
[   33.344755] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.344762] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.344768] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.344774] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   33.344780] *** STREAMING: Configuring CPM registers for VIC access ***
[   33.370531] STREAMING: CPM clocks configured for VIC access
[   33.370546] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   33.370552] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   33.370558] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   33.370564] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   33.370570] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   33.370576] *** tx_isp_vic_start: Adding CRITICAL missing VIC configuration registers ***
[   33.370585] *** tx_isp_vic_start: CRITICAL VIC configuration registers written - hardware protection should be prevented ***
[   33.370592] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   33.370599] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   33.370605] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   33.370610] *** VIC unlock: Commands written, checking VIC status register ***
[   33.370617] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   33.370623] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   33.370629] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   33.370634] *** tx_isp_vic_start: CRITICAL FIX - Writing VIC Control register sequence ***
[   33.370640] *** tx_isp_vic_start: VIC processing enabled (0x0=0x1, 0x4=0x1) ***
[   33.370646] *** tx_isp_vic_start: Configuring VIC hardware prerequisites for interrupt registers ***
[   33.370720] read_sensor_dimensions: Successfully read 1920x1080 from /proc/jz/sensor/
[   33.370727] *** VIC DIMENSIONS: Using /proc/jz/sensor/ dimensions 1920x1080 (RELIABLE) ***
[   33.370734] *** VIC REGISTER PROTECTION: SKIPPING interrupt-disrupting registers 0xc, 0x10, 0x14 - VIC interrupts already working ***
[   33.370742] *** VIC HARDWARE PREREQUISITES: Dimensions 1920x1080, stride 3840, MIPI mode 2 ***
[   33.370748] *** VIC INTERRUPT CONFIG: VIC unlock sequence will be completed first, then interrupt config ***
[   33.370755] *** VIC INTERRUPT STATUS CHECK (BEFORE UNLOCK): STATUS=0x00000000, MASK_STATUS=0x00000000 ***
[   33.370761] *** VIC INTERRUPT CONFIG: Using WORKING BRANCH registers (NOT Binary Ninja) ***
[   33.370767] *** VIC INTERRUPT CONFIG: Configuring interrupt masks (WORKING BRANCH) ***
[   33.370773] *** VIC INTERRUPT CONFIG: Configuring ISP control interrupts (WORKING BRANCH) ***
[   33.370779] *** VIC INTERRUPT CONFIG: Applying VIC interrupt system configuration (WORKING BRANCH) ***
[   33.370786] *** VIC PRIMARY: leaving 0x14=stride as-is (readback=0x00000001) ***
[   33.370791] *** VIC INTERRUPT CONFIG: WORKING BRANCH interrupt configuration complete ***
[   33.370797] *** VIC INTERRUPT CONFIG: Mirroring WORKING BRANCH registers to control bank ***
[   33.370804] *** VIC CONTROL VERIFY: 0x0c(IMCR)=0x00000000 (expect 0xb5742249) ***
[   33.370809] *** VIC INTERRUPT CONFIG: Control bank configuration complete ***
[   33.370815] *** ISP CORE INTERRUPT CONFIG: Enabling ISP core interrupt generation (MISSING FROM CURRENT BRANCH) ***
[   33.370822] *** ISP CORE CONFIG: Writing ISP core interrupt registers at VIC start ***
[   33.370828] *** ISP CORE CONFIG: ISP core interrupt registers written (0x30=0xffffffff, 0x10=0x133) ***
[   33.370834] *** ISP CORE: Hardware interrupt generation ENABLED (0x30=0xffffffff, 0x10=0x133) ***
[   33.370839] *** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***
[   33.370846] *** ISP CORE VERIFY: 0x30=0x8fffffff, 0x10=0x00000133 ***
[   33.370852] *** VIC INTERRUPT CONFIG: Starting verification of WORKING BRANCH interrupt registers ***
[   33.370862] *** VIC INTERRUPT CONTROL VERIFY (WORKING BRANCH REGS): 0x04=0x07800438, 0x0c=0x00000001, 0x100=0x000002d0, 0x14=0x00000001 ***
[   33.370868] *** VIC INTERRUPT: Some WORKING BRANCH interrupt register configuration failed ***
[   33.370874] *** VIC INTERRUPT: Expected: 0x04=0x07800438, 0x0c=0xb5742249, 0x100=0x2d0, 0x14=0x2b ***
[   33.370882] *** VIC INTERRUPT: imr_ok=1, imcr_ok=0, config_ok=1, control_ok=0 ***
[   33.370888] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   33.370893] *** tx_isp_vic_start: VIC Control register sequence complete - streaming should start ***
[   33.370899] *** tx_isp_vic_start: VIC should now generate frame done interrupts! ***
[   33.370905] *** tx_isp_vic_start: VIC interrupt will be enabled by tx_vic_enable_irq callback ***
[   33.370911] *** vic_core_s_stream: Forcing ispvic_frame_channel_qbuf to program buffer addresses before MDMA ***
[   33.370918] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   33.370926] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   33.370932] *** vic_core_s_stream: ispvic_frame_channel_qbuf SUCCESS ***
[   33.370938] *** vic_core_s_stream: Calling ispvic_frame_channel_s_stream(ENABLE) to start MDMA before enabling IRQ ***
[   33.370944] *** ispvic_frame_channel_s_stream: EXACT Binary Ninja implementation ***
[   33.370950] ispvic_frame_channel_s_stream: arg1=846be000, arg2=1
[   33.370956] ispvic_frame_channel_s_stream: s0 (vic_dev) = 846be000
[   33.370963] ispvic_frame_channel_s_stream[2441]: streamon
[   33.370970] *** ispvic_frame_channel_s_stream: Checking stream state - current=0, requested=1 ***
[   33.370976] *** ispvic_frame_channel_s_stream: Stream state different - proceeding with streaming setup ***
[   33.370981] *** VIC CONTROL (PRIMARY): WROTE 2 to [0x0] before MDMA/config ***
[   33.370987] *** CRITICAL: Calling vic_pipo_mdma_enable - required for VIC interrupts ***
[   33.370992] *** vic_pipo_mdma_enable: EXACT Binary Ninja MCP implementation ***
[   33.371000] vic_pipo_mdma_enable: Using cached sensor dimensions 1920x1080 (ATOMIC CONTEXT SAFE)
[   33.371006] vic_pipo_mdma_enable: reg 0x308 = 1 (MDMA enable)
[   33.371012] vic_pipo_mdma_enable: reg 0x304 = 0x7800438 (dimensions 1920x1080)
[   33.371018] vic_pipo_mdma_enable: reg 0x310 = 3840 (stride)
[   33.371024] vic_pipo_mdma_enable: reg 0x314 = 3840 (stride)
[   33.371030] *** CRITICAL FIX: Writing buffer addresses to VIC hardware registers ***
[   33.371036] *** CRITICAL: No VBM buffer addresses - using fallback addresses from reserved memory ***
[   33.371042] *** vbm_buffer_addresses=  (null), vbm_buffer_count=0 ***
[   33.371050] *** VIC FALLBACK BUFFER 0: Wrote reserved memory address 0x6300000 to reg 0x318 ***
[   33.371058] *** VIC FALLBACK BUFFER 1: Wrote reserved memory address 0x66f4800 to reg 0x31c ***
[   33.371065] *** VIC FALLBACK BUFFER 2: Wrote reserved memory address 0x6ae9000 to reg 0x320 ***
[   33.371073] *** VIC FALLBACK BUFFER 3: Wrote reserved memory address 0x6edd800 to reg 0x324 ***
[   33.371080] *** VIC FALLBACK BUFFER 4: Wrote reserved memory address 0x72d2000 to reg 0x328 ***
[   33.371086] *** CRITICAL: VIC fallback buffer addresses configured - hardware can now generate interrupts! ***
[   33.371092] *** VIC PIPO MDMA ENABLE COMPLETE - VIC should now generate interrupts! ***
[   33.371098] *** vic_pipo_mdma_enable completed - VIC MDMA should now generate interrupts! ***
[   33.371105] *** Binary Ninja EXACT: Wrote 0x80040020 to reg 0x300 (4 buffers) ***
[   33.371132] *** vic_core_s_stream: CORE W1C [9a70/9a7c] then GATE REASSERT [9ac0/9ac8] ***
[   33.371140] *** vic_core_s_stream: Re-writing buffer addresses AFTER MDMA start ***
[   33.371145] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   33.371152] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   33.371158] *** vic_core_s_stream: Post-MDMA QBUF SUCCESS ***
[   33.371170] *** VIC VERIFY (PRIMARY): [0x0]=0x00000000 [0x4]=0x07800438 [0x300]=0x80040020 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 (UNMASK-ALL)***
[   33.371179] *** VIC VERIFY (PRIMARY EXTRA): [0x100]=0x000002d0 [0x14]=0x00000001 (PRIMARY 0x14=stride) ***
[   33.371243] *** VIC VERIFY (CONTROL): [0x0]=0x00000000 [0x4]=0x00000000 [0x100]=0x00000000 [0x14]=0x00000000 [0x300]=0x00000000 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 ***
[   33.371255] *** VIC BUFS (PRIMARY): [0x318]=0x06300000 [0x31c]=0x066f4800 [0x320]=0x06ae9000 [0x324]=0x06edd800 [0x328]=0x072d2000 ***
[   33.371261] *** VIC CTRL (PRIMARY): [0x300]=0x80040020 ***
[   33.371270] *** VIC BUFS (CONTROL): [0x318]=0x00000000 [0x31c]=0x00000000 [0x320]=0x00000000 [0x324]=0x00000000 [0x328]=0x00000000 ***
[   33.371276] *** VIC CTRL (CONTROL): [0x300]=0x00000000 ***
[   33.371282] *** VIC CONTROL BANK: Re-applying enable sequence on CONTROL bank ***
[   33.371288] *** VIC CONTROL BANK: Post-enable [0x0]=0x00000000 ***
[   33.371296] *** VIC UNMASK-ALL TEST: [0x1e8]=0x00000000 [0x1ec]=0x00000000 (expect 0) ***
[   33.372304] *** VIC UNMASK-ALL TEST: No status bits asserted during pre-IRQ sample ***
[   33.372309] *** VIC MASK: Keeping UNMASK-ALL (0x1e8=0) during debug ***
[   33.372314] *** VIC CONTROL (PRIMARY): WROTE 1 to [0x0] before enabling IRQ ***
[   33.372422] *** VIC PRIMARY ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   33.372530] *** VIC CONTROL ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   33.372537] *** CORE VIC GATE REASSERT: [0x9ac0]=0x00000000 [0x9ac8]=0x00000000 ***
[   33.372543] *** vic_core_s_stream: Enabling VIC IRQ AFTER final re-assert/verify ***
[   33.372548] *** tx_vic_enable_irq: EXACT Binary Ninja implementation from working reference ***
[   33.372554] tx_vic_enable_irq: VIC interrupts enabled (irq_enabled = 1)
[   33.372560] *** tx_vic_enable_irq: CRITICAL FIX - Enabling VIC interrupt (IRQ 38) at kernel level ***
[   33.372568] *** tx_vic_enable_irq: VIC interrupt (IRQ 38) ENABLED at kernel level ***
[   33.372574] tx_vic_enable_irq: VIC interrupt flag set and kernel interrupt enabled
[   33.372579] *** tx_vic_enable_irq: completed successfully ***
root@ing-wyze-cam3-a000 ~# [INFO:WS.cpp]: Server started on port 8089
set jpeg streamMngCtx suceess
root@ing-wyze-cam3-a000 ~# dmesg [INFO:RTSP.cpp]: stream 0 available at: rtsp://192.168.50.211/ch0
[INFO:RTSP.cpp]: stream 1 available at: rtsp://192.168.50.211/ch1

[   33.341680] tiziano_bcsh_update: BCSH update completed (simplified implementation)
[   33.341800] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.341809] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980900 value=128
[   33.341816] Set control: cmd=0x980900 value=128
[   33.341941] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.341950] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.341956] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.342086] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.342094] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.342100] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.342220] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.342229] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980914 value=0
[   33.342236] Set control: cmd=0x980914 value=0
[   33.342437] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.342449] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   33.342456] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   33.342461] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   33.342466] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   33.342604] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.342614] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980915 value=0
[   33.342622] Set control: cmd=0x980915 value=0
[   33.342809] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.342820] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.342826] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.342977] ISP IOCTL: cmd=0x800456d3 arg=0x0
[   33.342988] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=0 ***
[   33.342997] *** vin_s_stream: SAFE implementation - sd=85217800, enable=0 ***
[   33.343004] vin_s_stream: VIN state = 4, enable = 0
[   33.343010] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.343018] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.343025] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.343031] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.343037] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   33.343044] *** vin_s_stream: SAFE implementation - sd=85217800, enable=0 ***
[   33.343050] vin_s_stream: VIN state = 3, enable = 0
[   33.343055] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.343062] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.343068] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.343074] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.343080] vin_s_stream: VIN state set to 3 (SAFE implementation)
[   33.343087] *** vic_core_s_stream: BINARY NINJA EXACT - sd=846be000, enable=0 ***
[   33.343093] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=2 ***
[   33.343098] *** vic_core_s_stream: STREAM OFF ***
[   33.343106] gc2053: s_stream called with enable=0
[   33.343114] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.343120] gc2053: *** STOPPING SENSOR HARDWARE STREAMING ***
[   33.343126] gc2053: Writing MIPI stream OFF registers (0x3e=0x00)
[   33.343135] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.343458] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.343466] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.343474] sensor_write: reg=0x3e val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.343793] sensor_write: reg=0x3e val=0x00 SUCCESS
[   33.343800] sensor_write_array: reg[2] 0x3e=0x00 OK
[   33.343807] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.343813] gc2053: Sensor hardware streaming stopped
[   33.343819] gc2053: s_stream called with enable=0
[   33.343826] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.343832] gc2053: *** STOPPING SENSOR HARDWARE STREAMING ***
[   33.343838] gc2053: Writing MIPI stream OFF registers (0x3e=0x00)
[   33.343846] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.344176] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.344183] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.344192] sensor_write: reg=0x3e val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.344506] sensor_write: reg=0x3e val=0x00 SUCCESS
[   33.344513] sensor_write_array: reg[2] 0x3e=0x00 OK
[   33.344519] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.344525] gc2053: Sensor hardware streaming stopped
[   33.344534] ISP IOCTL: cmd=0x800456d1 arg=0x7f9d3c90
[   33.344540] tx_isp_video_link_destroy: Destroying links for config 0
[   33.344548] tx_isp_video_link_destroy: All links destroyed, config reset to -1
[   33.344556] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.344564] isp_core_tunning_unlocked_ioctl: Set control cmd=0x8000164 value=1
[   33.344570] Set control: cmd=0x8000164 value=1
[   33.344578] ISP IOCTL: cmd=0x800456d0 arg=0x7f9d3c90
[   33.344584] TX_ISP_VIDEO_LINK_SETUP: config=0
[   33.344590] TX_ISP_VIDEO_LINK_SETUP: Link config changed from -1 to 0
[   33.344596] TX_ISP_VIDEO_LINK_SETUP: Link config updated to 0
[   33.344603] ISP IOCTL: cmd=0x800456d2 arg=0x0
[   33.344609] *** tx_isp_video_link_stream: EXACT Binary Ninja MCP implementation - enable=1 ***
[   33.344614] *** tx_isp_video_link_stream: CRITICAL FIX - Calling activate_module on all subdevs first ***
[   33.344621] *** tx_isp_video_link_stream: Calling activate_module on subdev[2] ***
[   33.344628] *** tx_isp_video_link_stream: activate_module SUCCESS on subdev[2] ***
[   33.344634] *** tx_isp_video_link_stream: All activate_module calls complete ***
[   33.344641] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   33.344647] vin_s_stream: VIN state = 3, enable = 1
[   33.344652] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.344660] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.344666] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.344672] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.344678] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   33.344684] *** vin_s_stream: SAFE implementation - sd=85217800, enable=1 ***
[   33.344690] vin_s_stream: VIN state = 4, enable = 1
[   33.344695] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.344702] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.344708] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.344714] vin_s_stream: VIN processing complete - sensor will be handled by core loop
[   33.344720] vin_s_stream: VIN state set to 4 (SAFE implementation)
[   33.344727] *** vic_core_s_stream: BINARY NINJA EXACT - sd=846be000, enable=1 ***
[   33.344732] *** vic_core_s_stream: BINARY NINJA EXACT - current_state=2 ***
[   33.344738] *** vic_core_s_stream: STREAM ON ***
[   33.344743] *** vic_core_s_stream: EXACT Binary Ninja - State != 4, calling VIC start sequence ***
[   33.344749] *** vic_core_s_stream: SKIPPING tx_vic_disable_irq before VIC start to preserve first frame IRQ ***
[   33.344755] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   33.344762] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   33.344768] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   33.344774] *** tx_isp_vic_start: Using single VIC register base - EXACT Binary Ninja reference ***
[   33.344780] *** STREAMING: Configuring CPM registers for VIC access ***
[   33.370531] STREAMING: CPM clocks configured for VIC access
[   33.370546] *** tx_isp_vic_start: CRITICAL DEBUG - interface_type=1, checking if == 1 ***
[   33.370552] *** tx_isp_vic_start: MIPI interface detected - configuring VIC for MIPI ***
[   33.370558] *** tx_isp_vic_start: vic_dev->width=1920, vic_dev->height=1080 ***
[   33.370564] *** tx_isp_vic_start: sensor_mode != interface_type, writing 0xa000a to 0x1a4 ***
[   33.370570] *** tx_isp_vic_start: Writing VIC configuration registers - EXACT Binary Ninja sequence ***
[   33.370576] *** tx_isp_vic_start: Adding CRITICAL missing VIC configuration registers ***
[   33.370585] *** tx_isp_vic_start: CRITICAL VIC configuration registers written - hardware protection should be prevented ***
[   33.370592] *** tx_isp_vic_start: Frame size 0x07800438 written to register 0x4 ***
[   33.370599] *** tx_isp_vic_start: VIC unlock sequence using SECONDARY VIC space (0x10023000) ***
[   33.370605] *** tx_isp_vic_start: VIC unlock sequence - FIXED register space issue ***
[   33.370610] *** VIC unlock: Commands written, checking VIC status register ***
[   33.370617] *** VIC unlock: Completed with final status=0x0 after 0 iterations ***
[   33.370623] *** tx_isp_vic_start: VIC unlock completed using SECONDARY VIC space ***
[   33.370629] *** tx_isp_vic_start: VIC enabled using SECONDARY VIC space ***
[   33.370634] *** tx_isp_vic_start: CRITICAL FIX - Writing VIC Control register sequence ***
[   33.370640] *** tx_isp_vic_start: VIC processing enabled (0x0=0x1, 0x4=0x1) ***
[   33.370646] *** tx_isp_vic_start: Configuring VIC hardware prerequisites for interrupt registers ***
[   33.370720] read_sensor_dimensions: Successfully read 1920x1080 from /proc/jz/sensor/
[   33.370727] *** VIC DIMENSIONS: Using /proc/jz/sensor/ dimensions 1920x1080 (RELIABLE) ***
[   33.370734] *** VIC REGISTER PROTECTION: SKIPPING interrupt-disrupting registers 0xc, 0x10, 0x14 - VIC interrupts already working ***
[   33.370742] *** VIC HARDWARE PREREQUISITES: Dimensions 1920x1080, stride 3840, MIPI mode 2 ***
[   33.370748] *** VIC INTERRUPT CONFIG: VIC unlock sequence will be completed first, then interrupt config ***
[   33.370755] *** VIC INTERRUPT STATUS CHECK (BEFORE UNLOCK): STATUS=0x00000000, MASK_STATUS=0x00000000 ***
[   33.370761] *** VIC INTERRUPT CONFIG: Using WORKING BRANCH registers (NOT Binary Ninja) ***
[   33.370767] *** VIC INTERRUPT CONFIG: Configuring interrupt masks (WORKING BRANCH) ***
[   33.370773] *** VIC INTERRUPT CONFIG: Configuring ISP control interrupts (WORKING BRANCH) ***
[   33.370779] *** VIC INTERRUPT CONFIG: Applying VIC interrupt system configuration (WORKING BRANCH) ***
[   33.370786] *** VIC PRIMARY: leaving 0x14=stride as-is (readback=0x00000001) ***
[   33.370791] *** VIC INTERRUPT CONFIG: WORKING BRANCH interrupt configuration complete ***
[   33.370797] *** VIC INTERRUPT CONFIG: Mirroring WORKING BRANCH registers to control bank ***
[   33.370804] *** VIC CONTROL VERIFY: 0x0c(IMCR)=0x00000000 (expect 0xb5742249) ***
[   33.370809] *** VIC INTERRUPT CONFIG: Control bank configuration complete ***
[   33.370815] *** ISP CORE INTERRUPT CONFIG: Enabling ISP core interrupt generation (MISSING FROM CURRENT BRANCH) ***
[   33.370822] *** ISP CORE CONFIG: Writing ISP core interrupt registers at VIC start ***
[   33.370828] *** ISP CORE CONFIG: ISP core interrupt registers written (0x30=0xffffffff, 0x10=0x133) ***
[   33.370834] *** ISP CORE: Hardware interrupt generation ENABLED (0x30=0xffffffff, 0x10=0x133) ***
[   33.370839] *** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***
[   33.370846] *** ISP CORE VERIFY: 0x30=0x8fffffff, 0x10=0x00000133 ***
[   33.370852] *** VIC INTERRUPT CONFIG: Starting verification of WORKING BRANCH interrupt registers ***
[   33.370862] *** VIC INTERRUPT CONTROL VERIFY (WORKING BRANCH REGS): 0x04=0x07800438, 0x0c=0x00000001, 0x100=0x000002d0, 0x14=0x00000001 ***
[   33.370868] *** VIC INTERRUPT: Some WORKING BRANCH interrupt register configuration failed ***
[   33.370874] *** VIC INTERRUPT: Expected: 0x04=0x07800438, 0x0c=0xb5742249, 0x100=0x2d0, 0x14=0x2b ***
[   33.370882] *** VIC INTERRUPT: imr_ok=1, imcr_ok=0, config_ok=1, control_ok=0 ***
[   33.370888] *** tx_isp_vic_start: vic_start_ok set to 1 - EXACT Binary Ninja reference ***
[   33.370893] *** tx_isp_vic_start: VIC Control register sequence complete - streaming should start ***
[   33.370899] *** tx_isp_vic_start: VIC should now generate frame done interrupts! ***
[   33.370905] *** tx_isp_vic_start: VIC interrupt will be enabled by tx_vic_enable_irq callback ***
[   33.370911] *** vic_core_s_stream: Forcing ispvic_frame_channel_qbuf to program buffer addresses before MDMA ***
[   33.370918] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   33.370926] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   33.370932] *** vic_core_s_stream: ispvic_frame_channel_qbuf SUCCESS ***
[   33.370938] *** vic_core_s_stream: Calling ispvic_frame_channel_s_stream(ENABLE) to start MDMA before enabling IRQ ***
[   33.370944] *** ispvic_frame_channel_s_stream: EXACT Binary Ninja implementation ***
[   33.370950] ispvic_frame_channel_s_stream: arg1=846be000, arg2=1
[   33.370956] ispvic_frame_channel_s_stream: s0 (vic_dev) = 846be000
[   33.370963] ispvic_frame_channel_s_stream[2441]: streamon
[   33.370970] *** ispvic_frame_channel_s_stream: Checking stream state - current=0, requested=1 ***
[   33.370976] *** ispvic_frame_channel_s_stream: Stream state different - proceeding with streaming setup ***
[   33.370981] *** VIC CONTROL (PRIMARY): WROTE 2 to [0x0] before MDMA/config ***
[   33.370987] *** CRITICAL: Calling vic_pipo_mdma_enable - required for VIC interrupts ***
[   33.370992] *** vic_pipo_mdma_enable: EXACT Binary Ninja MCP implementation ***
[   33.371000] vic_pipo_mdma_enable: Using cached sensor dimensions 1920x1080 (ATOMIC CONTEXT SAFE)
[   33.371006] vic_pipo_mdma_enable: reg 0x308 = 1 (MDMA enable)
[   33.371012] vic_pipo_mdma_enable: reg 0x304 = 0x7800438 (dimensions 1920x1080)
[   33.371018] vic_pipo_mdma_enable: reg 0x310 = 3840 (stride)
[   33.371024] vic_pipo_mdma_enable: reg 0x314 = 3840 (stride)
[   33.371030] *** CRITICAL FIX: Writing buffer addresses to VIC hardware registers ***
[   33.371036] *** CRITICAL: No VBM buffer addresses - using fallback addresses from reserved memory ***
[   33.371042] *** vbm_buffer_addresses=  (null), vbm_buffer_count=0 ***
[   33.371050] *** VIC FALLBACK BUFFER 0: Wrote reserved memory address 0x6300000 to reg 0x318 ***
[   33.371058] *** VIC FALLBACK BUFFER 1: Wrote reserved memory address 0x66f4800 to reg 0x31c ***
[   33.371065] *** VIC FALLBACK BUFFER 2: Wrote reserved memory address 0x6ae9000 to reg 0x320 ***
[   33.371073] *** VIC FALLBACK BUFFER 3: Wrote reserved memory address 0x6edd800 to reg 0x324 ***
[   33.371080] *** VIC FALLBACK BUFFER 4: Wrote reserved memory address 0x72d2000 to reg 0x328 ***
[   33.371086] *** CRITICAL: VIC fallback buffer addresses configured - hardware can now generate interrupts! ***
[   33.371092] *** VIC PIPO MDMA ENABLE COMPLETE - VIC should now generate interrupts! ***
[   33.371098] *** vic_pipo_mdma_enable completed - VIC MDMA should now generate interrupts! ***
[   33.371105] *** Binary Ninja EXACT: Wrote 0x80040020 to reg 0x300 (4 buffers) ***
[   33.371132] *** vic_core_s_stream: CORE W1C [9a70/9a7c] then GATE REASSERT [9ac0/9ac8] ***
[   33.371140] *** vic_core_s_stream: Re-writing buffer addresses AFTER MDMA start ***
[   33.371145] *** ispvic_frame_channel_qbuf: EXACT Binary Ninja MCP implementation ***
[   33.371152] ispvic_frame_channel_qbuf: arg1=846be000, arg2=  (null)
[   33.371158] *** vic_core_s_stream: Post-MDMA QBUF SUCCESS ***
[   33.371170] *** VIC VERIFY (PRIMARY): [0x0]=0x00000000 [0x4]=0x07800438 [0x300]=0x80040020 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 (UNMASK-ALL)***
[   33.371179] *** VIC VERIFY (PRIMARY EXTRA): [0x100]=0x000002d0 [0x14]=0x00000001 (PRIMARY 0x14=stride) ***
[   33.371243] *** VIC VERIFY (CONTROL): [0x0]=0x00000000 [0x4]=0x00000000 [0x100]=0x00000000 [0x14]=0x00000000 [0x300]=0x00000000 [0x30c]=0x00000000 [0x1e0]=0x00000000 [0x1e4]=0x00000000 [0x1e8]=0x00000000 [0x1ec]=0x00000000 ***
[   33.371255] *** VIC BUFS (PRIMARY): [0x318]=0x06300000 [0x31c]=0x066f4800 [0x320]=0x06ae9000 [0x324]=0x06edd800 [0x328]=0x072d2000 ***
[   33.371261] *** VIC CTRL (PRIMARY): [0x300]=0x80040020 ***
[   33.371270] *** VIC BUFS (CONTROL): [0x318]=0x00000000 [0x31c]=0x00000000 [0x320]=0x00000000 [0x324]=0x00000000 [0x328]=0x00000000 ***
[   33.371276] *** VIC CTRL (CONTROL): [0x300]=0x00000000 ***
[   33.371282] *** VIC CONTROL BANK: Re-applying enable sequence on CONTROL bank ***
[   33.371288] *** VIC CONTROL BANK: Post-enable [0x0]=0x00000000 ***
[   33.371296] *** VIC UNMASK-ALL TEST: [0x1e8]=0x00000000 [0x1ec]=0x00000000 (expect 0) ***
[   33.372304] *** VIC UNMASK-ALL TEST: No status bits asserted during pre-IRQ sample ***
[   33.372309] *** VIC MASK: Keeping UNMASK-ALL (0x1e8=0) during debug ***
[   33.372314] *** VIC CONTROL (PRIMARY): WROTE 1 to [0x0] before enabling IRQ ***
[   33.372422] *** VIC PRIMARY ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   33.372530] *** VIC CONTROL ENABLES (POST-RUN COMMIT): [0x1e0]=0x00000000 [0x1e4]=0x00000000 ***
[   33.372537] *** CORE VIC GATE REASSERT: [0x9ac0]=0x00000000 [0x9ac8]=0x00000000 ***
[   33.372543] *** vic_core_s_stream: Enabling VIC IRQ AFTER final re-assert/verify ***
[   33.372548] *** tx_vic_enable_irq: EXACT Binary Ninja implementation from working reference ***
[   33.372554] tx_vic_enable_irq: VIC interrupts enabled (irq_enabled = 1)
[   33.372560] *** tx_vic_enable_irq: CRITICAL FIX - Enabling VIC interrupt (IRQ 38) at kernel level ***
[   33.372568] *** tx_vic_enable_irq: VIC interrupt (IRQ 38) ENABLED at kernel level ***
[   33.372574] tx_vic_enable_irq: VIC interrupt flag set and kernel interrupt enabled
[   33.372579] *** tx_vic_enable_irq: completed successfully ***
[   33.786611] *** VIC POST-IRQ SAMPLE: No status bits asserted in 200ms window ***
[   33.786626] *** vic_core_s_stream: VIC state 2 - letting tx_isp_video_s_stream handle state 2  3 transition ***
[   33.786632] *** vic_core_s_stream: VIC initialized, final state=2 ***
[   33.786643] gc2053: s_stream called with enable=1
[   33.786651] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.786657] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   33.786663] gc2053: About to write streaming registers for interface 1
[   33.786669] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   33.786679] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.786999] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.787006] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.787015] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   33.797507] sensor_write: reg=0x3e val=0x91 SUCCESS
[   33.797521] sensor_write_array: reg[2] 0x3e=0x91 OK
[   33.797527] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.797535] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   33.797541] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   33.797547] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   33.797555] gc2053: s_stream called with enable=1
[   33.797561] gc2053: module data_interface=1, sensor data_interface=1 (1=MIPI, 2=DVP)
[   33.797567] gc2053: *** STARTING SENSOR HARDWARE STREAMING ***
[   33.797573] gc2053: About to write streaming registers for interface 1
[   33.797579] gc2053: *** WRITING MIPI STREAM ON REGISTERS - INCLUDING 0x3e=0x91 ***
[   33.797589] sensor_write: reg=0xfe val=0x00, client=854ccb00, adapter=i2c0, addr=0x37
[   33.797907] sensor_write: reg=0xfe val=0x00 SUCCESS
[   33.797915] sensor_write_array: reg[1] 0xfe=0x00 OK
[   33.797923] sensor_write: reg=0x3e val=0x91, client=854ccb00, adapter=i2c0, addr=0x37
[   33.798241] sensor_write: reg=0x3e val=0x91 SUCCESS
[   33.798248] sensor_write_array: reg[2] 0x3e=0x91 OK
[   33.798255] sensor_write_array: Complete - wrote 2 registers, 0 errors
[   33.798261] gc2053: *** MIPI STREAM ON REGISTER WRITE COMPLETE, ret=0 ***
[   33.798267] gc2053: *** STREAMING REGISTERS WRITTEN SUCCESSFULLY ***
[   33.798273] gc2053: CRITICAL: 0x3e=0x91 should now be written - sensor outputting MIPI data
[   33.798511] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc008561c
[   33.798523] isp_core_tunning_unlocked_ioctl: Set control cmd=0x980918 value=2
[   33.798530] Set control: cmd=0x980918 value=2
[   33.798676] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.798686] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.798692] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.798824] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.798833] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.798839] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.798956] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.798965] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.798971] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.799081] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.799089] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.799095] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.799239] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.799249] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.799255] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.799372] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.799381] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.799387] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.799511] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.799520] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.799526] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.799649] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.799657] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.799663] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.799871] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.799879] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.799885] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   33.800015] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   33.800023] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: DISABLE
[   33.800029] *** BINARY NINJA REFERENCE: Tuning disable - no hardware reset performed ***
[   34.097560] *** FRAME CHANNEL OPEN: minor=54 ***
[   34.097572] *** FRAME CHANNEL OPEN: Device not in array, creating new entry for minor 54 ***
[   34.097579] *** FRAME CHANNEL OPEN: Assigned to channel 0 ***
[   34.097585] *** FRAME CHANNEL 0: State set to 3 (ready for streaming) - Binary Ninja EXACT ***
[   34.097591] *** SAFE: Frame channel device stored in file->private_data ***
[   34.097597] *** FRAME CHANNEL 0 OPENED SUCCESSFULLY - NOW READY FOR IOCTLS ***
[   34.097605] Channel 0: Format 1920x1080, pixfmt=0x32315659, minor=54
[   34.097623] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc07056c3 ***
[   34.097631] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc07056c3 ***
[   34.097639] Channel 0: Set format 1920x1080 pixfmt=0x3231564e
[   34.098235] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0145608 ***
[   34.098246] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0145608 ***
[   34.098253] *** Channel 0: REQBUFS - MEMORY-AWARE implementation ***
[   34.098260] Channel 0: Request 4 buffers, type=1 memory=2
[   34.098266] Channel 0: USERPTR mode - client will provide buffers
[   34.098272] Channel 0: USERPTR mode - 4 user buffers expected
[   34.098282] *** Channel 0: REQBUFS allocated VBM buffer array for 4 buffers at 805ee380 ***
[   34.098289] *** Channel 0: VIC active_buffer_count set to 4 ***
[   34.098295] *** REQBUFS: VIC DMA will be configured during streaming via vic_pipo_mdma_enable ***
[   34.098301] *** Channel 0: MEMORY-AWARE REQBUFS SUCCESS - 4 buffers ***
[   34.098325] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.098333] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.098339] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.098345] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.098353] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.098360] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   34.098367] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.098374] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   34.098381] *** Channel 0: QBUF - Queue buffer index=0 ***
[   34.098387] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.098394] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   34.098401] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.098407] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.098414] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   34.098422] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   34.098430] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=1 ***
[   34.098438] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=1 ***
[   34.098445] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   34.098451] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   34.098459] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.098469] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.098475] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.098481] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.098488] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.098495] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.098503] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   34.098509] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.098516] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   34.098523] *** Channel 0: QBUF - Queue buffer index=1 ***
[   34.098529] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.098535] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   34.098541] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.098547] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.098554] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   34.098562] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   34.098569] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=2 ***
[   34.098577] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=2 ***
[   34.098584] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   34.098591] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   34.098597] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.098605] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.098612] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.098618] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.098624] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.098631] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   34.098638] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   34.098645] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.098652] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   34.098659] *** Channel 0: QBUF - Queue buffer index=2 ***
[   34.098664] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   34.098671] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   34.098677] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.098683] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.098690] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   34.098697] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   34.098705] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=3 ***
[   34.098713] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=3 ***
[   34.098719] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   34.098726] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   34.098733] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.098741] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.098747] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.098753] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.098759] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.098767] *** Channel 0: QBUF - Buffer received: index=3, type=1, memory=2 ***
[   34.098774] *** Channel 0: QBUF - Buffer m.offset=0x79d0000, m.userptr=0x79d0000 ***
[   34.098781] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.098788] *** Channel 0: QBUF - Validation: buffer.index=3, state->buffer_count=4 ***
[   34.098795] *** Channel 0: QBUF - Queue buffer index=3 ***
[   34.098800] *** QBUF: No buffer allocated for index 3 - VBM initialization mode ***
[   34.098807] *** Channel 0: QBUF - Using buffer struct   (null) for index 3 ***
[   34.098813] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.098819] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.098826] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x79d0000 ***
[   34.098833] *** Channel 0: QBUF - Buffer 3: phys_addr=0x79d0000, size=4147200 (VALIDATED) ***
[   34.098841] *** Channel 0: QBUF VBM - Stored buffer[3] = 0x79d0000, total_count=4 ***
[   34.098849] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.098855] *** Channel 0: QBUF - VBM buffer slot[3] available ***
[   34.098862] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x79d0000 ***
[   34.098868] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.098957] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x80045612 ***
[   34.098968] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x80045612 ***
[   34.098975] *** Channel 0: VIDIOC_STREAMON - Binary Ninja implementation ***
[   34.098981] Channel 0: STREAMON - Enqueuing buffers in driver
[   34.098987] *** Channel 0: STREAMON - Core device is stateless, only managing streaming flag ***
[   34.100371] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.100384] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.100391] *** Channel 0: Frame completion wait ***
[   34.100397] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.100403] *** Channel 0: Frame wait returned 10 ***
[   34.100409] *** Channel 0: Frame was ready, consuming it ***
[   34.100513] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.100521] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.100579] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.100587] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.100597] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.100604] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.100611] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.100634] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.100642] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.100648] *** Channel 0: Frame completion wait ***
[   34.100653] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.161712] *** FRAME CHANNEL OPEN: minor=53 ***
[   34.161724] *** FRAME CHANNEL OPEN: Device not in array, creating new entry for minor 53 ***
[   34.161731] *** FRAME CHANNEL OPEN: Assigned to channel 1 ***
[   34.161738] *** FRAME CHANNEL 1: State set to 3 (ready for streaming) - Binary Ninja EXACT ***
[   34.161743] *** SAFE: Frame channel device stored in file->private_data ***
[   34.161749] *** FRAME CHANNEL 1 OPENED SUCCESSFULLY - NOW READY FOR IOCTLS ***
[   34.161757] Channel 1: Format 640x360, pixfmt=0x32315659, minor=53
[   34.161775] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc07056c3 ***
[   34.161783] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc07056c3 ***
[   34.161791] Channel 1: Set format 640x360 pixfmt=0x3231564e
[   34.162638] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0145608 ***
[   34.162650] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0145608 ***
[   34.162656] *** Channel 1: REQBUFS - MEMORY-AWARE implementation ***
[   34.162664] Channel 1: Request 2 buffers, type=1 memory=2
[   34.162670] Channel 1: USERPTR mode - client will provide buffers
[   34.162676] Channel 1: USERPTR mode - 2 user buffers expected
[   34.162686] *** Channel 1: REQBUFS allocated VBM buffer array for 2 buffers at 805ee600 ***
[   34.162693] *** Channel 1: VIC active_buffer_count set to 2 ***
[   34.162698] *** REQBUFS: VIC DMA will be configured during streaming via vic_pipo_mdma_enable ***
[   34.162705] *** Channel 1: MEMORY-AWARE REQBUFS SUCCESS - 2 buffers ***
[   34.162719] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.162726] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.162732] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.162738] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.162746] *** Channel 1: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.162753] *** Channel 1: QBUF - Buffer m.offset=0x7e07100, m.userptr=0x7e07100 ***
[   34.162760] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.162767] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   34.162774] *** Channel 1: QBUF - Queue buffer index=0 ***
[   34.162780] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.162787] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   34.162794] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   34.162802] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   34.162810] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=1 ***
[   34.162818] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=1 ***
[   34.162825] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   34.162832] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   34.162839] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.162849] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.162856] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.162862] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.162868] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.162874] *** Channel 1: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.162882] *** Channel 1: QBUF - Buffer m.offset=0x7e5d500, m.userptr=0x7e5d500 ***
[   34.162889] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.162896] *** Channel 1: QBUF - Validation: buffer.index=1, state->buffer_count=2 ***
[   34.162902] *** Channel 1: QBUF - Queue buffer index=1 ***
[   34.162908] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.162915] *** Channel 1: QBUF - Using buffer struct   (null) for index 1 ***
[   34.162922] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e5d500 ***
[   34.162930] *** Channel 1: QBUF - Buffer 1: phys_addr=0x7e5d500, size=460800 (VALIDATED) ***
[   34.162938] *** Channel 1: QBUF VBM - Stored buffer[1] = 0x7e5d500, total_count=2 ***
[   34.162945] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.162952] *** Channel 1: QBUF - VBM buffer slot[1] available ***
[   34.162958] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e5d500 ***
[   34.162965] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.163056] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x80045612 ***
[   34.163066] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x80045612 ***
[   34.163073] *** Channel 1: VIDIOC_STREAMON - Binary Ninja implementation ***
[   34.163079] Channel 1: STREAMON - Enqueuing buffers in driver
[   34.163086] *** Channel 1: STREAMON - Core device is stateless, only managing streaming flag ***
[   34.170616] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.170630] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.170637] *** Channel 1: Frame completion wait ***
[   34.170643] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.170649] *** Channel 1: Frame wait returned 10 ***
[   34.170655] *** Channel 1: Frame was ready, consuming it ***
[   34.170719] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.170727] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.170734] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.170740] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.170750] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.170756] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.170763] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.170778] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.170785] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.170791] *** Channel 1: Frame completion wait ***
[   34.170796] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.200567] *** Channel 0: Frame wait returned 0 ***
[   34.200578] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.200599] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.200607] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.200613] *** Channel 0: Frame completion wait ***
[   34.200619] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.200625] *** Channel 0: Frame wait returned 10 ***
[   34.200630] *** Channel 0: Frame was ready, consuming it ***
[   34.200638] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.200645] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.200650] *** Channel 0: Frame completion wait ***
[   34.200656] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.270626] *** Channel 1: Frame wait returned 0 ***
[   34.270638] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.270659] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.270667] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.270673] *** Channel 1: Frame completion wait ***
[   34.270678] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.270685] *** Channel 1: Frame wait returned 10 ***
[   34.270690] *** Channel 1: Frame was ready, consuming it ***
[   34.270698] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.270704] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.270710] *** Channel 1: Frame completion wait ***
[   34.270716] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.300588] *** Channel 0: DQBUF wait returned 0 ***
[   34.300600] *** Channel 0: DQBUF timeout, generating frame ***
[   34.300609] *** Channel 0: DQBUF complete - buffer[0] seq=-1 flags=0x3 ***
[   34.300648] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.300656] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.300662] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.300668] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.300674] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.300798] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.300808] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.300815] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.300821] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.300831] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.300838] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.300844] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.300862] *** Channel 0: Frame wait returned 0 ***
[   34.300869] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.300880] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.300887] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.300894] *** Channel 0: Frame completion wait ***
[   34.300899] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.300906] *** Channel 0: Frame wait returned 10 ***
[   34.300911] *** Channel 0: Frame was ready, consuming it ***
[   34.300918] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.300925] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.300931] *** Channel 0: Frame completion wait ***
[   34.300936] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.310688] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.310702] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.310709] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.310716] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.310723] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.310730] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   34.310737] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.310744] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   34.310750] *** Channel 0: QBUF - Queue buffer index=0 ***
[   34.310756] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.310764] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   34.310771] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.310778] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.310784] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   34.310792] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   34.310800] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   34.310808] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.310815] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   34.310822] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   34.310834] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.310919] *** Channel 0: Frame wait returned 9 ***
[   34.310926] *** Channel 0: Frame was ready, consuming it ***
[   34.310939] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.310946] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.310952] *** Channel 0: Frame completion wait ***
[   34.310958] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.370586] *** Channel 1: DQBUF wait returned 0 ***
[   34.370598] *** Channel 1: DQBUF timeout, generating frame ***
[   34.370607] *** Channel 1: DQBUF complete - buffer[0] seq=-1 flags=0x3 ***
[   34.370719] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.370728] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.370734] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.370740] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.370751] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.370758] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.370764] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.370782] *** Channel 1: Frame wait returned 0 ***
[   34.370789] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.370800] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.370808] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.370814] *** Channel 1: Frame completion wait ***
[   34.370820] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.370826] *** Channel 1: Frame wait returned 10 ***
[   34.370831] *** Channel 1: Frame was ready, consuming it ***
[   34.370839] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.370846] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.370851] *** Channel 1: Frame completion wait ***
[   34.370856] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.406814] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.406827] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.406834] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.406839] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.406844] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.408708] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.408722] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.408744] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.408750] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.408758] *** Channel 1: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.408765] *** Channel 1: QBUF - Buffer m.offset=0x7e07100, m.userptr=0x7e07100 ***
[   34.408772] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.408779] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   34.408786] *** Channel 1: QBUF - Queue buffer index=0 ***
[   34.408792] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.408799] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   34.408806] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   34.408814] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   34.408822] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=2 ***
[   34.408830] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.408837] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   34.408844] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   34.408855] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.408942] *** Channel 1: Frame wait returned 7 ***
[   34.408949] *** Channel 1: Frame was ready, consuming it ***
[   34.408962] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.408968] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.408975] *** Channel 1: Frame completion wait ***
[   34.408980] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.410646] *** Channel 0: Frame wait returned 0 ***
[   34.410657] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.410678] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.410686] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.410692] *** Channel 0: Frame completion wait ***
[   34.410698] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.410704] *** Channel 0: Frame wait returned 10 ***
[   34.410710] *** Channel 0: Frame was ready, consuming it ***
[   34.410718] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.410724] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.410730] *** Channel 0: Frame completion wait ***
[   34.410735] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.500587] *** Channel 0: DQBUF wait returned 0 ***
[   34.500598] *** Channel 0: DQBUF timeout, generating frame ***
[   34.500608] *** Channel 0: DQBUF complete - buffer[1] seq=0 flags=0x3 ***
[   34.500643] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.500650] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.500657] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.500662] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.500668] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.500783] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.500792] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.500799] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.500804] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.500814] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.500820] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.500827] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.500846] *** Channel 1: Frame wait returned 0 ***
[   34.500853] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.500866] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.500874] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.500880] *** Channel 1: Frame completion wait ***
[   34.500886] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.500892] *** Channel 1: Frame wait returned 10 ***
[   34.500897] *** Channel 1: Frame was ready, consuming it ***
[   34.500905] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.500912] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.500917] *** Channel 1: Frame completion wait ***
[   34.500922] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.510614] *** Channel 0: Frame wait returned 0 ***
[   34.510631] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.510660] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.510668] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.510674] *** Channel 0: Frame completion wait ***
[   34.510680] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.510686] *** Channel 0: Frame wait returned 10 ***
[   34.510692] *** Channel 0: Frame was ready, consuming it ***
[   34.510700] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.510706] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.510712] *** Channel 0: Frame completion wait ***
[   34.510718] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.510951] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.510961] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.510968] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.510974] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.510981] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.510989] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   34.510996] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.511003] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   34.511009] *** Channel 0: QBUF - Queue buffer index=1 ***
[   34.511015] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.511023] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   34.511030] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.511036] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.511043] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   34.511051] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   34.511058] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   34.511066] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.511073] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   34.511080] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   34.511092] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.511159] *** Channel 0: DQBUF wait returned 19 ***
[   34.511170] *** Channel 0: DQBUF complete - buffer[2] seq=1 flags=0x3 ***
[   34.511187] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.511194] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.511200] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.511206] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.511211] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.511328] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.511339] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.511346] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.511352] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.511362] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.511368] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.511374] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.521432] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.521445] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.521452] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.521458] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.521466] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   34.521473] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   34.521480] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.521487] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   34.521493] *** Channel 0: QBUF - Queue buffer index=2 ***
[   34.521499] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   34.521507] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   34.521513] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.521520] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.521527] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   34.521535] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   34.521543] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   34.521550] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.521557] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   34.521564] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   34.521576] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.521644] *** Channel 0: Frame wait returned 9 ***
[   34.521652] *** Channel 0: Frame was ready, consuming it ***
[   34.521664] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.521670] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.521676] *** Channel 0: Frame completion wait ***
[   34.521682] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.570590] *** Channel 1: DQBUF wait returned 0 ***
[   34.570602] *** Channel 1: DQBUF timeout, generating frame ***
[   34.570611] *** Channel 1: DQBUF complete - buffer[1] seq=0 flags=0x3 ***
[   34.570720] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.570729] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.570736] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.570742] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.570752] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.570758] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.570765] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.573133] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.573146] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.573152] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.573172] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.573180] *** Channel 1: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.573187] *** Channel 1: QBUF - Buffer m.offset=0x7e5d500, m.userptr=0x7e5d500 ***
[   34.573194] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.573202] *** Channel 1: QBUF - Validation: buffer.index=1, state->buffer_count=2 ***
[   34.573208] *** Channel 1: QBUF - Queue buffer index=1 ***
[   34.573214] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.573222] *** Channel 1: QBUF - Using buffer struct   (null) for index 1 ***
[   34.573228] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e5d500 ***
[   34.573236] *** Channel 1: QBUF - Buffer 1: phys_addr=0x7e5d500, size=460800 (VALIDATED) ***
[   34.573244] *** Channel 1: QBUF VBM - Stored buffer[1] = 0x7e5d500, total_count=2 ***
[   34.573252] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.573259] *** Channel 1: QBUF - VBM buffer slot[1] available ***
[   34.573266] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e5d500 ***
[   34.573276] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.573362] *** Channel 1: DQBUF wait returned 20 ***
[   34.573372] *** Channel 1: DQBUF complete - buffer[0] seq=1 flags=0x3 ***
[   34.573472] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.573482] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.573489] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.573495] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.573504] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.573511] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.573518] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.575990] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.576003] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.576010] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.576016] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.576023] *** Channel 1: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.576030] *** Channel 1: QBUF - Buffer m.offset=0x7e07100, m.userptr=0x7e07100 ***
[   34.576038] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.576044] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   34.576051] *** Channel 1: QBUF - Queue buffer index=0 ***
[   34.576057] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.576064] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   34.576072] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   34.576080] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   34.576088] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=2 ***
[   34.576096] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.576102] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   34.576109] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   34.576120] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.576184] *** Channel 1: Frame wait returned 3 ***
[   34.576190] *** Channel 1: Frame was ready, consuming it ***
[   34.576202] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.576210] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.576216] *** Channel 1: Frame completion wait ***
[   34.576222] *** Channel 1: Waiting for frame (timeout=100ms) ***
root@ing-wyze-cam3-a000 ~# dmesg 
[   34.408779] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   34.408786] *** Channel 1: QBUF - Queue buffer index=0 ***
[   34.408792] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.408799] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   34.408806] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   34.408814] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   34.408822] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=2 ***
[   34.408830] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.408837] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   34.408844] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   34.408855] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.408942] *** Channel 1: Frame wait returned 7 ***
[   34.408949] *** Channel 1: Frame was ready, consuming it ***
[   34.408962] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.408968] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.408975] *** Channel 1: Frame completion wait ***
[   34.408980] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.410646] *** Channel 0: Frame wait returned 0 ***
[   34.410657] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.410678] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.410686] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.410692] *** Channel 0: Frame completion wait ***
[   34.410698] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.410704] *** Channel 0: Frame wait returned 10 ***
[   34.410710] *** Channel 0: Frame was ready, consuming it ***
[   34.410718] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.410724] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.410730] *** Channel 0: Frame completion wait ***
[   34.410735] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.500587] *** Channel 0: DQBUF wait returned 0 ***
[   34.500598] *** Channel 0: DQBUF timeout, generating frame ***
[   34.500608] *** Channel 0: DQBUF complete - buffer[1] seq=0 flags=0x3 ***
[   34.500643] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.500650] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.500657] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.500662] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.500668] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.500783] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.500792] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.500799] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.500804] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.500814] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.500820] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.500827] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.500846] *** Channel 1: Frame wait returned 0 ***
[   34.500853] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.500866] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.500874] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.500880] *** Channel 1: Frame completion wait ***
[   34.500886] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.500892] *** Channel 1: Frame wait returned 10 ***
[   34.500897] *** Channel 1: Frame was ready, consuming it ***
[   34.500905] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.500912] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.500917] *** Channel 1: Frame completion wait ***
[   34.500922] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.510614] *** Channel 0: Frame wait returned 0 ***
[   34.510631] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.510660] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.510668] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.510674] *** Channel 0: Frame completion wait ***
[   34.510680] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.510686] *** Channel 0: Frame wait returned 10 ***
[   34.510692] *** Channel 0: Frame was ready, consuming it ***
[   34.510700] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.510706] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.510712] *** Channel 0: Frame completion wait ***
[   34.510718] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.510951] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.510961] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.510968] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.510974] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.510981] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.510989] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   34.510996] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.511003] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   34.511009] *** Channel 0: QBUF - Queue buffer index=1 ***
[   34.511015] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.511023] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   34.511030] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.511036] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.511043] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   34.511051] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   34.511058] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   34.511066] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.511073] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   34.511080] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   34.511092] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.511159] *** Channel 0: DQBUF wait returned 19 ***
[   34.511170] *** Channel 0: DQBUF complete - buffer[2] seq=1 flags=0x3 ***
[   34.511187] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.511194] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.511200] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.511206] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.511211] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.511328] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.511339] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.511346] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.511352] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.511362] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.511368] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.511374] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.521432] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.521445] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.521452] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.521458] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.521466] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   34.521473] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   34.521480] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.521487] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   34.521493] *** Channel 0: QBUF - Queue buffer index=2 ***
[   34.521499] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   34.521507] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   34.521513] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.521520] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.521527] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   34.521535] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   34.521543] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   34.521550] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.521557] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   34.521564] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   34.521576] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.521644] *** Channel 0: Frame wait returned 9 ***
[   34.521652] *** Channel 0: Frame was ready, consuming it ***
[   34.521664] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.521670] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.521676] *** Channel 0: Frame completion wait ***
[   34.521682] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.570590] *** Channel 1: DQBUF wait returned 0 ***
[   34.570602] *** Channel 1: DQBUF timeout, generating frame ***
[   34.570611] *** Channel 1: DQBUF complete - buffer[1] seq=0 flags=0x3 ***
[   34.570720] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.570729] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.570736] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.570742] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.570752] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.570758] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.570765] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.573133] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.573146] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.573152] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.573172] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.573180] *** Channel 1: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.573187] *** Channel 1: QBUF - Buffer m.offset=0x7e5d500, m.userptr=0x7e5d500 ***
[   34.573194] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.573202] *** Channel 1: QBUF - Validation: buffer.index=1, state->buffer_count=2 ***
[   34.573208] *** Channel 1: QBUF - Queue buffer index=1 ***
[   34.573214] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.573222] *** Channel 1: QBUF - Using buffer struct   (null) for index 1 ***
[   34.573228] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e5d500 ***
[   34.573236] *** Channel 1: QBUF - Buffer 1: phys_addr=0x7e5d500, size=460800 (VALIDATED) ***
[   34.573244] *** Channel 1: QBUF VBM - Stored buffer[1] = 0x7e5d500, total_count=2 ***
[   34.573252] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.573259] *** Channel 1: QBUF - VBM buffer slot[1] available ***
[   34.573266] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e5d500 ***
[   34.573276] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.573362] *** Channel 1: DQBUF wait returned 20 ***
[   34.573372] *** Channel 1: DQBUF complete - buffer[0] seq=1 flags=0x3 ***
[   34.573472] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.573482] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.573489] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.573495] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.573504] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.573511] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.573518] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.575990] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.576003] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.576010] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.576016] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.576023] *** Channel 1: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.576030] *** Channel 1: QBUF - Buffer m.offset=0x7e07100, m.userptr=0x7e07100 ***
[   34.576038] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.576044] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   34.576051] *** Channel 1: QBUF - Queue buffer index=0 ***
[   34.576057] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.576064] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   34.576072] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   34.576080] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   34.576088] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=2 ***
[   34.576096] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.576102] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   34.576109] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   34.576120] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.576184] *** Channel 1: Frame wait returned 3 ***
[   34.576190] *** Channel 1: Frame was ready, consuming it ***
[   34.576202] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.576210] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.576216] *** Channel 1: Frame completion wait ***
[   34.576222] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.620594] *** Channel 0: Frame wait returned 0 ***
[   34.620606] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.620626] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.620634] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.620640] *** Channel 0: Frame completion wait ***
[   34.620646] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.620652] *** Channel 0: Frame wait returned 10 ***
[   34.620658] *** Channel 0: Frame was ready, consuming it ***
[   34.620665] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.620672] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.620678] *** Channel 0: Frame completion wait ***
[   34.620683] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.670596] *** Channel 1: Frame wait returned 0 ***
[   34.670607] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.670628] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.670636] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.670642] *** Channel 1: Frame completion wait ***
[   34.670648] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.670654] *** Channel 1: Frame wait returned 10 ***
[   34.670660] *** Channel 1: Frame was ready, consuming it ***
[   34.670667] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.670674] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.670680] *** Channel 1: Frame completion wait ***
[   34.670685] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.710615] *** Channel 0: DQBUF wait returned 0 ***
[   34.710628] *** Channel 0: DQBUF timeout, generating frame ***
[   34.710636] *** Channel 0: DQBUF complete - buffer[3] seq=2 flags=0x3 ***
[   34.710662] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.710670] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.710676] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.710682] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.710687] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.710818] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.710828] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.710834] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.710840] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.710850] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.710856] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.710863] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.720624] *** Channel 0: Frame wait returned 0 ***
[   34.720638] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.720664] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.720685] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.720692] *** Channel 0: Frame completion wait ***
[   34.720698] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.720704] *** Channel 0: Frame wait returned 10 ***
[   34.720710] *** Channel 0: Frame was ready, consuming it ***
[   34.720718] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.720725] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.720730] *** Channel 0: Frame completion wait ***
[   34.720736] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.720908] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.720918] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.720924] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.720931] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.720938] *** Channel 0: QBUF - Buffer received: index=3, type=1, memory=2 ***
[   34.720946] *** Channel 0: QBUF - Buffer m.offset=0x79d0000, m.userptr=0x79d0000 ***
[   34.720952] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.720960] *** Channel 0: QBUF - Validation: buffer.index=3, state->buffer_count=4 ***
[   34.720966] *** Channel 0: QBUF - Queue buffer index=3 ***
[   34.720972] *** QBUF: No buffer allocated for index 3 - VBM initialization mode ***
[   34.720980] *** Channel 0: QBUF - Using buffer struct   (null) for index 3 ***
[   34.720986] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.720993] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.721000] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x79d0000 ***
[   34.721008] *** Channel 0: QBUF - Buffer 3: phys_addr=0x79d0000, size=4147200 (VALIDATED) ***
[   34.721016] *** Channel 0: QBUF VBM - Stored buffer[3] = 0x79d0000, total_count=4 ***
[   34.721024] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.721030] *** Channel 0: QBUF - VBM buffer slot[3] available ***
[   34.721037] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x79d0000 ***
[   34.721048] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.721114] *** Channel 0: DQBUF wait returned 19 ***
[   34.721126] *** Channel 0: DQBUF complete - buffer[0] seq=3 flags=0x3 ***
[   34.721142] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.721167] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.721174] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.721180] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.721185] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.721304] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.721316] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.721322] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.721329] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.721338] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.721346] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.721352] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.731650] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.731664] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.731670] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.731676] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.731684] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.731691] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   34.731698] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.731705] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   34.731712] *** Channel 0: QBUF - Queue buffer index=0 ***
[   34.731718] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.731725] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   34.731732] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.731738] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.731746] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   34.731754] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   34.731761] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   34.731769] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.731776] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   34.731782] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   34.731794] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.731860] *** Channel 0: Frame wait returned 9 ***
[   34.731867] *** Channel 0: Frame was ready, consuming it ***
[   34.731879] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.731886] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.731892] *** Channel 0: Frame completion wait ***
[   34.731898] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.770602] *** Channel 1: DQBUF wait returned 0 ***
[   34.770613] *** Channel 1: DQBUF timeout, generating frame ***
[   34.770622] *** Channel 1: DQBUF complete - buffer[1] seq=2 flags=0x3 ***
[   34.770744] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.770753] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.770760] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.770766] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.770776] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.770782] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.770789] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.770807] *** Channel 1: Frame wait returned 0 ***
[   34.770814] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.770826] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.770833] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.770839] *** Channel 1: Frame completion wait ***
[   34.770844] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.770850] *** Channel 1: Frame wait returned 10 ***
[   34.770856] *** Channel 1: Frame was ready, consuming it ***
[   34.770864] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.770870] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.770876] *** Channel 1: Frame completion wait ***
[   34.770882] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.773242] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.773270] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.773277] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.773283] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.773290] *** Channel 1: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.773298] *** Channel 1: QBUF - Buffer m.offset=0x7e5d500, m.userptr=0x7e5d500 ***
[   34.773305] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.773312] *** Channel 1: QBUF - Validation: buffer.index=1, state->buffer_count=2 ***
[   34.773318] *** Channel 1: QBUF - Queue buffer index=1 ***
[   34.773324] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.773332] *** Channel 1: QBUF - Using buffer struct   (null) for index 1 ***
[   34.773339] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e5d500 ***
[   34.773347] *** Channel 1: QBUF - Buffer 1: phys_addr=0x7e5d500, size=460800 (VALIDATED) ***
[   34.773355] *** Channel 1: QBUF VBM - Stored buffer[1] = 0x7e5d500, total_count=2 ***
[   34.773363] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.773370] *** Channel 1: QBUF - VBM buffer slot[1] available ***
[   34.773376] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e5d500 ***
[   34.773388] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.773466] *** Channel 1: Frame wait returned 10 ***
[   34.773474] *** Channel 1: Frame was ready, consuming it ***
[   34.773486] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.773494] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.773500] *** Channel 1: Frame completion wait ***
[   34.773506] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.830619] *** Channel 0: Frame wait returned 0 ***
[   34.830631] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.830651] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.830658] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.830665] *** Channel 0: Frame completion wait ***
[   34.830670] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.830676] *** Channel 0: Frame wait returned 10 ***
[   34.830682] *** Channel 0: Frame was ready, consuming it ***
[   34.830689] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.830696] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.830702] *** Channel 0: Frame completion wait ***
[   34.830707] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.870606] *** Channel 1: Frame wait returned 0 ***
[   34.870617] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.870638] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.870645] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.870651] *** Channel 1: Frame completion wait ***
[   34.870657] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.870663] *** Channel 1: Frame wait returned 10 ***
[   34.870669] *** Channel 1: Frame was ready, consuming it ***
[   34.870677] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.870683] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.870689] *** Channel 1: Frame completion wait ***
[   34.870695] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.920617] *** Channel 0: DQBUF wait returned 0 ***
[   34.920628] *** Channel 0: DQBUF timeout, generating frame ***
[   34.920637] *** Channel 0: DQBUF complete - buffer[1] seq=4 flags=0x3 ***
[   34.920661] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.920669] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.920675] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.920680] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.920685] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.920801] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.920810] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.920817] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.920841] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.920851] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.920858] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.920865] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.930625] *** Channel 0: Frame wait returned 0 ***
[   34.930647] *** Channel 0: Frame wait timeout/error, generating frame ***
[   34.930667] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.930675] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.930681] *** Channel 0: Frame completion wait ***
[   34.930687] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.930693] *** Channel 0: Frame wait returned 10 ***
[   34.930698] *** Channel 0: Frame was ready, consuming it ***
[   34.930706] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.930713] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.930718] *** Channel 0: Frame completion wait ***
[   34.930723] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.930891] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.930901] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.930907] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.930913] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.930921] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   34.930928] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   34.930935] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.930942] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   34.930948] *** Channel 0: QBUF - Queue buffer index=1 ***
[   34.930954] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   34.930961] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   34.930968] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.930975] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.930982] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   34.930989] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   34.930997] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   34.931005] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.931012] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   34.931019] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   34.931030] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.931097] *** Channel 0: DQBUF wait returned 19 ***
[   34.931108] *** Channel 0: DQBUF complete - buffer[2] seq=5 flags=0x3 ***
[   34.931124] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   34.931131] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   34.931138] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   34.931143] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   34.931149] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   34.931290] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.931301] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.931308] *** Channel 0: DQBUF - dequeue buffer request ***
[   34.931314] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.931324] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.931331] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.931337] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.941424] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.941437] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.941443] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.941450] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   34.941457] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   34.941465] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   34.941471] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.941479] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   34.941485] *** Channel 0: QBUF - Queue buffer index=2 ***
[   34.941491] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   34.941499] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   34.941505] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   34.941512] *** Channel 0: QBUF EVENT - No VIC callback ***
[   34.941519] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   34.941527] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   34.941534] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   34.941542] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   34.941549] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   34.941555] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   34.941568] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   34.941656] *** Channel 0: Frame wait returned 9 ***
[   34.941663] *** Channel 0: Frame was ready, consuming it ***
[   34.941676] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.941683] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.941689] *** Channel 0: Frame completion wait ***
[   34.941695] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   34.970616] *** Channel 1: DQBUF wait returned 0 ***
[   34.970627] *** Channel 1: DQBUF timeout, generating frame ***
[   34.970637] *** Channel 1: DQBUF complete - buffer[0] seq=3 flags=0x3 ***
[   34.970743] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   34.970751] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   34.970758] *** Channel 1: DQBUF - dequeue buffer request ***
[   34.970764] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   34.970774] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   34.970781] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   34.970787] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   34.970803] *** Channel 1: Frame wait returned 0 ***
[   34.970810] *** Channel 1: Frame wait timeout/error, generating frame ***
[   34.970821] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.970829] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.970835] *** Channel 1: Frame completion wait ***
[   34.970841] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.970847] *** Channel 1: Frame wait returned 10 ***
[   34.970852] *** Channel 1: Frame was ready, consuming it ***
[   34.970860] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.970867] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.970872] *** Channel 1: Frame completion wait ***
[   34.970878] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   34.971835] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   34.971848] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   34.971854] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   34.971861] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   34.971867] *** Channel 1: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   34.971875] *** Channel 1: QBUF - Buffer m.offset=0x7e07100, m.userptr=0x7e07100 ***
[   34.971882] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   34.971889] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   34.971895] *** Channel 1: QBUF - Queue buffer index=0 ***
[   34.971901] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   34.971909] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   34.971916] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   34.971924] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   34.971932] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=2 ***
[   34.971939] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   34.971946] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   34.971953] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   34.971965] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   34.971987] *** Channel 1: Frame wait returned 10 ***
[   34.971994] *** Channel 1: Frame was ready, consuming it ***
[   34.972005] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   34.972012] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   34.972018] *** Channel 1: Frame completion wait ***
[   34.972024] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.040644] *** Channel 0: Frame wait returned 0 ***
[   35.040655] *** Channel 0: Frame wait timeout/error, generating frame ***
[   35.040675] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.040682] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.040688] *** Channel 0: Frame completion wait ***
[   35.040694] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.040700] *** Channel 0: Frame wait returned 10 ***
[   35.040705] *** Channel 0: Frame was ready, consuming it ***
[   35.040713] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.040720] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.040725] *** Channel 0: Frame completion wait ***
[   35.040731] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.070624] *** Channel 1: Frame wait returned 0 ***
[   35.070635] *** Channel 1: Frame wait timeout/error, generating frame ***
[   35.070656] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.070664] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.070671] *** Channel 1: Frame completion wait ***
[   35.070676] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.070682] *** Channel 1: Frame wait returned 10 ***
[   35.070688] *** Channel 1: Frame was ready, consuming it ***
[   35.070695] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.070716] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.070722] *** Channel 1: Frame completion wait ***
[   35.070727] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.130627] *** Channel 0: DQBUF wait returned 0 ***
[   35.130638] *** Channel 0: DQBUF timeout, generating frame ***
[   35.130647] *** Channel 0: DQBUF complete - buffer[3] seq=6 flags=0x3 ***
[   35.130684] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   35.130691] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   35.130698] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   35.130703] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   35.130709] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   35.130823] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.130833] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.130839] *** Channel 0: DQBUF - dequeue buffer request ***
[   35.130845] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.130855] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.130861] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.130868] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.140645] *** Channel 0: Frame wait returned 0 ***
[   35.140659] *** Channel 0: Frame wait timeout/error, generating frame ***
[   35.140692] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.140699] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.140705] *** Channel 0: Frame completion wait ***
[   35.140711] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.140717] *** Channel 0: Frame wait returned 10 ***
[   35.140723] *** Channel 0: Frame was ready, consuming it ***
[   35.140731] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.140738] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.140743] *** Channel 0: Frame completion wait ***
[   35.140749] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.140921] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.140931] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.140937] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.140943] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   35.140950] *** Channel 0: QBUF - Buffer received: index=3, type=1, memory=2 ***
[   35.140957] *** Channel 0: QBUF - Buffer m.offset=0x79d0000, m.userptr=0x79d0000 ***
[   35.140965] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.140971] *** Channel 0: QBUF - Validation: buffer.index=3, state->buffer_count=4 ***
[   35.140978] *** Channel 0: QBUF - Queue buffer index=3 ***
[   35.140984] *** QBUF: No buffer allocated for index 3 - VBM initialization mode ***
[   35.140992] *** Channel 0: QBUF - Using buffer struct   (null) for index 3 ***
[   35.140998] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   35.141005] *** Channel 0: QBUF EVENT - No VIC callback ***
[   35.141012] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x79d0000 ***
[   35.141020] *** Channel 0: QBUF - Buffer 3: phys_addr=0x79d0000, size=4147200 (VALIDATED) ***
[   35.141027] *** Channel 0: QBUF VBM - Stored buffer[3] = 0x79d0000, total_count=4 ***
[   35.141035] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   35.141042] *** Channel 0: QBUF - VBM buffer slot[3] available ***
[   35.141049] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x79d0000 ***
[   35.141061] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   35.141124] *** Channel 0: DQBUF wait returned 19 ***
[   35.141135] *** Channel 0: DQBUF complete - buffer[0] seq=7 flags=0x3 ***
[   35.141152] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   35.141160] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   35.141166] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   35.141171] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   35.141177] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   35.141295] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.141307] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.141313] *** Channel 0: DQBUF - dequeue buffer request ***
[   35.141319] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.141329] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.141336] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.141343] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.151437] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.151451] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.151457] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.151464] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   35.151471] *** Channel 0: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   35.151479] *** Channel 0: QBUF - Buffer m.offset=0x70d9000, m.userptr=0x70d9000 ***
[   35.151485] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.151493] *** Channel 0: QBUF - Validation: buffer.index=0, state->buffer_count=4 ***
[   35.151499] *** Channel 0: QBUF - Queue buffer index=0 ***
[   35.151505] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   35.151513] *** Channel 0: QBUF - Using buffer struct   (null) for index 0 ***
[   35.151519] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   35.151525] *** Channel 0: QBUF EVENT - No VIC callback ***
[   35.151533] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x70d9000 ***
[   35.151541] *** Channel 0: QBUF - Buffer 0: phys_addr=0x70d9000, size=4147200 (VALIDATED) ***
[   35.151548] *** Channel 0: QBUF VBM - Stored buffer[0] = 0x70d9000, total_count=4 ***
[   35.151556] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   35.151563] *** Channel 0: QBUF - VBM buffer slot[0] available ***
[   35.151569] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x70d9000 ***
[   35.151581] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   35.151648] *** Channel 0: Frame wait returned 9 ***
[   35.151655] *** Channel 0: Frame was ready, consuming it ***
[   35.151667] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.151674] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.151680] *** Channel 0: Frame completion wait ***
[   35.151686] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.170650] *** Channel 1: DQBUF wait returned 0 ***
[   35.170661] *** Channel 1: DQBUF timeout, generating frame ***
[   35.170670] *** Channel 1: DQBUF complete - buffer[1] seq=4 flags=0x3 ***
[   35.170777] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.170785] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.170792] *** Channel 1: DQBUF - dequeue buffer request ***
[   35.170798] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.170808] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.170815] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.170821] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.170838] *** Channel 1: Frame wait returned 0 ***
[   35.170845] *** Channel 1: Frame wait timeout/error, generating frame ***
[   35.170857] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.170863] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.170870] *** Channel 1: Frame completion wait ***
[   35.170875] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.170881] *** Channel 1: Frame wait returned 10 ***
[   35.170887] *** Channel 1: Frame was ready, consuming it ***
[   35.170895] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.170901] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.170907] *** Channel 1: Frame completion wait ***
[   35.170913] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.171931] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.171944] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.171951] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.171957] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   35.171964] *** Channel 1: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   35.171971] *** Channel 1: QBUF - Buffer m.offset=0x7e5d500, m.userptr=0x7e5d500 ***
[   35.171979] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.171985] *** Channel 1: QBUF - Validation: buffer.index=1, state->buffer_count=2 ***
[   35.171992] *** Channel 1: QBUF - Queue buffer index=1 ***
[   35.171998] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   35.172006] *** Channel 1: QBUF - Using buffer struct   (null) for index 1 ***
[   35.172013] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e5d500 ***
[   35.172037] *** Channel 1: QBUF - Buffer 1: phys_addr=0x7e5d500, size=460800 (VALIDATED) ***
[   35.172045] *** Channel 1: QBUF VBM - Stored buffer[1] = 0x7e5d500, total_count=2 ***
[   35.172054] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   35.172060] *** Channel 1: QBUF - VBM buffer slot[1] available ***
[   35.172067] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e5d500 ***
[   35.172079] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   35.172155] *** Channel 1: Frame wait returned 10 ***
[   35.172163] *** Channel 1: Frame was ready, consuming it ***
[   35.250634] *** Channel 0: Frame wait returned 0 ***
[   35.250647] *** Channel 0: Frame wait timeout/error, generating frame ***
[   35.340649] *** Channel 0: DQBUF wait returned 1 ***
[   35.340664] *** Channel 0: DQBUF complete - buffer[1] seq=8 flags=0x3 ***
[   35.340689] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   35.340696] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   35.340702] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   35.340708] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   35.340713] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   35.340829] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.340839] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.340846] *** Channel 0: DQBUF - dequeue buffer request ***
[   35.340852] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.340861] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.340868] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.340875] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.341137] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.341152] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.341159] *** Channel 0: Frame completion wait ***
[   35.341165] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.350897] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.350910] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.350916] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.350923] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   35.350930] *** Channel 0: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   35.350937] *** Channel 0: QBUF - Buffer m.offset=0x73d6000, m.userptr=0x73d6000 ***
[   35.350944] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.350951] *** Channel 0: QBUF - Validation: buffer.index=1, state->buffer_count=4 ***
[   35.350958] *** Channel 0: QBUF - Queue buffer index=1 ***
[   35.350963] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   35.350971] *** Channel 0: QBUF - Using buffer struct   (null) for index 1 ***
[   35.350978] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   35.350985] *** Channel 0: QBUF EVENT - No VIC callback ***
[   35.350991] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x73d6000 ***
[   35.350999] *** Channel 0: QBUF - Buffer 1: phys_addr=0x73d6000, size=4147200 (VALIDATED) ***
[   35.351007] *** Channel 0: QBUF VBM - Stored buffer[1] = 0x73d6000, total_count=4 ***
[   35.351015] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   35.351022] *** Channel 0: QBUF - VBM buffer slot[1] available ***
[   35.351029] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x73d6000 ***
[   35.351040] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   35.351107] *** Channel 0: Frame wait returned 9 ***
[   35.351113] *** Channel 0: Frame was ready, consuming it ***
[   35.370672] *** Channel 1: DQBUF wait returned 0 ***
[   35.370683] *** Channel 1: DQBUF timeout, generating frame ***
[   35.370692] *** Channel 1: DQBUF complete - buffer[0] seq=5 flags=0x3 ***
[   35.370805] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.370814] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.370821] *** Channel 1: DQBUF - dequeue buffer request ***
[   35.370827] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.370836] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.370843] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.370849] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.371075] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.371088] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.371095] *** Channel 1: Frame completion wait ***
[   35.371101] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.371885] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.371897] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.371904] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.371910] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   35.371917] *** Channel 1: QBUF - Buffer received: index=0, type=1, memory=2 ***
[   35.371925] *** Channel 1: QBUF - Buffer m.offset=0x7e07100, m.userptr=0x7e07100 ***
[   35.371932] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.371939] *** Channel 1: QBUF - Validation: buffer.index=0, state->buffer_count=2 ***
[   35.371945] *** Channel 1: QBUF - Queue buffer index=0 ***
[   35.371951] *** QBUF: No buffer allocated for index 0 - VBM initialization mode ***
[   35.371959] *** Channel 1: QBUF - Using buffer struct   (null) for index 0 ***
[   35.371966] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e07100 ***
[   35.371974] *** Channel 1: QBUF - Buffer 0: phys_addr=0x7e07100, size=460800 (VALIDATED) ***
[   35.371982] *** Channel 1: QBUF VBM - Stored buffer[0] = 0x7e07100, total_count=2 ***
[   35.371990] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   35.371997] *** Channel 1: QBUF - VBM buffer slot[0] available ***
[   35.372003] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e07100 ***
[   35.372016] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   35.372039] *** Channel 1: Frame wait returned 10 ***
[   35.372045] *** Channel 1: Frame was ready, consuming it ***
[   35.408315] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   35.408327] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   35.408333] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   35.408339] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   35.408345] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   35.540652] *** Channel 0: DQBUF wait returned 0 ***
[   35.540663] *** Channel 0: DQBUF timeout, generating frame ***
[   35.540672] *** Channel 0: DQBUF complete - buffer[2] seq=9 flags=0x3 ***
[   35.540697] isp_core_tunning_unlocked_ioctl: Handling ISP core control command 0xc00c56c6
[   35.540705] isp_core_tunning_unlocked_ioctl: Tuning enable/disable: ENABLE
[   35.540711] *** DEBUG: enable=1, dev->core_dev->tuning_enabled=1 ***
[   35.540716] *** BINARY NINJA REFERENCE: Tuning enable - no hardware reset performed ***
[   35.540722] isp_core_tunning_unlocked_ioctl: ISP tuning enabled
[   35.540840] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.540850] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.540856] *** Channel 0: DQBUF - dequeue buffer request ***
[   35.540862] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.540872] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.540879] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.540885] *** Channel 0: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.541123] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.541138] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.541145] *** Channel 0: Frame completion wait ***
[   35.541151] *** Channel 0: Waiting for frame (timeout=100ms) ***
[   35.550870] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.550884] *** Frame channel 0 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.550890] *** Channel 0: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.550896] *** Channel 0: QBUF - Buffer copied from user successfully ***
[   35.550904] *** Channel 0: QBUF - Buffer received: index=2, type=1, memory=2 ***
[   35.550911] *** Channel 0: QBUF - Buffer m.offset=0x76d3000, m.userptr=0x76d3000 ***
[   35.550918] *** Channel 0: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.550925] *** Channel 0: QBUF - Validation: buffer.index=2, state->buffer_count=4 ***
[   35.550932] *** Channel 0: QBUF - Queue buffer index=2 ***
[   35.550938] *** QBUF: No buffer allocated for index 2 - VBM initialization mode ***
[   35.550945] *** Channel 0: QBUF - Using buffer struct   (null) for index 2 ***
[   35.550952] *** Channel 0: QBUF - Calling tx_isp_send_event_to_remote(VIC, 0x3000008, &buffer) ***
[   35.550958] *** Channel 0: QBUF EVENT - No VIC callback ***
[   35.550966] *** Channel 0: QBUF - Using REAL buffer address from userptr: 0x76d3000 ***
[   35.550974] *** Channel 0: QBUF - Buffer 2: phys_addr=0x76d3000, size=4147200 (VALIDATED) ***
[   35.550981] *** Channel 0: QBUF VBM - Stored buffer[2] = 0x76d3000, total_count=4 ***
[   35.550989] *** Channel 0: QBUF - VBM buffer check: vbm_buffer_addresses=805ee380, vbm_buffer_count=4 ***
[   35.550996] *** Channel 0: QBUF - VBM buffer slot[2] available ***
[   35.551003] *** Channel 0: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x76d3000 ***
[   35.551014] *** Channel 0: QBUF completed successfully (MIPS-safe) ***
[   35.551080] *** Channel 0: Frame wait returned 9 ***
[   35.551087] *** Channel 0: Frame was ready, consuming it ***
[   35.570671] *** Channel 1: DQBUF wait returned 0 ***
[   35.570682] *** Channel 1: DQBUF timeout, generating frame ***
[   35.570692] *** Channel 1: DQBUF complete - buffer[1] seq=6 flags=0x3 ***
[   35.570802] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc0445611 ***
[   35.570811] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc0445611 ***
[   35.570818] *** Channel 1: DQBUF - dequeue buffer request ***
[   35.570824] *** tx_isp_get_sensor: Searching subdev array for sensors ***
[   35.570834] *** tx_isp_get_sensor: Found real sensor subdev at index 4: 85f69400 (name=gc2053) ***
[   35.570840] *** tx_isp_get_sensor: Found real sensor: 85f69400 ***
[   35.570847] *** Channel 1: DQBUF waiting for frame completion (timeout=200ms) ***
[   35.571052] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0x400456bf ***
[   35.571064] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0x400456bf ***
[   35.571071] *** Channel 1: Frame completion wait ***
[   35.571077] *** Channel 1: Waiting for frame (timeout=100ms) ***
[   35.571890] *** frame_channel_unlocked_ioctl: ENTRY - cmd=0xc044560f ***
[   35.571904] *** Frame channel 1 IOCTL: MIPS-safe processing - cmd=0xc044560f ***
[   35.571910] *** Channel 1: QBUF - ENTRY POINT - VBM buffer queue attempt ***
[   35.571916] *** Channel 1: QBUF - Buffer copied from user successfully ***
[   35.571924] *** Channel 1: QBUF - Buffer received: index=1, type=1, memory=2 ***
[   35.571931] *** Channel 1: QBUF - Buffer m.offset=0x7e5d500, m.userptr=0x7e5d500 ***
[   35.571938] *** Channel 1: QBUF - Validation: buffer.type=1, fcd->buffer_type=1 ***
[   35.571945] *** Channel 1: QBUF - Validation: buffer.index=1, state->buffer_count=2 ***
[   35.571951] *** Channel 1: QBUF - Queue buffer index=1 ***
[   35.571957] *** QBUF: No buffer allocated for index 1 - VBM initialization mode ***
[   35.571965] *** Channel 1: QBUF - Using buffer struct   (null) for index 1 ***
[   35.571972] *** Channel 1: QBUF - Using REAL buffer address from userptr: 0x7e5d500 ***
[   35.571980] *** Channel 1: QBUF - Buffer 1: phys_addr=0x7e5d500, size=460800 (VALIDATED) ***
[   35.571988] *** Channel 1: QBUF VBM - Stored buffer[1] = 0x7e5d500, total_count=2 ***
[   35.571996] *** Channel 1: QBUF - VBM buffer check: vbm_buffer_addresses=805ee600, vbm_buffer_count=2 ***
[   35.572002] *** Channel 1: QBUF - VBM buffer slot[1] available ***
[   35.572010] *** Channel 1: QBUF VBM mode - VBMFillPool initialization with buffer_addr=0x7e5d500 ***
[   35.572022] *** Channel 1: QBUF completed successfully (MIPS-safe) ***
[   35.572044] *** Channel 1: Frame wait returned 10 ***
[   35.572050] *** Channel 1: Frame was ready, consuming it ***
root@ing-wyze-cam3-a000 ~# cat /proc/interrupts 
           CPU0       
  9:          0   jz-intc  i2s_irq
 11:      10085   jz-intc  jz-timerost
 14:        144   jz-intc  ipu
 15:      73023   jz-intc  jz-sfc
 18:          0   jz-intc  pdma
 23:          0   jz-intc  GPIO C
 24:          1   jz-intc  GPIO B
 25:          0   jz-intc  GPIO A
 29:          1   jz-intc  dwc2
 37:          0   jz-intc  isp-m0
 38:          0   jz-intc  isp-w02
 44:       8339   jz-intc  jzmmc_v1.2.1
 45:          0   jz-intc  jzmmc_v1.2.0
 58:        383   jz-intc  uart1
 68:        158   jz-intc  jz-i2c.0
 70:         29   jz-intc  avpu.0
126:          0    GPIO B  GPIO Button
134:          1    GPIO B  mmc-insert-detect
ERR:          0
root@ing-wyze-cam3-a000 ~# insmod /opt/tx-isp-^Cace.ko 

root@ing-wyze-cam3-a000 ~# cat /opt/trace.txt 
ISP Register Monitor v1.3 initializing
ISP Monitor: initialized region isp-w01 at phys 0x0x10023000 size 0x1000
ISP Monitor: initialized region isp-m0 at phys 0x0x13300000 size 0x100000
ISP Monitor: initialized region isp-w02 at phys 0x0x133e0000 size 0x10000
ISP Monitor: initialized region isp-csi at phys 0x0x10022000 size 0x1000
ISP isp-w02: [CSI PHY Control] write at offset 0x4: 0x0 -> 0x7800438 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xc: 0x0 -> 0x2 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x0: 0x0 -> 0x54560031 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x4: 0x0 -> 0x7800438 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x8: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xc: 0x0 -> 0x80700008 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x28: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x2c: 0x0 -> 0x400040 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x14: 0x0 -> 0x2 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x18: 0x0 -> 0xf00 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x60: 0x0 -> 0x800800 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x64: 0x0 -> 0x9d09d0 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x70: 0x0 -> 0x6002 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x74: 0x0 -> 0x7003 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x90: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x94: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x98: 0x0 -> 0x30000 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xa8: 0x0 -> 0x58050000 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xac: 0x0 -> 0x58050000 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xc4: 0x0 -> 0x40000 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xc0: 0x0 -> 0xeb8080 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xc4: 0x0 -> 0x108080 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xc8: 0x0 -> 0x29f06e (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xcc: 0x0 -> 0x913622 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xd0: 0x0 -> 0x515af0 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xd4: 0x0 -> 0xaaa610 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xc8: 0x0 -> 0x400040 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xcc: 0x0 -> 0x100 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xd4: 0x0 -> 0xc (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xd8: 0x0 -> 0xffffff (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xe0: 0x0 -> 0x100 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xe4: 0x0 -> 0x400040 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xd8: 0x0 -> 0xd21092 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xdc: 0x0 -> 0x6acade (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xe0: 0x0 -> 0xeb8080 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xe4: 0x0 -> 0x108080 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xe8: 0x0 -> 0x29f06e (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xec: 0x0 -> 0x913622 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0xf0: 0x0 -> 0xff808000 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Config] write at offset 0x110: 0x0 -> 0x80007000 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Config] write at offset 0x114: 0x0 -> 0x777111 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x9804: 0x0 -> 0x3f00 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xf0: 0x0 -> 0x515af0 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xf4: 0x0 -> 0xaaa610 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xf8: 0x0 -> 0xd21092 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x9864: 0x0 -> 0x7800438 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x987c: 0x0 -> 0xc0000000 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x9880: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x9884: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x9890: 0x0 -> 0x1010001 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x989c: 0x0 -> 0x1010001 (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x98a8: 0x0 -> 0x1010001 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a00: 0x0 -> 0x50002d0 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a04: 0x0 -> 0x3000300 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xfc: 0x0 -> 0x6acade (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x100: 0x0 -> 0x2d0 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x10c: 0x0 -> 0x2c000 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x110: 0x0 -> 0x7800000 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x1a4: 0x0 -> 0x100010 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a2c: 0x0 -> 0x50002d0 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a34: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a70: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a7c: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a80: 0x0 -> 0x500 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a88: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a94: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x1a8: 0x0 -> 0x4440 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x1b0: 0x0 -> 0x10 (delta: 0.000 ms)
ISP isp-m0: [VIC Control] write at offset 0x9a98: 0x0 -> 0x500 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb004: 0x0 -> 0xf001f001 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb008: 0x0 -> 0x40404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb00c: 0x0 -> 0x40404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb010: 0x0 -> 0x40404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb014: 0x0 -> 0x404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb018: 0x0 -> 0x40404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb01c: 0x0 -> 0x40404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb020: 0x0 -> 0x40404040 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x0: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0xc: 0x2 -> 0x1 (delta: 80.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x10: 0x0 -> 0x7800438 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x14: 0x2 -> 0x0 (delta: 80.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x8c: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x10c: 0x2c000 -> 0x1f40000 (delta: 80.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x110: 0x7800000 -> 0x780002b (delta: 80.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb024: 0x0 -> 0x404040 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb028: 0x0 -> 0x1000080 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb02c: 0x0 -> 0x1000080 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb030: 0x0 -> 0x100 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb034: 0x0 -> 0xffff0100 (delta: 0.000 ms)
ISP isp-w02: [CSI PHY Config] write at offset 0x1a0: 0x0 -> 0x1 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb038: 0x0 -> 0x1ff00 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb04c: 0x0 -> 0x103 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb050: 0x0 -> 0x3 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb07c: 0x0 -> 0x1fffff (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb080: 0x0 -> 0x1fffff (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb084: 0x0 -> 0x1fffff (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb088: 0x0 -> 0x1fdeff (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb08c: 0x0 -> 0x1fff (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x30: 0x0 -> 0x8fffffff (delta: 0.000 ms)
ISP isp-m0: [ISP Control] write at offset 0x9804: 0x3f00 -> 0x0 (delta: 230.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x10: 0x0 -> 0x133 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x14: 0x0 -> 0x2b (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x18: 0x0 -> 0xa (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Control] write at offset 0x1c: 0x0 -> 0x8 (delta: 0.000 ms)
ISP isp-m0: [CSI PHY Config] write at offset 0x110: 0x80007000 -> 0x80007001 (delta: 590.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb078: 0x0 -> 0x10000000 (delta: 0.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb004: 0xf001f001 -> 0x7 (delta: 730.000 ms)
ISP isp-m0: [Core Control] write at offset 0xb008: 0x40404040 -> 0x0 (delta: 730.000 ms)
ISP isp-w02: [CSI PHY Control] write at offset 0x14: 0x0 -> 0x1 (delta: 870.000 ms)
root@ing-wyze-cam3-a000 ~# cat /proc/jz/clock/clocks 
ID NAME       FRE        stat       count     parent
--------------------------------------------------------
 1 ext0          0.032MHz  enable   0 root
 2 ext1         24.000MHz  enable   11 root
 3 otg_phy      48.000MHz  enable   0 root
--------------------------------------------------------
 5 apll       1392.000MHz  enable   1 ext1
 6 mpll       1200.000MHz  enable   7 ext1
 7 vpll       1200.000MHz  enable   1 ext1
 8 sclka      1392.000MHz  enable   9 apll
--------------------------------------------------------
10 cclk       1392.000MHz  enable   0 sclka
11 l2clk       696.000MHz  enable   0 sclka
12 h0clk       200.000MHz  enable   4 mpll
13 h2clk       200.000MHz  enable   7 mpll
14 pclk        100.000MHz  enable   5 mpll
15 msc          24.000MHz  enable   0 ext1
--------------------------------------------------------
17 cgu_isp     100.000MHz  enable   2 mpll
18 cgu_cim      24.000MHz  enable   1 vpll
19 cgu_ssi      50.000MHz  enable   2 mpll
20 cgu_msc_mux 1392.000MHz  enable   0 sclka
21 cgu_i2s_spk    4.096MHz  enable   2 sclka
22 cgu_i2s_mic    2.048MHz  enable   1 sclka
23 cgu_msc1     24.000MHz  enable   1 sclka
24 cgu_msc0     24.000MHz  enable   0 sclka
25 cgu_lpc       4.687MHz disable   0 vpll
26 cgu_macphy    4.687MHz disable   0 mpll
27 cgu_vpu     600.000MHz  enable   2 mpll
28 cgu_ddr     600.000MHz  enable   0 mpll
29 cgu_rsa      75.000MHz disable   0 mpll
--------------------------------------------------------
31 ddr         200.000MHz  enable   0 h0clk
32 tcu         100.000MHz  enable   0 pclk
33 rtc         100.000MHz  enable   0 pclk
34 des         100.000MHz  enable   0 pclk
35 csi         100.000MHz disable   0 pclk
36 lcd         200.000MHz disable   0 h0clk
37 isp         200.000MHz  enable   2 h0clk
38 pdma        200.000MHz  enable   1 h2clk
39 sfc         200.000MHz  enable   1 h2clk
40 uart2        24.000MHz disable   0 ext1
41 uart1        24.000MHz  enable   1 ext1
42 uart0        24.000MHz disable   0 ext1
43 sadc        100.000MHz  enable   0 pclk
44 dmic        100.000MHz disable   0 pclk
45 aic         100.000MHz  enable   1 pclk
46 hash        200.000MHz disable   0 h2clk
47 i2c1        100.000MHz disable   0 pclk
48 i2c0        100.000MHz disable   0 pclk
49 ssi0         50.000MHz  enable   0 cgu_ssi
50 ssi1         50.000MHz disable   0 cgu_ssi
51 ssi_slv     100.000MHz disable   0 pclk
52 msc1        200.000MHz  enable   0 h2clk
53 msc0        200.000MHz  enable   0 h2clk
54 otg1        200.000MHz  enable   1 h2clk
--------------------------------------------------------
56 cpu          24.000MHz  enable   0 ext1
57 apb0         24.000MHz  enable   0 ext1
58 sys_ost      24.000MHz  enable   2 ext1
59 ahb0         24.000MHz  enable   0 ext1
--------------------------------------------------------
61 riscv       200.000MHz  enable   0 h2clk
62 aes         200.000MHz disable   0 h2clk
63 rsa         100.000MHz disable   0 pclk
64 ahb1         24.000MHz  enable   2 ext1
65 gmac        200.000MHz  enable   0 h2clk
66 ipu         200.000MHz  enable   888 h0clk
67 dtrng       100.000MHz disable   0 pclk
68 avpu        200.000MHz  enable   2 h0clk
root@ing-wyze-cam3-a000 ~# 
