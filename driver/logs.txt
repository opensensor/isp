
/* tx_isp_vic_start - Following EXACT Binary Ninja flow with reference driver sequences */
int tx_isp_vic_start(struct tx_isp_vic_device *vic_dev)
{
    void __iomem *vic_regs;
    struct tx_isp_sensor_attribute *sensor_attr;
    u32 interface_type, sensor_format;
    u32 timeout = 10000;
    struct clk *isp_clk, *cgu_isp_clk, *csi_clk, *ipu_clk;
    void __iomem *cpm_regs;
    int ret;

    pr_info("*** tx_isp_vic_start: Following EXACT Binary Ninja flow ***\n");

    /* Binary Ninja: 00010244 void* $v1 = *(arg1 + 0x110) */
    if (!vic_dev) {
        pr_err("*** CRITICAL: Invalid vic_dev pointer ***\n");
        return -EINVAL;
    }

    /* Get sensor attributes - offset 0x110 in Binary Ninja */
    sensor_attr = &vic_dev->sensor_attr;
    
    /* Binary Ninja: 0001024c int32_t $v0 = *($v1 + 0x14) - interface type at offset 0x14 */
    interface_type = sensor_attr->dbus_type;
    sensor_format = sensor_attr->data_type;

    pr_info("*** Interface type: %d, Format: 0x%x ***\n", interface_type, sensor_format);

    /* Get VIC register base - offset 0xb8 in Binary Ninja */
    vic_regs = vic_dev->vic_regs;
    if (!vic_regs) {
        pr_err("*** CRITICAL: No VIC register base ***\n");
        return -EINVAL;
    }

    /* Calculate base addresses for register blocks */
    void __iomem *main_isp_base = vic_regs - 0x9a00;
    void __iomem *csi_base = main_isp_base + 0x10000;

    /* STEP 1: Enable clocks - Critical for VIC operation */
    cgu_isp_clk = clk_get(NULL, "cgu_isp");
    if (!IS_ERR(cgu_isp_clk)) {
        clk_set_rate(cgu_isp_clk, 100000000);
        ret = clk_prepare_enable(cgu_isp_clk);
        if (ret == 0) {
            pr_info("CGU_ISP clock enabled at 100MHz\n");
        }
    }

    isp_clk = clk_get(NULL, "isp");
    if (!IS_ERR(isp_clk)) {
        clk_prepare_enable(isp_clk);
    }

    csi_clk = clk_get(NULL, "csi");
    if (!IS_ERR(csi_clk)) {
        clk_prepare_enable(csi_clk);
    }

    /* STEP 2: CPM register setup */
    cpm_regs = ioremap(0x10000000, 0x1000);
    if (cpm_regs) {
        u32 clkgr0 = readl(cpm_regs + 0x20);
        u32 clkgr1 = readl(cpm_regs + 0x28);
        
        clkgr0 &= ~(1 << 13); // ISP
        clkgr0 &= ~(1 << 21); // Alternative ISP
        clkgr0 &= ~(1 << 30); // VIC in CLKGR0
        clkgr1 &= ~(1 << 30); // VIC in CLKGR1
        
        writel(clkgr0, cpm_regs + 0x20);
        writel(clkgr1, cpm_regs + 0x28);
        wmb();
        msleep(20);
        iounmap(cpm_regs);
    }

    /* Binary Ninja: Branch on interface type at 00010250 */
    if (interface_type == 1) {
        /* DVP interface - Binary Ninja 00010260-000104f8 */
        pr_info("DVP interface configuration\n");
        
        /* Binary Ninja: Check flags at 00010260 */
        if (sensor_attr->dbus_type != interface_type) {
            writel(0xa000a, vic_regs + 0x1a4);
        } else {
            writel(0x20000, vic_regs + 0x10);
            writel(0x100010, vic_regs + 0x1a4);
        }
        
        /* Calculate buffer size - Binary Ninja 000102b8-00010308 */
        u32 stride_mult = 8;
        if (sensor_format == 1) stride_mult = 0xa;
        else if (sensor_format == 2) stride_mult = 0xc;
        else if (sensor_format == 7) stride_mult = 0x10;
        
        u32 buffer_calc = stride_mult * sensor_attr->integration_time;
        writel((buffer_calc >> 5) + ((buffer_calc & 0x1f) ? 1 : 0), vic_regs + 0x100);
        
        /* Binary Ninja: Core DVP registers 00010310-00010338 */
        writel(2, vic_regs + 0xc);
        writel(sensor_format, vic_regs + 0x14);
        writel((vic_dev->width << 16) | vic_dev->height, vic_regs + 0x4);
        
        /* Frame mode based on WDR - Binary Ninja 00010414-00010478 */
        u32 wdr_mode = sensor_attr->wdr_cache;
        u32 frame_mode = (wdr_mode == 0) ? 0x4440 : 
                        (wdr_mode == 1) ? 0x4140 : 0x4240;
        writel(frame_mode, vic_regs + 0x1ac);
        writel(frame_mode, vic_regs + 0x1a8);
        writel(0x10, vic_regs + 0x1b0);
        
        /* Unlock sequence - Binary Ninja 00010484-00010490 */
        writel(2, vic_regs + 0x0);
        wmb();
        writel(4, vic_regs + 0x0);
        wmb();
        
        /* Wait for unlock - Binary Ninja 000104b8 */
        while (readl(vic_regs + 0x0) != 0) {
            udelay(1);
        }
        
        /* Enable VIC - Binary Ninja 000107d4 */
        writel(1, vic_regs + 0x0);
        
    } else if (interface_type == 2) {
        /* MIPI interface - Binary Ninja 000107ec-00010b04 */
        pr_info("MIPI interface configuration\n");
        
        /* Binary Ninja: 000107ec - Set CSI mode */
        writel(3, vic_regs + 0xc);
        wmb();
        
        /* Format detection logic - Binary Ninja 000107f8-00010a04 */
        u32 mipi_config;
        
        if (sensor_format >= 0x3010) {
            if (sensor_format >= 0x3110) {
                if (sensor_format >= 0x3200) {
                    if (sensor_format < 0x3210) {
                        mipi_config = 0x20000;
                    } else if ((sensor_format - 0x3300) < 0x10) {
                        mipi_config = 0x40000;
                        if (sensor_attr->total_width == 2) {
                            mipi_config = 0x50000;
                        }
                    } else {
                        pr_err("Format 0x%x not supported\n", sensor_format);
                        return -1;
                    }
                } else {
                    mipi_config = 0x20000;
                }
            } else if (sensor_format >= 0x3100) {
                u32 gpio_mode = sensor_attr->dbus_type;
                if (gpio_mode == 3) {
                    mipi_config = 0;
                } else if (gpio_mode == 4) {
                    mipi_config = 0x100000;
                } else {
                    pr_err("DVP mode config failed\n");
                    return -1;
                }
            } else if (sensor_format >= 0x3013 && sensor_format < 0x3015) {
                u32 gpio_mode = sensor_attr->dbus_type;
                if (gpio_mode == 3) {
                    mipi_config = 0;
                } else if (gpio_mode == 4) {
                    mipi_config = 0x100000;
                } else {
                    pr_err("DVP mode config failed\n");
                    return -1;
                }
            } else {
                mipi_config = 0x40000;
                if (sensor_attr->total_width == 2) {
                    mipi_config = 0x50000;
                }
            }
        } else if (sensor_format >= 0x300e) {
            mipi_config = 0x20000;
        } else if (sensor_format == 0x2011) {
            mipi_config = 0xc0000;
        } else if (sensor_format >= 0x2012) {
            if (sensor_format == 0x3007) {
                mipi_config = 0x20000;
            } else if (sensor_format < 0x3008) {
                if ((sensor_format - 0x3001) < 2) {
                    u32 gpio_mode = sensor_attr->dbus_type;
                    if (gpio_mode == 3) {
                        mipi_config = 0;
                    } else if (gpio_mode == 4) {
                        mipi_config = 0x100000;
                    } else {
                        pr_err("DVP mode config failed\n");
                        return -1;
                    }
                } else {
                    pr_err("Format 0x%x not supported\n", sensor_format);
                    return -1;
                }
            } else if (sensor_format == 0x3008) {
                mipi_config = 0x40000;
                if (sensor_attr->total_width == 2) {
                    mipi_config = 0x50000;
                }
            } else if (sensor_format == 0x300a) {
                mipi_config = 0x20000;
            } else {
                pr_err("Format 0x%x not supported\n", sensor_format);
                return -1;
            }
        } else if (sensor_format == 0x1008) {
            mipi_config = 0x80000;
        } else if (sensor_format >= 0x1009) {
            if ((sensor_format - 0x2002) >= 4) {
                pr_err("Format 0x%x not supported\n", sensor_format);
                return -1;
            }
            mipi_config = 0xc0000;
        } else if (sensor_format == 0x1006) {
            mipi_config = 0xa0000;
        } else {
            /* Default case - includes RAW10 (0x2b) */
            mipi_config = 0x20000;
        }
        
        /* Binary Ninja: 00010a08-00010a30 - Apply width/height flags */
        if (sensor_attr->total_width == 2) {
            mipi_config |= 2;
        }
        if (sensor_attr->total_height == 2) {
            mipi_config |= 1;
        }
        
        /* Binary Ninja: 00010a2c-00010a78 - Integration time and gain */
        u32 integration_time = sensor_attr->integration_time;
        if (integration_time != 0) {
            writel((integration_time << 16) + vic_dev->width, vic_regs + 0x18);
        }
        
        u32 again = sensor_attr->again;
        if (again != 0) {
            writel(again, vic_regs + 0x3c);
        }
        
        /* Binary Ninja: 00010a90-00010aa8 - Final MIPI config */
        writel((sensor_attr->total_width << 31) | mipi_config, vic_regs + 0x10);
        writel((vic_dev->width << 16) | vic_dev->height, vic_regs + 0x4);
        wmb();
        
        /* Binary Ninja: 00010ab4-00010ac0 - Unlock sequence */
        writel(2, vic_regs + 0x0);
        wmb();
        writel(4, vic_regs + 0x0);
        wmb();
        
        /* Binary Ninja: 00010acc - Wait for unlock */
        while (readl(vic_regs + 0x0) != 0) {
            udelay(1);
            if (--timeout == 0) {
                pr_err("VIC unlock timeout\n");
                return -ETIMEDOUT;
            }
        }
        
        /* Binary Ninja: 00010ad4 - Enable VIC */
        writel(1, vic_regs + 0x0);
        wmb();
        
        /* Binary Ninja: 00010ae4-00010b04 - Final MIPI registers */
        writel(0x100010, vic_regs + 0x1a4);
        writel(0x4210, vic_regs + 0x1ac);
        writel(0x10, vic_regs + 0x1b0);
        writel(0, vic_regs + 0x1b4);
        wmb();
        
    } else if (interface_type == 3) {
        /* BT601 - Binary Ninja 00010688-000107d4 */
        pr_info("BT601 interface configuration\n");
        
        writel(1, vic_regs + 0xc);
        
        int gpio_mode = sensor_attr->dbus_type;
        u32 bt601_config;
        
        if (gpio_mode == 0) {
            bt601_config = 0x800c8000;
        } else if (gpio_mode == 1) {
            bt601_config = 0x88060820;
        } else {
            pr_err("Unsupported GPIO mode\n");
            return -1;
        }
        
        writel(bt601_config, vic_regs + 0x10);
        writel((vic_dev->width << 1) | 0x100000, vic_regs + 0x18);
        writel(0x30, vic_regs + 0x3c);
        writel(0x1b8, vic_regs + 0x1c);
        writel(0x1402d0, vic_regs + 0x30);
        writel(0x50014, vic_regs + 0x34);
        writel(0x2d00014, vic_regs + 0x38);
        writel(0, vic_regs + 0x1a0);
        writel(0x100010, vic_regs + 0x1a4);
        writel(0x4440, vic_regs + 0x1ac);
        writel((vic_dev->width << 16) | vic_dev->height, vic_regs + 0x4);
        
        writel(2, vic_regs + 0x0);
        wmb();
        writel(1, vic_regs + 0x0);
        
    } else if (interface_type == 4) {
        /* BT656 - Binary Ninja 000105b0-00010684 */
        pr_info("BT656 interface configuration\n");
        
        writel(0, vic_regs + 0xc);
        writel(0x800c0000, vic_regs + 0x10);
        writel((vic_dev->width << 16) | vic_dev->height, vic_regs + 0x4);
        writel(vic_dev->width << 1, vic_regs + 0x18);
        writel(0x100010, vic_regs + 0x1a4);
        writel(0x4440, vic_regs + 0x1ac);
        writel(0x200, vic_regs + 0x1d0);
        writel(0x200, vic_regs + 0x1d4);
        
        writel(2, vic_regs + 0x0);
        wmb();
        writel(1, vic_regs + 0x0);
        
    } else if (interface_type == 5) {
        /* BT1120 - Binary Ninja 00010500-00010684 */
        pr_info("BT1120 interface configuration\n");
        
        writel(4, vic_regs + 0xc);
        writel(0x800c0000, vic_regs + 0x10);
        writel((vic_dev->width << 16) | vic_dev->height, vic_regs + 0x4);
        writel(vic_dev->width << 1, vic_regs + 0x18);
        writel(0x100010, vic_regs + 0x1a4);
        writel(0x4440, vic_regs + 0x1ac);
        
        writel(2, vic_regs + 0x0);
        wmb();
        writel(1, vic_regs + 0x0);
        
    } else {
        pr_err("Unsupported interface type %d\n", interface_type);
        return -1;
    }

    /* Binary Ninja: 00010b48-00010b74 - Log WDR mode */
    if (sensor_attr->wdr_cache != 0) {
        pr_info("tx_isp_vic_start: WDR mode enabled\n");
    } else {
        pr_info("tx_isp_vic_start: Linear mode enabled\n");
    }

    /* Binary Ninja: 00010b84 - Set vic_start_ok */
    vic_start_ok = 1;
    pr_info("*** VIC start completed - vic_start_ok = 1 ***\n");

    /* CRITICAL: Enable ISP core interrupt generation - EXACT Binary Ninja reference */
    if (ourISPdev && ourISPdev->core_regs) {
        void __iomem *core = ourISPdev->core_regs;

        /* Clear any pending interrupts first */
        u32 pend_legacy = readl(core + 0xb4);
        u32 pend_new    = readl(core + 0x98b4);
        writel(pend_legacy, core + 0xb8);
        writel(pend_new,    core + 0x98b8);

        /* CRITICAL: Enable ISP pipeline connection - this is what was missing! */
        /* Binary Ninja: system_reg_write(0x800, 1) - Enable ISP pipeline */
        writel(1, core + 0x800);

        /* Binary Ninja: system_reg_write(0x804, routing) - Configure ISP routing */
        writel(0x1c, core + 0x804);

        /* Binary Ninja: system_reg_write(0x1c, 8) - Set ISP control mode */
        writel(8, core + 0x1c);

        /* CRITICAL: Enable ISP core interrupt generation at hardware level */
        /* Binary Ninja: system_reg_write(0x30, 0xffffffff) - Enable all interrupt sources */
        writel(0xffffffff, core + 0x30);

        /* Binary Ninja: system_reg_write(0x10, 0x133) - Enable specific interrupt types */
        writel(0x133, core + 0x10);

        /* Enable interrupt banks */
        writel(0x3FFF, core + 0xb0);
        writel(0x3FFF, core + 0xbc);
        writel(0x3FFF, core + 0x98b0);
        writel(0x3FFF, core + 0x98bc);
        wmb();

        pr_info("*** ISP PIPELINE: VIC->ISP connection ENABLED (0x800=1, 0x804=0x1c, 0x1c=8) ***\n");
        pr_info("*** ISP CORE: Hardware interrupt generation ENABLED during VIC init ***\n");
        pr_info("*** VIC->ISP: Pipeline should now generate hardware interrupts when VIC completes frames! ***\n");
    } else {
        pr_warn("*** ISP CORE IRQ: core_regs not mapped; unable to enable core interrupts here ***\n");
    }

    /* Also enable the kernel IRQ line if it was registered earlier */
    if (ourISPdev && ourISPdev->isp_irq > 0) {
        enable_irq(ourISPdev->isp_irq);
        pr_info("*** ISP CORE IRQ: enable_irq(%d) called ***\n", ourISPdev->isp_irq);
    }

    return 0;
}